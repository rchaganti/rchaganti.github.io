<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kubernetes on Ravikanth Chaganti</title>
    <link>https://ravichaganti.com/tags/kubernetes/</link>
    <description>Recent content in Kubernetes on Ravikanth Chaganti</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 14 Mar 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://ravichaganti.com/tags/kubernetes/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Kube Resource Orchestrator (KRO) - Deploying the sample voting application</title>
      <link>https://ravichaganti.com/blog/kube-resource-orchestrator-kro-deploying-the-sample-voting-application/</link>
      <pubDate>Fri, 14 Mar 2025 00:00:00 +0000</pubDate>
      <guid>https://ravichaganti.com/blog/kube-resource-orchestrator-kro-deploying-the-sample-voting-application/</guid>
      <description>&lt;p&gt;In today&amp;rsquo;s article, you will build upon what you learned in the earlier article about the &lt;a href=&#34;https://cloudnativecentral.com/posts/kube-resource-orchestrator-the-basics/&#34;&gt;basics&lt;/a&gt; of &lt;code&gt;kro&lt;/code&gt;. To demonstrate a few more &lt;code&gt;kro&lt;/code&gt; concepts, we will use the famous &lt;a href=&#34;https://github.com/dockersamples/example-voting-app&#34;&gt;sample voting&lt;/a&gt; application.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/dockersamples/example-voting-app/raw/main/architecture.excalidraw.png&#34; alt=&#34;Sample voting app&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;While not very complex, this application has enough moving parts to define dependencies. In this article, we shall look at the custom API needed to instantiate this voting application on Kubernetes. In this example, we must bring up the &lt;code&gt;redis&lt;/code&gt; and &lt;code&gt;db&lt;/code&gt; services as &lt;code&gt;ClusterIP&lt;/code&gt; services before the &lt;code&gt;vote&lt;/code&gt; and &lt;code&gt;result&lt;/code&gt; services, which are &lt;code&gt;NodePort&lt;/code&gt; type.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Kube Resource Orchestrator (KRO) - The Basics</title>
      <link>https://ravichaganti.com/blog/kube-resource-orchestrator-kro-the-basics/</link>
      <pubDate>Sun, 09 Mar 2025 00:00:00 +0000</pubDate>
      <guid>https://ravichaganti.com/blog/kube-resource-orchestrator-kro-the-basics/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://helm.sh/&#34;&gt;Helm&lt;/a&gt; helps application developers and operators manage Kubernetes applications. It allows you to define, install, and upgrade Kubernetes applications. Helm uses a packaging format called charts, a collection of files describing a related set of Kubernetes resources. Other application packaging solutions, such as &lt;a href=&#34;https://kubectl.docs.kubernetes.io/references/kustomize/&#34;&gt;Kustomize&lt;/a&gt;, exist, but nothing comes close to the popularity Helm gained in the Cloud Native space. While Helm is certainly the most popular package manager, it comes with a few limitations. Helm does not offer an efficient dependency management solution. At deployment time, there is no way you can retrieve the dependent resource properties for subsequent resource deployment within the chart. Helm cannot handle custom resource definitions well. We must use &lt;code&gt;values.yaml&lt;/code&gt; to supply custom values to the chart and its subcharts. This has no schema validation and, therefore, results in human errors at the time of deployment. Helm does not offer any post-deployment reconciliation support, which is important to ensure any drift in application configuration can be detected and corrected. Companies in the Cloud-native space have been looking at alternatives, and a new open-source project called &lt;code&gt;kro&lt;/code&gt; may be that alternative.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Fully automated Kubernetes cluster deployment on Azure in under 8 minutes</title>
      <link>https://ravichaganti.com/blog/2022-11-26-fully-automated-kubernetes-cluster-deployment-on-azure-in-under-8-minutes/</link>
      <pubDate>Sat, 26 Nov 2022 00:00:00 +0000</pubDate>
      <guid>https://ravichaganti.com/blog/2022-11-26-fully-automated-kubernetes-cluster-deployment-on-azure-in-under-8-minutes/</guid>
      <description>&lt;p&gt;In an earlier article, I wrote about provisioning a virtual Kubernetes cluster with kubeadm](&lt;a href=&#34;https://ravichaganti.com/blog/2022-11-13-installing-and-configuring-kubernetes-cluster-using-kubeadm-on-ubuntu/)&#34;&gt;https://ravichaganti.com/blog/2022-11-13-installing-and-configuring-kubernetes-cluster-using-kubeadm-on-ubuntu/)&lt;/a&gt;. I use this method on a laptop with limited resources. This is good to a large extent but not good enough when I want to scale my experiments and learning. This is where I began planning my Kubernetes lab on Azure. I needed something I could spin quickly with no manual intervention. Given my interest in the Bicep language, I naturally wrote a Bicep template to perform this deployment.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Fully Automated Kubernetes Cluster Deployment on Azure in Under 8 Minutes</title>
      <link>https://ravichaganti.com/blog/fully-automated-kubernetes-cluster-deployment-on-azure-in-under-8-minutes/</link>
      <pubDate>Sat, 26 Nov 2022 00:00:00 +0000</pubDate>
      <guid>https://ravichaganti.com/blog/fully-automated-kubernetes-cluster-deployment-on-azure-in-under-8-minutes/</guid>
      <description>&lt;p&gt;In an earlier article, I had written about &lt;a href=&#34;https://ravichaganti.com/posts/installing-and-configuring-kubernetes-cluster-using-kubeadm-on-ubuntu/&#34;&gt;provisioning a virtual Kubernetes cluster using kubeadm&lt;/a&gt;. I use this method on a laptop with limited resources. This is good to a large extent but not good enough when I want to scale my experiments and learning. This is where I started looking at creating my Kubernetes lab on Azure. I needed something that could spin fast and without manual intervention. Given my interest in the Bicep language, I wrote a Bicep template to perform this deployment.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Installing and Configuring Kubernetes cluster using kubeadm on Ubuntu</title>
      <link>https://ravichaganti.com/blog/2022-11-13-installing-and-configuring-kubernetes-cluster-using-kubeadm-on-ubuntu/</link>
      <pubDate>Sun, 13 Nov 2022 00:00:00 +0000</pubDate>
      <guid>https://ravichaganti.com/blog/2022-11-13-installing-and-configuring-kubernetes-cluster-using-kubeadm-on-ubuntu/</guid>
      <description>&lt;p&gt;This article is more like a note to myself, but this may help if you are looking at configuring a Kubernetes cluster on Ubuntu.&lt;/p&gt;&#xA;&lt;p&gt;There are many ways to install and configure Kubernetes cluster for learning and development purposes. You can use &lt;a href=&#34;https://www.docker.com/products/docker-desktop/&#34;&gt;Docker Desktop&lt;/a&gt; or &lt;a href=&#34;https://rancherdesktop.io/&#34;&gt;Rancher Desktop&lt;/a&gt; or &lt;a href=&#34;https://podman-desktop.io/&#34;&gt;https://podman-desktop.io/&lt;/a&gt; or &lt;a href=&#34;https://minikube.sigs.k8s.io/docs/start/&#34;&gt;minikube&lt;/a&gt; or &lt;a href=&#34;https://microk8s.io/&#34;&gt;microk8s&lt;/a&gt; to create a single node cluster for your development work quickly. I am a big fan of Docker Desktop and use that for any quick experiments. However, I need a multi-node cluster with additional services for anything more than simple deployment. I use Ubuntu virtual machines and configure a Kubernetes cluster using &lt;a href=&#34;https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/&#34;&gt;kubeadm&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Installing and Configuring Kubernetes Cluster using Kubeadm on Ubuntu</title>
      <link>https://ravichaganti.com/blog/installing-and-configuring-kubernetes-cluster-using-kubeadm-on-ubuntu/</link>
      <pubDate>Sun, 13 Nov 2022 00:00:00 +0000</pubDate>
      <guid>https://ravichaganti.com/blog/installing-and-configuring-kubernetes-cluster-using-kubeadm-on-ubuntu/</guid>
      <description>&lt;p&gt;There are many ways to install and configure a Kubernetes cluster for learning and development purposes. We can use &lt;a href=&#34;https://www.docker.com/products/docker-desktop/&#34;&gt;Docker Desktop&lt;/a&gt;, &lt;a href=&#34;https://rancherdesktop.io/&#34;&gt;Rancher Desktop&lt;/a&gt;, &lt;a href=&#34;https://podman-desktop.io/&#34;&gt;Podman Desktop&lt;/a&gt;, &lt;a href=&#34;https://minikube.sigs.k8s.io/docs/start/&#34;&gt;minikube&lt;/a&gt;, or &lt;a href=&#34;https://microk8s.io/&#34;&gt;microk8s&lt;/a&gt; to quickly create a single-node cluster for our development work. These are good for quick development work but not so much when we need a multi-node cluster with additional services. For such a scenario, we can use virtual machines and configure a Kubernetes cluster using &lt;a href=&#34;https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/&#34;&gt;kubeadm&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;This article examines the steps necessary to set up a virtual Kubernetes cluster.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
