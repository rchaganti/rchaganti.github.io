<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Cloud-Native on Ravikanth Chaganti</title>
    <link>https://ravichaganti.com/tags/cloud-native/</link>
    <description>Recent content in Cloud-Native on Ravikanth Chaganti</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 03 Feb 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://ravichaganti.com/tags/cloud-native/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Devcontainers for cloud-native application development</title>
      <link>https://ravichaganti.com/blog/devcontainers-for-cloud-native-application-development/</link>
      <pubDate>Sat, 03 Feb 2024 00:00:00 +0000</pubDate>
      <guid>https://ravichaganti.com/blog/devcontainers-for-cloud-native-application-development/</guid>
      <description>&lt;p&gt;Containers changed the way we develop, package, and distribute applications. This helped teams accelerate development and ensure their code worked consistently across different environments and infrastructures. To a large extent, this enabled write once and run anywhere. Docker made this easy by providing tools to create, manage, and package application code and dependencies as images. We could run a container instance from that image wherever a container runtime exists. Standardizing image and runtime formats helped ensure we could take an image and run it anywhere and not worry about the underlying infrastructure. This also led to the proliferation of microservices-based application architectures, where an application comprises several services running within containers to deliver the expected functionality. Most cloud-native and modern application architectures use microservices to implement the necessary functionality. When developing an application with multiple microservice dependencies, a developer must ensure the development environment is suitably set up to handle all required dependencies.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Using Bicep to provision Azure Red Hat OpenShift cluster</title>
      <link>https://ravichaganti.com/blog/using-bicep-to-provision-azure-red-hat-openshift-cluster/</link>
      <pubDate>Fri, 01 Dec 2023 00:00:00 +0000</pubDate>
      <guid>https://ravichaganti.com/blog/using-bicep-to-provision-azure-red-hat-openshift-cluster/</guid>
      <description>&lt;p&gt;Azure Red Hat OpenShift (ARO) service provides fully managed and highly available OpenShift clusters on Azure jointly operated by Microsoft and Red Hat. There are different ways to provision an ARO cluster.&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Azure Portal&lt;/li&gt;&#xA;&lt;li&gt;Azure CLI or Azure PowerShell&lt;/li&gt;&#xA;&lt;li&gt;Azure Resource Manager (ARM) / Bicep templates&lt;/li&gt;&#xA;&lt;li&gt;Red Hat Advanced Cluster Management (RHACM)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;This article will explore using Bicep language to provision an ARO cluster.&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Examples in this article use Azure CLI for interacting with Azure resources and deployments.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
