<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Azure on Ravikanth Chaganti</title>
    <link>https://ravichaganti.com/tags/azure/</link>
    <description>Recent content in Azure on Ravikanth Chaganti</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Thu, 30 Jul 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://ravichaganti.com/tags/azure/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Azure Resource Manager - Using expressions and variables in ARM templates</title>
      <link>https://ravichaganti.com/blog/azure-resource-manager-in-30-days-using-expressions-and-variables-in-arm-templates/</link>
      <pubDate>Thu, 30 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ravichaganti.com/blog/azure-resource-manager-in-30-days-using-expressions-and-variables-in-arm-templates/</guid>
      <description>
    &lt;figure &gt;
        
            &lt;img src=&#34;https://ravichaganti.com/images/armin30/templatearchitecture.png&#34; width=&#34;760&#34; /&gt;
        
        
    &lt;/figure&gt;
    
&lt;p&gt;So far in &lt;a href=&#34;https://ravichaganti.com/series/azure-resource-manager-in-30-days/&#34;&gt;this series&lt;/a&gt;, you learned how to use VS Code and ARM Tools extension to get started with the ARM template development, how to perform a subscription scoped deployment to create a resource group and then looked at resource group scoped deployment to create a storage account and a virtual network resources. You learned about parameterizing the ARM template so that it becomes reusable. Equipped with that knowledge, you can now start digging into expressions and variables in the ARM templates.&lt;/p&gt;
&lt;h2 id=&#34;expressions&#34;&gt;Expressions&lt;/h2&gt;
&lt;p&gt;You have already used expressions in the template you built in the last part. For example, &lt;code&gt;[parameters(&#39;storageAccountSku&#39;)]&lt;/code&gt; is an expression that you used. Within an ARM template, expressions are a way to dynamically determine values of resource properties and other artifacts. Expressions are invoked within square brackets and are calculated at deployment time. When creating an expression, you can combine multiple &lt;a href=&#34;https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/template-functions&#34;&gt;template functions&lt;/a&gt;. For example, in the previous template that provisioned a storage account and a virtual network, the storage account name has to be unique. Now, either you can let the end user figure out a unique string for this resource property by trial and error or you can use an expression such as &lt;code&gt;[concat(&#39;sacct&#39;, &#39;-&#39;, uniqueString(resourceGroup().id))]&lt;/code&gt; to generate a random string to use as a name for the storage account you want provision. Remember that, within the same resource group, the value generated by this expression will always be same since the seed to the &lt;code&gt;uniqueString()&lt;/code&gt; function will always be same. So, when you deploy a template that uses this expression multiple times, no action will be taken if the storage account already exists with the name.&lt;/p&gt;
&lt;p&gt;There are several categories of standard (built-in) template functions that you can use to simplify template authoring and deployment experience. These functions include comparison and logical functions, numeric and string functions, array, object, and date functions, and resource and deployment value functions. For example, the &lt;code&gt;concat()&lt;/code&gt; function that you saw in the earlier example is a part of &lt;a href=&#34;https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/template-functions-string&#34;&gt;string functions&lt;/a&gt; category. It takes multiple strings and returns a concatenated string. A &lt;code&gt;concat()&lt;/code&gt; function exists in the &lt;a href=&#34;https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/template-functions-array&#34;&gt;array functions&lt;/a&gt; category as well and works on arrays and returns a concatenated array. The &lt;code&gt;uniqueString()&lt;/code&gt; function is in the string functions category and generates a hash based on the value passed as its argument. The &lt;code&gt;resourceGroup()&lt;/code&gt; function is a part of the &lt;a href=&#34;https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/template-functions-resource&#34;&gt;resource functions&lt;/a&gt; category and returns the properties of the resource group within which the deployment is in progress.&lt;/p&gt;
&lt;p&gt;Let us see another example of using expressions in ARM templates. In the template that was develope d in the last part, the &lt;code&gt;storageAccountName&lt;/code&gt; parameter was used the capture the input for the name property of the storage account resource. In this parameter definition, &lt;code&gt;minLength&lt;/code&gt; and &lt;code&gt;maxLength&lt;/code&gt; elements were used to ensure the string length is between 3 and 24 characters. However, the name of the storage account name should always be in lower case. There is no element in parameter definition to describe this validation. This can be achieved by using the &lt;code&gt;toLower()&lt;/code&gt; function from the string functions category to transform the user provided input value into a lower case string. Here is how it can be done.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/rchaganti/d7e35878c6687da07ae5fa5dfb7d54c2.js?file=storageResourceWithToLower.json&#34;&gt;&lt;/script&gt;

&lt;p&gt;These are just a few examples of how you can use standard template functions in ARM templates as a part of different expressions. I recommend that you read through the &lt;a href=&#34;https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/template-functions&#34;&gt;documentation&lt;/a&gt; to understand how to use these functions in an expression and explore how you can simplify the template deployment experience. But, how do you evaluate an expression that you want to use in an ARM template?&lt;/p&gt;
&lt;h3 id=&#34;evaluating-expressions&#34;&gt;Evaluating Expressions&lt;/h3&gt;
&lt;p&gt;Waiting for a real resource template deployment may be not be a great idea and a way to evaluate expression output without initiating a real deployment would be beneficial. This is totally possible with the &lt;code&gt;outputs&lt;/code&gt; element in an ARM template.&lt;/p&gt;
&lt;p&gt;As you learned in the template basics, the &lt;code&gt;outputs&lt;/code&gt; element in a template is used to return values from after a deployment is complete. This is especially useful in automated deployment processes. Except for a few that are runtime functions such as &lt;code&gt;reference()&lt;/code&gt;, this method can be used with most of the standard template functions and expressions that you create. In general, the following snippet shows the syntax of &lt;code&gt;outputs&lt;/code&gt; element.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/rchaganti/d7e35878c6687da07ae5fa5dfb7d54c2.js?file=outputSyntax.json&#34;&gt;&lt;/script&gt;

&lt;p&gt;This is a simplified syntax of &lt;code&gt;outputs&lt;/code&gt; element. There are other properties you can use but for now, this is good enough.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Element Name&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;th&gt;Is Required&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;output-name&lt;/td&gt;
&lt;td&gt;Name of the output value&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;type&lt;/td&gt;
&lt;td&gt;type of the output value&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;value&lt;/td&gt;
&lt;td&gt;Expression that should be evaluated and returned as output value&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;To try this method of using &lt;code&gt;outputs&lt;/code&gt; element , you can create an ARM template with no resource definitions as shown below.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/rchaganti/d7e35878c6687da07ae5fa5dfb7d54c2.js?file=outputDemo.azrm.json&#34;&gt;&lt;/script&gt;

&lt;p&gt;In the outputs element definition, the name of the output value has been set to &lt;code&gt;lowercaseStorageAccountName&lt;/code&gt; and the output value is set to &lt;code&gt;[toLower(parameters(&#39;StorageAccountName&#39;))]&lt;/code&gt;. Although there is just one output from this example template, there can be any number of outputs from a given ARM template. The above ARM template can be deployed using of the known deployment tools to see the value the expression evaluates to. Let us see an example using Azure CLI.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/rchaganti/d7e35878c6687da07ae5fa5dfb7d54c2.js?file=deployForEvalOutput.azcli&#34;&gt;&lt;/script&gt;

&lt;p&gt;In the command above, inline parameter specification has been used and the value for the &lt;code&gt;storageAccountName&lt;/code&gt; has been set to a string containing mixed case characters. The expression used in the output value element should return this string with all characters in lower case.&lt;/p&gt;
&lt;p&gt;When you deploy using Azure CLI or Azure PowerShell, the command output contains the deployment output as well when the template deployment completes successfully. The default output format in Azure CLI is JSON. So, when the command completes successfully, you will see the JSON string returned to the command console.&lt;/p&gt;

    &lt;figure &gt;
        
            &lt;img src=&#34;https://ravichaganti.com/images/armin30/outputEvalExprDemo.png&#34; width=&#34;670&#34; /&gt;
        
        
    &lt;/figure&gt;
    
&lt;p&gt;This JSON output can be queried using &lt;a href=&#34;https://docs.microsoft.com/en-us/cli/azure/query-azure-cli?view=azure-cli-latest&#34;&gt;JMESPath&lt;/a&gt;. All you have to do is append &lt;code&gt;--query properties.outputs.&amp;lt;output_value_name&amp;gt;.value&lt;/code&gt; to the above Azure CLI deployment command.&lt;/p&gt;
&lt;p&gt;Output values from the template&amp;rsquo;s &lt;code&gt;outputs&lt;/code&gt; element can be seen in the Azure portal as well if you navigate to the resource group and check the deployment history.&lt;/p&gt;

    &lt;figure &gt;
        
            &lt;img src=&#34;https://ravichaganti.com/images/armin30/portalOutput.png&#34; width=&#34;670&#34; /&gt;
        
        
    &lt;/figure&gt;
    
&lt;h2 id=&#34;variables&#34;&gt;Variables&lt;/h2&gt;
&lt;p&gt;Variables are a way to help reduce complexity in an ARM template. In the template that deployed a storage account and a virtual network, we used seven parameters to collect the input required for the template deployment. This provides flexibility in choosing desired values for the deployment. While this flexibility is good, you may want to use fixed address prefixes for virtual network and subnets that you deploy as a part of the template. One way to achieve this is to hard code these values in resource properties. Hard coding values results in repetition and any unintentional mistakes that lead to errors in deployment. Also, there may be certain resource property values that you want to auto-generate based on the value of a specific parameter. This is where variables in ARM template syntax play a role.&lt;/p&gt;
&lt;p&gt;Here is the simplified syntax for adding variables in an ARM template.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/rchaganti/d7e35878c6687da07ae5fa5dfb7d54c2.js?file=variableSyntax.json&#34;&gt;&lt;/script&gt;

&lt;p&gt;Simple variable declaration is straightforward. You just need to add a key-value pair for the variable name and it&amp;rsquo;s value. Here is how you may simplify the earlier template.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/rchaganti/d7e35878c6687da07ae5fa5dfb7d54c2.js?file=variablesForStorageAndVNet.json&#34;&gt;&lt;/script&gt;

&lt;p&gt;This variable definition eliminates the need for three parameters - &lt;code&gt;virtualNetworkAddressPrefix&lt;/code&gt;, &lt;code&gt;virtualNetworkSubnetName&lt;/code&gt;, and &lt;code&gt;virtualNetworkSubnetAddressPrefix&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;accessing-variable-values&#34;&gt;Accessing variable values&lt;/h3&gt;
&lt;p&gt;Within the resource definitions, you can access the values of variables using the &lt;code&gt;variables()&lt;/code&gt; function in an expression. Here is the updated template that uses variables for a few resource properties.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/rchaganti/d7e35878c6687da07ae5fa5dfb7d54c2.js?file=d4RgScopedStorageVNetTemplateFinal.azrm.json&#34;&gt;&lt;/script&gt;

&lt;p&gt;You can deploy this template by clicking on the deploy to Azure button.&lt;/p&gt;

    &lt;a href=&#34;https://portal.azure.com/#create/Microsoft.Template/uri/https%3a%2f%2fgist.githubusercontent.com%2frchaganti%2fd7e35878c6687da07ae5fa5dfb7d54c2%2fraw%2fd5RgScopedStorageVNetTemplateFinal.json&#34; target=&#34;_blank&#34;&gt;
        &lt;img src=&#34;https://raw.githubusercontent.com/Azure/azure-quickstart-templates/master/1-CONTRIBUTION-GUIDE/images/deploytoazure.svg?sanitize=true&#34; alt=&#34;&#34;&gt;
    &lt;/a&gt;
    &lt;br /&gt;

&lt;p&gt;In the portal template deployment experience, you will see that the number of input parameters have reduced but the final result stays same. You can try deploying this template via the Azure CLI using the same set of commands you tried in the last part.&lt;/p&gt;
&lt;h3 id=&#34;free-form-vs-known-configuration&#34;&gt;Free-form vs known configuration&lt;/h3&gt;
&lt;p&gt;So far, you have learned about are parameters, variables, and learn to use them in ARM templates. Parameters enable the flexibility to gather input from user deploying the template. You can parameterize a complete template and let the user provide every value needed for the deployment as an input parameter. This is called &lt;strong&gt;free-form configuration&lt;/strong&gt;. However, using free-form configuration is not always scalable. The number of parameters that a user need to input might be overwhelming. Also, you don’t want your end user deploying this template to mess-up with critical resource properties such as virtual network and subnet address prefixes. This can have negative effects on the overall infrastructure deployment. As you have seen in the updated template, you might always want to use fixed values for certain parameters where there is scope for errors. Some of this cannot be controlled unless you use &lt;strong&gt;known configurations&lt;/strong&gt;. Known configurations help standardize resource configurations. Use variables in the template for resource settings that require no user input or you need control over. By using variables, you can simply change the value of the variable if at all you need to modify the template instead of trying to find where all the value is used.&lt;/p&gt;
&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;
&lt;p&gt;Expressions syntax in ARM templates enable combining multiple standard functions provided by the ARM template language. Variables when combined with expression syntax can simplify the overall template authoring experience. Choosing between free-form vs known configurations for the ARM template, you can create a template that is both flexible and implements known configurations to control how the deployed infrastructure gets configured. With this knowledge around parameters, variables, and expressions, in the next part of this series, you will learn more about some of the standard functions and learn how to implement user-defined functions.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Azure Resource Manager - Adding parameters to ARM templates</title>
      <link>https://ravichaganti.com/blog/azure-resource-manager-adding-parameters-to-arm-templates/</link>
      <pubDate>Fri, 24 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ravichaganti.com/blog/azure-resource-manager-adding-parameters-to-arm-templates/</guid>
      <description>
    &lt;figure &gt;
        
            &lt;img src=&#34;https://ravichaganti.com/images/armin30/templatearchitecture.png&#34; width=&#34;760&#34; /&gt;
        
        
    &lt;/figure&gt;
    
&lt;p&gt;In the &lt;a href=&#34;https://ravichaganti.com/blog/azure-resource-manager-arm-template-basics/&#34;&gt;last part&lt;/a&gt; of &lt;a href=&#34;https://ravichaganti.com/series/azure-resource-manager-in-30-days/&#34;&gt;this series&lt;/a&gt;, you learned the template syntax and authored an ARM template that provisions the resource group needed for the above architecture. This deployment was performed at the subscription level using Azure CLI. In this part, you will create another template for performing additional resource &amp;ndash; storage account and virtual network &amp;ndash; provisioning at the resource group level. You will, then, parameterize this template to understand how to add parameters to ARM templates.&lt;/p&gt;
&lt;h2 id=&#34;resource-group-deployment&#34;&gt;Resource group deployment&lt;/h2&gt;
&lt;p&gt;Deployments scoped at the resource group level are the most common deployments. In this method, you provision resources within a resource group in your subscription. Within the VS Code editor, typing &lt;code&gt;arm!&lt;/code&gt; brings up the snippet for a resource group scoped ARM template.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/rchaganti/d7e35878c6687da07ae5fa5dfb7d54c2.js?file=rgScopedDeploymentSkeleton.azrm.json&#34;&gt;&lt;/script&gt;

&lt;p&gt;You can see in the above snippet that the &lt;code&gt;$schema&lt;/code&gt; value is different from what was used for a subscription scoped deployment. Within this template, you can either right-click in the editor window and select Insert Item in the context menu and select Resource or click &lt;code&gt;+&lt;/code&gt; next to resources in the ARM template outline to add any additional resources you need.&lt;/p&gt;

    &lt;figure &gt;
        
            &lt;img src=&#34;https://ravichaganti.com/images/armin30/d3-insertresource.png&#34; width=&#34;760&#34; /&gt;
        
        
    &lt;/figure&gt;
    
&lt;p&gt;Either of these options will present you with a list of available resource types. To add a storage account resource type, select &lt;code&gt;Storage Account&lt;/code&gt; from the list of resources. You may go ahead and add a virtual network resource as well. This is how the updated template will look like.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/rchaganti/d7e35878c6687da07ae5fa5dfb7d54c2.js?file=rgScopedDeployment.azrm.json&#34;&gt;&lt;/script&gt;

&lt;p&gt;As you see here, the insert resources method adds the resource definitions with pre-defined default values. You may not be able deploy this as-is since some of the resource names (storage account especially) might be taken already. You may enter some unique names for the resources and try template deployment using the deploy to Azure button below.&lt;/p&gt;

    &lt;a href=&#34;https://portal.azure.com/#create/Microsoft.Template/uri/https%3a%2f%2fgist.githubusercontent.com%2frchaganti%2fd7e35878c6687da07ae5fa5dfb7d54c2%2fraw%2frgScopedDeployment.azrm.json&#34; target=&#34;_blank&#34;&gt;
        &lt;img src=&#34;https://raw.githubusercontent.com/Azure/azure-quickstart-templates/master/1-CONTRIBUTION-GUIDE/images/deploytoazure.svg?sanitize=true&#34; alt=&#34;&#34;&gt;
    &lt;/a&gt;
    &lt;br /&gt;

&lt;p&gt;When this template opens in the Azure portal, you will be prompted to select either an existing resource group or create a new resource group. Since you already created a resource group in the last part of this series, you can select the same. For the resources (storage account and virtual network), the selected resource group&amp;rsquo;s location will be used. This is specified in the template using the built-in &lt;code&gt;resourceGroup()&lt;/code&gt; function. You will learn more about these functions and expressions in a later part of the series. For now, just remember that &lt;code&gt;resourceGroup().location&lt;/code&gt; will give the location of the resource group selected for the resources&amp;rsquo; deployment.&lt;/p&gt;
&lt;h2 id=&#34;parameters-in-arm-templates&#34;&gt;Parameters in ARM templates&lt;/h2&gt;
&lt;p&gt;The template that you just built provides a good foundation to start experimenting with parameters in an ARM template. In the template above, there are several resource properties that can be parameterized so that the template becomes reusable between multiple deployments by providing the necessary input parameters. So, if you have to identify a few parameters within each resource, you may come with a list similar to the one below.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Resource&lt;/th&gt;
&lt;th&gt;Parameter Names&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;storageAccounts&lt;/td&gt;
&lt;td&gt;storageAccountName, storageAccountSku, storageAccountTier&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;virtualNetworks&lt;/td&gt;
&lt;td&gt;virtualNetworkName, virtualNetworkAddressPrefix, VirtualNetworkSubnetName, virtualNetworkSubnetAddressPrefix&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;With this list handy, take a look at the syntax for adding parameters.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/rchaganti/d7e35878c6687da07ae5fa5dfb7d54c2.js?file=parameterSyntax.json&#34;&gt;&lt;/script&gt;

&lt;p&gt;Within all possible elements described above for defining a parameter, only name and type are mandatory. Rest all elements provide a way to control the input values. For the type element, the allowed values are string, int, bool, securestring, object, secureObject, and array. The type of a parameter depends on the resource property that we choose to parameterize.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;allowedValues&lt;/code&gt; element in parameters can be used to define a set of valid values for the selected resource property. For example, Azure supports two type of storage tiers &amp;ndash; standard and premium &amp;ndash; for any storage SKU. Any other value for this property will be invalid. When an end user does not select any value out of the allowed values for a property, you can default to a known value using the &lt;code&gt;defaultValue&lt;/code&gt; element.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;maxLength&lt;/code&gt; and &lt;code&gt;minLength&lt;/code&gt; are used for string data types. Within the above template, these elements can be used for the &lt;code&gt;name&lt;/code&gt; property of the resources to define the minimum and maximum allowed length of the string input. For example, an Azure storage account name should be between 3 to 24 characters in length. These elements can be used with array type as well.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;minValue&lt;/code&gt; and &lt;code&gt;maxValue&lt;/code&gt; elements are used for parameters of int type. In the parameter selection that we did, there is no need for using these elements yet. You will see the use of these elements in a later part of this series.&lt;/p&gt;
&lt;p&gt;With this understanding, you can define the parameters for this template as below.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/rchaganti/d7e35878c6687da07ae5fa5dfb7d54c2.js?file=parametersford4template.json&#34;&gt;&lt;/script&gt;

&lt;p&gt;The parameter definitions above provide a clear idea about how to use the &lt;code&gt;allowedValues&lt;/code&gt; and &lt;code&gt;defaultValue&lt;/code&gt; elements in a parameter definition. Now, how do you use these parameter values in the template for resource properties?&lt;/p&gt;
&lt;h3 id=&#34;using-parameter-values&#34;&gt;Using parameter values&lt;/h3&gt;
&lt;p&gt;The built-in &lt;code&gt;parameters()&lt;/code&gt; function can be used to retrieve the value provided by the end user as a part of template deployment. This function takes the parameter name as the argument and retrieves the value. For example, &lt;code&gt;[parameters(&#39;storageAccountSku&#39;)]&lt;/code&gt;. You may now update the template above to change the static values to use the &lt;code&gt;parameters()&lt;/code&gt; function.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/rchaganti/d7e35878c6687da07ae5fa5dfb7d54c2.js?file=d4RgScopedStorageVNetTemplateFinal.azrm.json&#34;&gt;&lt;/script&gt;

&lt;h3 id=&#34;deploying-parameterized-templates&#34;&gt;Deploying parameterized templates&lt;/h3&gt;
&lt;p&gt;You can try deploying the parameterized template by clicking on the below deploy to Azure button.&lt;/p&gt;

    &lt;a href=&#34;https://portal.azure.com/#create/Microsoft.Template/uri/https%3a%2f%2fgist.githubusercontent.com%2frchaganti%2fd7e35878c6687da07ae5fa5dfb7d54c2%2fraw%2fd4RgScopedStorageVNetTemplateFinal.azrm.json&#34; target=&#34;_blank&#34;&gt;
        &lt;img src=&#34;https://raw.githubusercontent.com/Azure/azure-quickstart-templates/master/1-CONTRIBUTION-GUIDE/images/deploytoazure.svg?sanitize=true&#34; alt=&#34;&#34;&gt;
    &lt;/a&gt;
    &lt;br /&gt;

&lt;p&gt;This will bring up the input blade for this template deployment.&lt;/p&gt;

    &lt;figure &gt;
        
            &lt;img src=&#34;https://ravichaganti.com/images/armin30/d4-finalportaldeployment.png&#34; width=&#34;660&#34; /&gt;
        
        
    &lt;/figure&gt;
    
&lt;p&gt;Take a look at how the array value for the virtual network address prefix is provided. The &lt;code&gt;*&lt;/code&gt; next to a parameter name indicates a mandatory parameter or a parameter that has no default value. If you hover the &lt;code&gt;!&lt;/code&gt; icon next to the parameter name to see (balloon tip) what the parameter is about. This text is you added in the parameter &lt;code&gt;metadata&lt;/code&gt; element as &lt;code&gt;description&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The parameter &amp;lsquo;Virtual Network Address Prefix&amp;rsquo; accepts values of array type and it can be seen from the example above how array values are provided. The array values must be enclosed in square brackets.&lt;/p&gt;
&lt;p&gt;Now that you have tried the portal experience of deploying templates, take a look at how you can do that at the command line using Azure CLI. With Azure CLI, there are many ways of providing template parameter input. Inline parameter values is one such method.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/rchaganti/d7e35878c6687da07ae5fa5dfb7d54c2.js?file=d4-deployTemplateInlineParam.azcli&#34;&gt;&lt;/script&gt;

&lt;p&gt;In the above command, a resource group for the template deployment gets created first. The &lt;code&gt;az deployment group create&lt;/code&gt; command performs the template deployment by using the template URL as the argument to &lt;code&gt;--template-uri&lt;/code&gt; parameter and &lt;code&gt;--parameters&lt;/code&gt; is used to supply all template input parameter values. The URL specified as argument to the &lt;code&gt;--template-uri&lt;/code&gt; parameter must be accessible from Azure. As an alternate to the &lt;code&gt;--template-uri&lt;/code&gt; parameter, you can use the &lt;code&gt;--template-file&lt;/code&gt; to specify a local path to the template JSON file.&lt;/p&gt;
&lt;p&gt;As you see in the above Azure CLI command, all mandatory parameters (parameters with no default values) should be provided as key-value pairs separated by space. This can be quite daunting and error-prone if you have a lot of template parameters. You can also provide a JSON string as an argument to &lt;code&gt;--parameters&lt;/code&gt;. Also, when using Azure CLI, you must know the names of the parameters to be supplied as input. This is where the parameter files will come in very handy. You can either create one manually or use ARM Tools VS Code extension to generate one for you.&lt;/p&gt;
&lt;p&gt;To use VS Code extension to generate the parameter file, right-click anywhere in the template editor window and click &lt;em&gt;Select/Create Parameter File&lt;/em&gt;. In the command window, select &lt;em&gt;New&lt;/em&gt; and then &lt;em&gt;All Parameters&lt;/em&gt;. This will prompt for a name and location for the parameter JSON file. Here is how the generated parameter JSON will look like.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/rchaganti/d7e35878c6687da07ae5fa5dfb7d54c2.js?file=d4-paramJson.json&#34;&gt;&lt;/script&gt;

&lt;p&gt;You can fill-in the required values and use the following Azure CLI command to start the deployment.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/rchaganti/d7e35878c6687da07ae5fa5dfb7d54c2.js?file=d4-deployTemplateWithParamJson.azcli&#34;&gt;&lt;/script&gt;

&lt;p&gt;This command specification is way simpler than using inline parameters or JSON string.&lt;/p&gt;
&lt;p&gt;Apart from the inline key-value pair specification, the @d4-paramJson.json (@{path}) specification references a file in the local folder path. This is most preferred in case of CI &amp;amp; CD of ARM templates in which the parameter JSON file can be auto-generated during build processes. Also, you can use a mix of inline parameters and parameter JSON as well. You can explore more such examples using &lt;code&gt;az deployment group create --help&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;
&lt;p&gt;In this part, you looked at how to add resources to an ARM template and learned how to parameterize the template for reusability. Parameters in ARM templates support multiple data types and learned how to use string and array data types in this article. You will learn about using other data types in the later parts of this series. You learned how to use Azure portal and Azure CLI for template deployments. You looked at using inline parameter key-value specification and looked at creating and using parameter JSON files as well. In the next part, you will learn how to build expressions and variables in ARM templates.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Azure Resource Manager - ARM template basics</title>
      <link>https://ravichaganti.com/blog/azure-resource-manager-arm-template-basics/</link>
      <pubDate>Thu, 23 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ravichaganti.com/blog/azure-resource-manager-arm-template-basics/</guid>
      <description>&lt;p&gt;In the last two parts of &lt;a href=&#34;https://ravichaganti.com/series/azure-resource-manager-in-30-days/&#34;&gt;the series&lt;/a&gt;, you have seen a brief introduction to Azure Resource Manager and the services that complement ARM to extend its functionality or support the services offered by ARM. You also looked at an overview of ARM templates and the tools available to design, author, and deploy these templates.&lt;/p&gt;
&lt;p&gt;Starting this part of the series for the next few days, you will start learning about authoring ARM templates right from the basics and to the advanced template syntax and techniques with a goal to build an ARM template that helps provision the following architecture.&lt;/p&gt;

    &lt;figure &gt;
        
            &lt;img src=&#34;https://ravichaganti.com/images/armin30/templatearchitecture.png&#34; width=&#34;760&#34; /&gt;
        
        
    &lt;/figure&gt;
    
&lt;p&gt;This is not a complex architecture but gives you enough scope to implement what you learn through this series of articles. Apart from this architecture, I recommend that you start looking at the &lt;a href=&#34;https://github.com/Azure/AzureStack-QuickStart-Templates&#34;&gt;quickstart templates repository&lt;/a&gt; and read the templates there to understand the syntax and how some of those templates are written and implement best practices. Throughout this series, you will see examples from quickstart templates repository to explain best practices in template authoring.&lt;/p&gt;
&lt;p&gt;I strongly recommend using VS Code for ARM template authoring and the next section provides a quick overview of this before you dive into ARM template basics.&lt;/p&gt;
&lt;h2 id=&#34;vs-code-and-arm-tools-extension&#34;&gt;VS Code and ARM tools extension&lt;/h2&gt;
&lt;p&gt;If you have already installed VS Code and the ARM tools extension, you may want to customize the extension settings for improved authoring experience and ease. By default, VS Code editor will auto-detect template files if the JSON or JSONC file contains the appropriate schema and changes the editor language to Azure Resource Manager template. You can see this in the status bar of the VS Code editor.&lt;/p&gt;

    &lt;figure &gt;
        
            &lt;img src=&#34;https://ravichaganti.com/images/armin30/d3-editorarm.png&#34; /&gt;
        
        
    &lt;/figure&gt;
    
&lt;p&gt;However, this method requires that you at least have a value for the $schema element. You can also use file association setting to detect a file in the editor as an ARM template. This can be done by adding the following in the extension settings. With this setting in place, you can even create an empty file with an extension azrm.json and the editor auto-detects and sets the editor language as ARM template.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/rchaganti/d7e35878c6687da07ae5fa5dfb7d54c2.js?file=azrmtemplatefileassociation.json&#34;&gt;&lt;/script&gt;

&lt;p&gt;Once the editor language gets set to Azure Resource Manager Template, you can access over 70 snippets that come with the extension. For example, typing arm in the editor window, brings up the snippets that you can select and insert into the editor.&lt;/p&gt;

    &lt;figure &gt;
        
            &lt;img src=&#34;https://ravichaganti.com/images/armin30/d3-armsnippets.png&#34; width=&#34;600&#34; /&gt;
        
        
    &lt;/figure&gt;
    
&lt;p&gt;Throughout this series, you will see different features of this VS Code extension. Now, let us get started with the basics of the ARM template language.&lt;/p&gt;
&lt;h2 id=&#34;basics&#34;&gt;Basics&lt;/h2&gt;
&lt;p&gt;As you have seen already, an ARM template is JSON file with additional template functions and expressions that the Azure Resource Manager understands. Here is a basic skeleton structure of an ARM template.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/rchaganti/d7e35878c6687da07ae5fa5dfb7d54c2.js?file=skeleton.azrm.json&#34;&gt;&lt;/script&gt;

&lt;p&gt;In the following sections, you will see quick overview of the elements in an ARM template.&lt;/p&gt;
&lt;h3 id=&#34;schema&#34;&gt;$schema&lt;/h3&gt;
&lt;p&gt;This element identifies the version of template language to be used. The value of this element changes based on the type of editor and the scope of the deployment. There are four different scopes at which you can deploy an ARM template.&lt;/p&gt;
&lt;h4 id=&#34;subscription-scope&#34;&gt;Subscription Scope&lt;/h4&gt;
&lt;p&gt;When you need to deploy resources at the subscription level, for example create resource groups or provision policies and resource-based access controls, you need to use subscription level deployments. For this type of deployments, the value of &lt;code&gt;$schema&lt;/code&gt; should be &lt;code&gt;https://schema.management.azure.com/schemas/2018-05-01/subscriptionDeploymentTemplate.json#&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;management-group-scope&#34;&gt;Management Group Scope&lt;/h4&gt;
&lt;p&gt;Management groups in Azure are used to organize subscriptions for better governance. When you need to provision resources such as policies at the management group level, you need to the use the management group level schema. The value of this element for management group level deployments should be &lt;code&gt;https://schema.management.azure.com/schemas/2019-08-01/managementGroupDeploymentTemplate.json#&lt;/code&gt;.&lt;/p&gt;
&lt;h4 id=&#34;tenant-scope&#34;&gt;Tenant Scope&lt;/h4&gt;
&lt;p&gt;For provisioning resources across multiple Azure AD tenants, you need the tenant scoped deployments. For tenant level deployments the value of &lt;code&gt;$schema&lt;/code&gt; element should be set to &lt;code&gt;https://schema.management.azure.com/schemas/2019-08-01/tenantDeploymentTemplate.json#&lt;/code&gt;.&lt;/p&gt;
&lt;h4 id=&#34;resource-group-scope&#34;&gt;Resource Group Scope&lt;/h4&gt;
&lt;p&gt;This is the typical type of deployment you will normally come across. When using this deployment scope, you describe resources that need to be deployed within a given resource group in a subscription. The value of &lt;code&gt;$schema&lt;/code&gt; for this type of deployments in VS Code should be &lt;code&gt;https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#&lt;/code&gt;. For Visual Studio, this value should be &lt;code&gt;https://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;You will learn more about scoped deployments in a later article in this series.&lt;/p&gt;
&lt;h3 id=&#34;contentversion&#34;&gt;ContentVersion&lt;/h3&gt;
&lt;p&gt;This element identifies the version of the template content. This value is required but can be set to anything you want. If you use source control for ARM templates, you can increment the value of this element in your template at every commit. You will learn more about this in a later article discussing CI &amp;amp; CD of ARM templates.&lt;/p&gt;
&lt;h3 id=&#34;parameters&#34;&gt;Parameters&lt;/h3&gt;
&lt;p&gt;This element accepts a set of parameters that act as input to the ARM template deployment using which you can introduce reusability of ARM templates. If you are familiar with any programming language, similar to a function or a method parameters, ARM template parameters too support different data types, valid values, default values, and different other characteristics such as min and max values (for numeric types), and min and max length (for string types). This is not a mandatory element but highly recommended to parameterize the template.&lt;/p&gt;
&lt;h3 id=&#34;functions&#34;&gt;Functions&lt;/h3&gt;
&lt;p&gt;ARM template syntax support built-in functions and expressions. These functions range from comparison functions to numeric, date, string, and so on. In a later update to the ARM template syntax, support for custom user-defined functions was added. You can now define some complex expressions that you want to use in the template as user-defined functions. This is not a mandatory element.&lt;/p&gt;
&lt;h3 id=&#34;variables&#34;&gt;Variables&lt;/h3&gt;
&lt;p&gt;Variables, similar to functions, can help reduce the complexity of expressions in the ARM template. This is not a mandatory element. In an ARM template, variables are predominantly inside expressions. Between parameters and variables, you need to always a strike balance (free-form vs known configuration) to create templates are easy to deploy.&lt;/p&gt;
&lt;h3 id=&#34;resources&#34;&gt;Resources&lt;/h3&gt;
&lt;p&gt;This element is where you define what Azure resource you need to deploy or update. An ARM template must have at least one resource. The type of valid resources supported in a template depends on the value of &lt;code&gt;$schema&lt;/code&gt; element. In the next section, you will see how to author your first ARM template and you will see more about resource specification in an ARM template.&lt;/p&gt;
&lt;h3 id=&#34;outputs&#34;&gt;Outputs&lt;/h3&gt;
&lt;p&gt;Using this element, you can specify the values returned by the template after the deployment is complete. This element is not mandatory. This can be very useful when using nested templates and you will learn more about it soon in this series.&lt;/p&gt;
&lt;h2 id=&#34;first-arm-template&#34;&gt;First ARM template&lt;/h2&gt;
&lt;p&gt;Alright! After that quick overview of the template elements, this section will get you started with your first ARM template. For this purpose, you will perform a subscription scoped deployment to provision a new resource group. Within VS Code, if you want a quick snippet that supports subscription level deployments, you can type &lt;code&gt;arm!s&lt;/code&gt; and press enter. You can now add the following snippet under the resource element.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/rchaganti/d7e35878c6687da07ae5fa5dfb7d54c2.js?file=resourceGroup.res&#34;&gt;&lt;/script&gt;

&lt;p&gt;A typical resource specification will be very similar to what is shown above. The following table provides an overview of the resource group object properties that you can use in a template.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Property Name&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;th&gt;Is Mandatory?&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;type&lt;/td&gt;
&lt;td&gt;This property identifies the type of a resource that you want to provision. For a resource group, this will be &lt;code&gt;Microsoft.Resources/resourceGroups&lt;/code&gt;.&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;name&lt;/td&gt;
&lt;td&gt;Using this property, you can specify a name for the resource being provisioned.&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;apiVersion&lt;/td&gt;
&lt;td&gt;This property identifies the API version to be used for provisioning the resource. For a resource group resource, this, at present, should be &lt;code&gt;2020-06-01&lt;/code&gt;.&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;location&lt;/td&gt;
&lt;td&gt;This property specifies where there resource should be created. Some resources may not be supported in all regions or enabled in your subscription.&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;properties&lt;/td&gt;
&lt;td&gt;Specifies additional properties needed for the resource provisioning.&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;tags&lt;/td&gt;
&lt;td&gt;Specifies a list of tags (key-value pairs) associated with the resource.&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;For now, you don&amp;rsquo;t have to worry about the parameters, variables, functions, and outputs in the template. You can simply leave them blank. With the addition of resource group snippet, here is how your first template should look like.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/rchaganti/d7e35878c6687da07ae5fa5dfb7d54c2.js?file=resourceGroup.azrm.json&#34;&gt;&lt;/script&gt;

&lt;p&gt;This is ready for deployment. If you want to use Azure portal for template deployments, the subscription level deployment, at present, is available only in the preview portal. The below deploy to Azure button will take you directly to the preview portal.&lt;/p&gt;

    &lt;a href=&#34;https://preview.portal.azure.com/#create/Microsoft.Template/uri/https%3a%2f%2fgist.githubusercontent.com%2frchaganti%2fd7e35878c6687da07ae5fa5dfb7d54c2%2fraw%2fresourceGroup.azrm.json&#34; target=&#34;_blank&#34;&gt;
        &lt;img src=&#34;https://raw.githubusercontent.com/Azure/azure-quickstart-templates/master/1-CONTRIBUTION-GUIDE/images/deploytoazure.svg?sanitize=true&#34; alt=&#34;&#34;&gt;
    &lt;/a&gt;
    &lt;br /&gt;

&lt;p&gt;If you want to perform this deployment using Azure CLI, you can use the below command to perform this subscription level deployment to create the resource group.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If you have not already done so, you must first authenticate using &lt;code&gt;az login&lt;/code&gt; command.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/rchaganti/d7e35878c6687da07ae5fa5dfb7d54c2.js?file=resourceGroupDeploy.azcli&#34;&gt;&lt;/script&gt;

&lt;p&gt;In the above command, do not confuse the &lt;code&gt;--name&lt;/code&gt; and &lt;code&gt;--location&lt;/code&gt; parameters to what you have in the ARM template. These two parameters indicate the name of the deployment and location where the deployment meta data should be stored. The &lt;code&gt;sub&lt;/code&gt; subcommand within az deployment indicates that you are doing a subscription level deployment.&lt;/p&gt;
&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;
&lt;p&gt;In this part of the article, you looked at basics of ARM template syntax, understood different elements in the template and their purpose, saw a quick overview of scoped deployments, and finally performed a subscription level deployment to create a resource group in your subscription and used Azure CLI for this purpose. In this next part of this series, you will learn how to create reusable ARM templates by adding parameters.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Azure Resource Manager - Tools for ARM template design, authoring, and deployment</title>
      <link>https://ravichaganti.com/blog/azure-resource-manager-tools-for-arm-template-design-authoring-and-deployment/</link>
      <pubDate>Fri, 17 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ravichaganti.com/blog/azure-resource-manager-tools-for-arm-template-design-authoring-and-deployment/</guid>
      <description>&lt;p&gt;The first part of this series of articles on Azure Resource Manager (ARM) provided a quick overview of ARM. You looked a quick introduction to ARM templates as well and looked at an overview of different template deployment methods. In this part of the series, we will look at different methods to author ARM templates and an in-depth look at preferred deployment methods. You can choose any of the methods mentioned here but this series of articles will use one preferred method each for authoring and deploying templates. You will read more about those methods and the reasons behind that choice as well.&lt;/p&gt;
&lt;h2 id=&#34;authoring-tools&#34;&gt;Authoring Tools&lt;/h2&gt;
&lt;p&gt;ARM templates, as mentioned in the last part, are JSON documents. These files can be authored in notepad as well but there are better ways to deal with this task. You will learn about three different methods that I have used and my observations and preferences around these methods. Let us start with the template editor that Azure Portal offers.&lt;/p&gt;
&lt;h3 id=&#34;template-editor-in-azure-portal&#34;&gt;Template Editor in Azure Portal&lt;/h3&gt;
&lt;p&gt;The web-based template editor in the Azure portal is one way but I see it as a better way to edit existing templates than writing one from scratch. You can import a quick start template and use that as a starting point for building your own template.&lt;/p&gt;

    &lt;figure &gt;
        
            &lt;img src=&#34;https://ravichaganti.com/images/armin30/d2-templateeditor-qs.png&#34; width=&#34;860&#34; /&gt;
        
        
    &lt;/figure&gt;
    
&lt;p&gt;Once you click on &lt;em&gt;Quickstart template&lt;/em&gt; [1], you will be shown a list of templates available from the &lt;a href=&#34;https://github.com/Azure/azure-quickstart-templates&#34;&gt;GitHub repository&lt;/a&gt;. The selected template then gets loaded into the editor for further updates or deployment. I selected the &lt;a href=&#34;https://github.com/Azure/azure-quickstart-templates/tree/master/101-vm-simple-windows&#34;&gt;101-vm-simple-windows template&lt;/a&gt; from the list.&lt;/p&gt;

    &lt;figure &gt;
        
            &lt;img src=&#34;https://ravichaganti.com/images/armin30/d2-templateeditor-ar.png&#34; width=&#34;860&#34; /&gt;
        
        
    &lt;/figure&gt;
    
&lt;p&gt;At this point, you can click on &lt;em&gt;Add resource&lt;/em&gt; [2] to add another resource to this template. This will bring up a limited set of additional resources you can add to the loaded template. You may select a Windows Virtual Machine.&lt;/p&gt;

    &lt;figure &gt;
        
            &lt;img src=&#34;https://ravichaganti.com/images/armin30/d2-templateeditor-arwvm.png&#34; width=&#34;860&#34; /&gt;
        
        
    &lt;/figure&gt;
    
&lt;p&gt;This brings up a few input parameters needed for the new VM instance. Once you enter these values and click OK, the template in the editor window gets updated to add the new VM resource instance. You can review the updated template and click on Save to move ahead to deploy this template.&lt;/p&gt;

    &lt;figure &gt;
        
            &lt;img src=&#34;https://ravichaganti.com/images/armin30/d2-templateeditor-deploy.png&#34; width=&#34;860&#34; /&gt;
        
        
    &lt;/figure&gt;
    
&lt;p&gt;At this point, you will presented with a list of input parameters needed for this template deployment. You can enter these values and click &lt;em&gt;Purchase&lt;/em&gt; to start the template validation and deploy it if there are no validation errors. However, it is not always this straightforward. I ended up updating a few language expressions to make this working. If you have tried this option, you will know that the editing experience is limited. It supports adding only a few types of additional resources to the template. And, of course, this isn&amp;rsquo;t a great way to edit or build anything other than a simple template. You need a better way than this web-based editor.&lt;/p&gt;
&lt;h3 id=&#34;visual-studio&#34;&gt;Visual Studio&lt;/h3&gt;
&lt;p&gt;Visual Studio provides a rich integrated development environment (IDE) for developing various types of applications. You can use some of the starter templates packaged along with Visual Studio and build upon those existing templates to add your own resources or start from a blank template and build everything from scratch. For this quick overview of using Visual Studio for template authoring and deployment, I will use Visual Studio 2019 Community Edition.&lt;/p&gt;

    &lt;figure &gt;
        
            &lt;img src=&#34;https://ravichaganti.com/images/armin30/d2-visualstudiostart.png&#34; width=&#34;860&#34; /&gt;
        
        
    &lt;/figure&gt;
    
&lt;p&gt;When you install and open Visual Studio, you will see different options to get started. Select &lt;em&gt;Create a new project&lt;/em&gt;.&lt;/p&gt;

    &lt;figure &gt;
        
            &lt;img src=&#34;https://ravichaganti.com/images/armin30/d2-visualstudio.png&#34; width=&#34;860&#34; /&gt;
        
        
    &lt;/figure&gt;
    
&lt;p&gt;In the next window, filter down the options [1] to Azure and Cloud. In the filtered project templates, select &lt;em&gt;Azure Resource Group&lt;/em&gt; [2] and click &lt;em&gt;Next&lt;/em&gt;.&lt;/p&gt;

    &lt;figure &gt;
        
            &lt;img src=&#34;https://ravichaganti.com/images/armin30/d2-visualstudioconfigure.png&#34; width=&#34;560&#34; /&gt;
        
        
    &lt;/figure&gt;
    
&lt;p&gt;Enter the relevant input for creating a Visual Studio project and click Create.&lt;/p&gt;

    &lt;figure &gt;
        
            &lt;img src=&#34;https://ravichaganti.com/images/armin30/d2-visualstudiotemplate.png&#34; width=&#34;560&#34; /&gt;
        
        
    &lt;/figure&gt;
    
&lt;p&gt;As you see in the above screenshot, you can select one of the canned starter templates or start with a blank template. Since we have learned the basics of template authoring yet, scroll down in the template list and select &lt;em&gt;Windows Virtual Machine&lt;/em&gt; and click OK. This creates the Visual Studio solution.&lt;/p&gt;

    &lt;figure &gt;
        
            &lt;img src=&#34;https://ravichaganti.com/images/armin30/d2-visualstudiosolution.png&#34; width=&#34;860&#34; /&gt;
        
        
    &lt;/figure&gt;
    
&lt;p&gt;Once the solution gets created, click on WindowsVirtualMachine.json [1] in the Solution Explorer pane. This opens the ARM template. On the left-hand side, you can see the JSON Outline [2] pane which shows parameters, variables, and resources defined in the template.&lt;/p&gt;

    &lt;figure &gt;
        
            &lt;img src=&#34;https://ravichaganti.com/images/armin30/d2-visualstudioresource.png&#34; width=&#34;860&#34; /&gt;
        
        
    &lt;/figure&gt;
    
&lt;p&gt;Similar to the Azure Portal template editing experience, you can add resources to this existing template by right-clicking on resources node in the JSON outline and selecting &lt;em&gt;Add New Resource&lt;/em&gt;.&lt;/p&gt;

    &lt;figure &gt;
        
            &lt;img src=&#34;https://ravichaganti.com/images/armin30/d2-visualstudioaddresource.png&#34; width=&#34;560&#34; /&gt;
        
        
    &lt;/figure&gt;
    
&lt;p&gt;From a set of limited resource types, you can select the resource type you want to add, provide the necessary input parameter values and click Add. The selected resource gets added to the template. You can now customize the template and start a deployment. Before you can deploy the template, you will have to provide the values for the template parameters. This can be done by opening the WindowsVirtualMachine.parameters.json file and enter the relevant values.&lt;/p&gt;

    &lt;figure &gt;
        
            &lt;img src=&#34;https://ravichaganti.com/images/armin30/d2-visualstudioeditparams.png&#34; width=&#34;860&#34; /&gt;
        
        
    &lt;/figure&gt;
    
&lt;p&gt;Before starting a deployment of this template, you can validate the template. For that, right click on the solution name in the Solution Explorer and select &lt;em&gt;Validate&lt;/em&gt;.&lt;/p&gt;

    &lt;figure &gt;
        
            &lt;img src=&#34;https://ravichaganti.com/images/armin30/d2-visualstudiovalidate.png&#34; width=&#34;560&#34; /&gt;
        
        
    &lt;/figure&gt;
    
&lt;p&gt;You will be prompted to enter the password for the admin user to continue validation. If the validation completes with no errors, you can again right-click on the solution name in the Solution Explorer and click Deploy to provision the ARM resources defined in the template.&lt;/p&gt;
&lt;p&gt;Overall experience with authoring templates in Visual Studio is good. This method provides intellisense for different resource properties based on the template schema version.&lt;/p&gt;

    &lt;figure &gt;
        
            &lt;img src=&#34;https://ravichaganti.com/images/armin30/d2-visualstudiointelli.png&#34; width=&#34;560&#34; /&gt;
        
        
    &lt;/figure&gt;
    
&lt;p&gt;The editor experience in Visual Studio also provides insights into what might be wrong with certain resource property values and / or what might be missing therefore providing better editing experience.&lt;/p&gt;

    &lt;figure &gt;
        
            &lt;img src=&#34;https://ravichaganti.com/images/armin30/d2-visualstudioeditorexp.png&#34; width=&#34;560&#34; /&gt;
        
        
    &lt;/figure&gt;
    
&lt;p&gt;Overall, compared to the web editor in Azure portal, authoring experience in Visual Studio is way better. However, this is a heavy solution. On a decently configured system, it takes close to a minute to just open Visual Studio. Also, as you may have already seen, the starter templates do not support selecting the Azure quickstart templates from the GitHub repository. Within the template editor, you can auto-complete the resource property names once the resource type property is populated. However, there are no quick snippets that you can use directly. This, for me, kills productivity. There may be a few external marketplace extensions but there is no built-in support.&lt;/p&gt;
&lt;h3 id=&#34;visual-studio--code&#34;&gt;Visual Studio  Code&lt;/h3&gt;
&lt;p&gt;This is my favorite tool. No doubt. There are several reasons as you will read in this section. This tweet poll just endorses my choice.&lt;/p&gt;
&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;What is your favorite editor for authoring &lt;a href=&#34;https://twitter.com/Azure?ref_src=twsrc%5Etfw&#34;&gt;@Azure&lt;/a&gt; Resource Manager templates?&lt;/p&gt;&amp;mdash; Ravikanth Chaganti (@ravikanth) &lt;a href=&#34;https://twitter.com/ravikanth/status/1280058881322872833?ref_src=twsrc%5Etfw&#34;&gt;July 6, 2020&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;

&lt;p&gt;Throughout this series, you will see using VS Code only for authoring ARM templates. Therefore, I will skip any details similar to Visual Studio based template authoring experience you just read earlier. Now, moving on to why I like VS Code for ARM template authoring, first of all, VS Code is an open source, lightweight, and faster alternative to Visual Studio. The extension support within VS Code is unmatchable. With the official Azure extensions and a bunch of other community extensions, you can be super productive when working with the complex ARM template files. Before you get started with authoring an ARM template in VS Code, you must first install the right set of extensions that will help you in the authoring process. The following list is the minimum you will need to follow the articles in this series. Alternatively, you can install the &lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=ms-vscode.vscode-node-azure-pack&#34;&gt;Azure Tools extension pack&lt;/a&gt; that will install following three plus a bunch of other extensions that you may never need.&lt;/p&gt;
&lt;h4 id=&#34;azure-account&#34;&gt;Azure Account&lt;/h4&gt;
&lt;p&gt;The &lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=ms-vscode.azure-account&#34;&gt;Azure account&lt;/a&gt; VS Code extension allows you to sign into Azure and access your Azure subscriptions. This is necessary for other Azure extensions to function. Once you install this extension, you get a set of commands to sign in, sign out, select subscriptions, create Azure accounts, and open Azure Cloud Shell within VS Code.&lt;/p&gt;
&lt;h4 id=&#34;azure-resource-manager-arm-tools&#34;&gt;Azure Resource Manager (ARM) Tools&lt;/h4&gt;
&lt;p&gt;The &lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=msazurermtools.azurerm-vscode-tools&#34;&gt;ARM Tools extension&lt;/a&gt; is a must if you want to be productive authoring ARM templates in VS Code. This extension provides the full ARM template language support and provides a bunch of snippets to speed up the authoring process. You will see and use this extension a lot in the next parts of this article series and therefore I will not spend any more time on this here.&lt;/p&gt;
&lt;h4 id=&#34;azure-policy&#34;&gt;Azure Policy&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=AzurePolicy.azurepolicyextension&#34;&gt;Azure Policy&lt;/a&gt; extension can be used for authoring and managing policy definitions and assignments. This is in preview like a few other VS Code extensions. This is a good one to install as well as you follow this series of articles on Azure Resource Manager and want to try out Azure Policy related examples.&lt;/p&gt;
&lt;h4 id=&#34;azure-cli-tools&#34;&gt;Azure CLI Tools&lt;/h4&gt;
&lt;p&gt;Finally, the &lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=ms-vscode.azurecli&#34;&gt;Azure CLI Tools&lt;/a&gt; extension is what will help you when you author Azure CLI scripts to perform template deployments. This is an optional one if all you need is really the ability to run Azure CLI commands to validate and deploy templates within the VS Code terminal.&lt;/p&gt;
&lt;h2 id=&#34;deployment-tools&#34;&gt;Deployment Tools&lt;/h2&gt;
&lt;p&gt;There are many ways to deploy ARM templates. This includes using Azure portal, Azure CLI, Azure PowerShell cmdlets, ARM REST API, and Python or Go SDK.&lt;/p&gt;
&lt;h3 id=&#34;azure-portal&#34;&gt;Azure Portal&lt;/h3&gt;
&lt;p&gt;Azure Portal allows you to author templates in an online editor or upload templates for deployments or deploy from a collection of quick start templates. We looked at the an example of this in the previous section already. Using the template editor in the Azure portal, you can author and deploy or you can simply upload a template for deployment. Many places online (including the Azure Quickstart template repository), you see a &lt;a href=&#34;https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/deploy-to-azure-button&#34;&gt;Deploy to Azure&lt;/a&gt; button that directly takes to you the custom deployment page. You can use this method to deploy a template stored in an online public repository to perform resource group level deployments. Here is how it appears in a webpage.&lt;/p&gt;

    &lt;a href=&#34;https://portal.azure.com/#create/Microsoft.Template/uri/https%3a%2f%2fportal.azure.com%2f%23create%2fMicrosoft.Template%2furi%2fhttps%253A%252F%252Fraw.githubusercontent.com%252FAzure%252Fazure-quickstart-templates%252Fmaster%252F101-storage-account-create%252Fazuredeploy.json&#34; target=&#34;_blank&#34;&gt;
        &lt;img src=&#34;https://raw.githubusercontent.com/Azure/azure-quickstart-templates/master/1-CONTRIBUTION-GUIDE/images/deploytoazure.svg?sanitize=true&#34; alt=&#34;&#34;&gt;
    &lt;/a&gt;
    &lt;br /&gt;

&lt;p&gt;Clicking on the above button brings up the custom deployment blade asking for the input parameters needed for the template deployment.&lt;/p&gt;
&lt;h3 id=&#34;azure-cli&#34;&gt;Azure CLI&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.microsoft.com/en-us/cli/azure/?view=azure-cli-latest&#34;&gt;Azure CLI&lt;/a&gt; offers a method to deploy ARM templates as well. You can use the &lt;code&gt;az deployment&lt;/code&gt; command to perform template deployment.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/rchaganti/d7e35878c6687da07ae5fa5dfb7d54c2.js?file=deploytemplate.azcli&#34;&gt;&lt;/script&gt;

&lt;p&gt;With the &lt;code&gt;az deployment&lt;/code&gt; command, we can either use an online template file or local file.&lt;/p&gt;
&lt;h3 id=&#34;azure-powershell&#34;&gt;Azure PowerShell&lt;/h3&gt;
&lt;p&gt;Similar to Azure CLI, you can use &lt;a href=&#34;https://docs.microsoft.com/en-us/powershell/azure&#34;&gt;Azure PowerShell module&lt;/a&gt; as well to deploy ARM templates.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/rchaganti/d7e35878c6687da07ae5fa5dfb7d54c2.js?file=deploytemplate.ps1&#34;&gt;&lt;/script&gt;

&lt;p&gt;If you do not want to install any of these tools (Az CLI and Az PowerShell module) on your local system, you can always use Azure Cloud Shell within VS Code or launch Cloud Shell in the browser to start using any of these tools. Within this series of articles, you will occasionally see a button like the one displayed below. You can click on it to open &lt;a href=&#34;https://docs.microsoft.com/en-us/azure/cloud-shell/embed-cloud-shell&#34;&gt;Azure Cloud Shell&lt;/a&gt; and start performing command execution.&lt;/p&gt;

    &lt;a href=&#34;https://shell.azure.com/&#34; target=&#34;_blank&#34;&gt;
        &lt;img src=&#34;https://shell.azure.com/images/launchcloudshell.png&#34; alt=&#34;&#34;&gt;
    &lt;/a&gt;
    &lt;br /&gt;

&lt;h3 id=&#34;arm-rest-api&#34;&gt;ARM REST API&lt;/h3&gt;
&lt;p&gt;ARM REST API is another way to do template deployment but I consider this a bit low-level and requires good amount of scripting / programming experience.&lt;/p&gt;
&lt;p&gt;For most part of this series of articles on ARM, you will see Azure CLI examples. You will occasionally see a few Azure PowerShell examples. I will write about other deployment methods such as Terraform and Pulumi in a different series of articles. But, before you go there, it is good to get a good grasp of ARM fundamentals. Next few articles in this series of articles will dive into the ARM template authoring and deployment. For now, let us move on to discuss some features and services that work hand in hand with ARM.&lt;/p&gt;
&lt;h2 id=&#34;template-design-and-visualization-tools&#34;&gt;Template Design and visualization Tools&lt;/h2&gt;
&lt;p&gt;As a cloud consultant or architect, you have to create the cloud architecture proposals before you go into the implementation phase. There are a bunch of tools &amp;ndash; online and offline &amp;ndash; that can help you create the architecture diagrams for your cloud infrastructure proposals. In this final section of this post, you will get to know about a few tools that I have used or using to create these architecture diagrams.&lt;/p&gt;
&lt;p&gt;You can always use good old friend Microsoft Visio if you have a license for the product and I trust this a lot and use it. However, I will introduce other tools that you may find useful.&lt;/p&gt;
&lt;h3 id=&#34;arm-template-visualizer&#34;&gt;ARM template visualizer&lt;/h3&gt;
&lt;p&gt;The ARM template visualizer is not really a designer like Visio or any other tool you may see in this section but a good way to visualize an ARM template on a canvas. If you navigate to the ARM quickstart template GitHub repository, you will see a button like what is shown below.&lt;/p&gt;

    &lt;a href=&#34;http://armviz.io/#/?load=https%3a%2f%2fraw.githubusercontent.com%2fAzure%2fazure-quickstart-templates%2fmaster%2f101-1vm-2nics-2subnets-1vnet%2fazuredeploy.json&#34; target=&#34;_blank&#34;&gt;
        &lt;img src=&#34;https://raw.githubusercontent.com/Azure/azure-quickstart-templates/master/1-CONTRIBUTION-GUIDE/images/visualizebutton.svg?sanitize=true&#34; alt=&#34;&#34;&gt;
    &lt;/a&gt;
    &lt;br /&gt;

&lt;p&gt;And, when you on click on this button, it takes you to an ARM template visualizer where you can see the template in a visual form.&lt;/p&gt;

    &lt;figure &gt;
        
            &lt;img src=&#34;https://ravichaganti.com/images/armin30/d2-armviz.png&#34; width=&#34;860&#34; /&gt;
        
        
    &lt;/figure&gt;
    
&lt;p&gt;By default, the template visualization [1] opens up and you can click on &lt;em&gt;&amp;lt;/&amp;gt;&lt;/em&gt; [2] to see the ARM template JSON. You can edit the contents of the template and return back to the canvas to see the updated visualization. Going to the File menu, you can open a local template or download the template that is visualized.&lt;/p&gt;
&lt;h3 id=&#34;drawio&#34;&gt;Draw.io&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://draw.io&#34;&gt;Draw.io&lt;/a&gt; is a web-based tool that can help you design and save Azure architecture diagrams. There is a &lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=hediet.vscode-drawio&#34;&gt;VS Code extension&lt;/a&gt; as well for this and you can now create the diagrams right within VS Code.&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&#34;https://ravichaganti.com/images/armin30/d2-drawio.png&#34; width=&#34;860&#34;/&gt; 
&lt;/figure&gt;

&lt;h3 id=&#34;cloudskew&#34;&gt;Cloudskew&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cloudskew.com/&#34;&gt;Cloudskew&lt;/a&gt; is another web-based tool that provides a very nice canvas to create cloud architecture diagrams. This is also a free tool that offers several built-in cloud icon support.&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&#34;https://ravichaganti.com/images/armin30/d2-cloudskew.png&#34; width=&#34;860&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;There may be many other tools for ARM template design and visualization that I may not have tried yet. But, like I mentioned earlier, my trusted source is still good old Visio and I continue to use it.&lt;/p&gt;
&lt;p&gt;So far in this article, we looked at different authoring tools, deployment methods, and finally a few options to design and visualize these ARM templates. This should get you equipped with the right tools to get started with template authoring. In the next part of this series, we will look at the basics of template authoring. Stay tuned.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Azure Resource Manager - Introduction</title>
      <link>https://ravichaganti.com/blog/azure-resource-manager-introduction/</link>
      <pubDate>Thu, 16 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ravichaganti.com/blog/azure-resource-manager-introduction/</guid>
      <description>&lt;p&gt;A while ago, I had written a &lt;a href=&#34;https://ravichaganti.com/series/arm-templates/&#34;&gt;series of articles&lt;/a&gt; introducing and diving deep into authoring Azure Resource Manager (ARM) templates. A few things have changed in authoring ARM templates and new features got added in the recent past. I thought it is probably a better time to revisit and do it all over again. At the same time, I thought why just limit to just authoring ARM templates. Over the years, I made notes around ARM and learned quite a bit. Starting today, I will share those notes with you here.&lt;/p&gt;
&lt;p&gt;In this new and improved series, I will start from the very basics and build upon that in each article. The goal is to ensure I create a set of articles that can be referenced in a zero to hero approach to understand ARM and authoring ARM templates. So, without further ado, let us get started and let us start with the very basics.&lt;/p&gt;
&lt;h2 id=&#34;what-is-azure-resource-manager-arm&#34;&gt;What is Azure Resource Manager (ARM)?&lt;/h2&gt;
&lt;p&gt;Microsoft Azure, during the early days, had a management layer called Azure Service Manager (ASM) that was responsible for deploying and managing services. These services that you deployed using ASM were all independent entities without any grouping whatsoever. There was no way to define the dependencies either. So, if you were to implement a three-tier application as a set of cloud services, each service in the three-tier application had to be deployed individually and managed individually. When you have to delete this application, you had to do it by deleting each service individually. The same applies to updates as well. Monitoring and billing was a nightmare. This approach was not scalable. So, during &lt;a href=&#34;https://channel9.msdn.com/Events/Build/2014/2-607&#34;&gt;Build 2014&lt;/a&gt;, Microsoft announced a new deployment and management service called Azure Resource Manager (ARM).&lt;/p&gt;
&lt;p&gt;Here is a super simplified view of the ARM that provides an overview of the constructs.&lt;/p&gt;

    &lt;figure &gt;
        
            &lt;img src=&#34;https://ravichaganti.com/images/armin30/d1-armarch.png&#34; width=&#34;350&#34; /&gt;
        
        
    &lt;/figure&gt;
    
&lt;p&gt;With ARM, all your &lt;em&gt;&lt;strong&gt;resources&lt;/strong&gt;&lt;/em&gt; having a common life cycle (create/update/delete) can now be grouped together under a &lt;em&gt;&lt;strong&gt;resource group&lt;/strong&gt;&lt;/em&gt; and their life cycle management can be done together. A resource group becomes the unit of management. Each resource in Azure is supplied by a service known as a &lt;em&gt;&lt;strong&gt;resource provider&lt;/strong&gt;&lt;/em&gt;. The resources in Azure can be deployed in many ways but the focus of this series will be around the declarative &lt;em&gt;&lt;strong&gt;deployment templates&lt;/strong&gt;&lt;/em&gt; through which you can provision the resources in a consistent and idempotent manner.&lt;/p&gt;
&lt;p&gt;Let us dig a bit into the terminology you read in the above paragraph.&lt;/p&gt;
&lt;h2 id=&#34;azure-resources&#34;&gt;Azure Resources&lt;/h2&gt;
&lt;p&gt;Resources are what you provision in Azure cloud. For example, as shown in the above image, web apps, virtual machines, databases, and so on. Each resource will have certain properties that you can configure. What resources you can provision depends on what is allowed and / or enabled in your subscription. We will look at this in a later article.&lt;/p&gt;
&lt;h2 id=&#34;azure-resource-groups&#34;&gt;Azure Resource Groups&lt;/h2&gt;
&lt;p&gt;Resource group is a container for all resources that share a common life cycle. A resource should always exist in a resource group and can exist only in one group. It is not necessary that resources that have inter-dependencies are provisioned in the same resource group. These resources within a resource group can exist in different regions too. Instead, the life cycle of the resources is used as a way to group the resources together.&lt;/p&gt;
&lt;h2 id=&#34;azure-resource-providers&#34;&gt;Azure Resource Providers&lt;/h2&gt;
&lt;p&gt;The resource providers enable the resource and implement the management of the resources. Each resource that you can provision in Azure will have an associated resource provider. ARM binds all this together to provide a single management pane irrespective of what type of resource you are provisioning.&lt;/p&gt;
&lt;p&gt;There are several methods to interact with ARM for all your resource creation and management needs. These methods include Azure PowerShell module, Azure CLI, Azure SDKs for Golang, Python, and other languages. You can, of course, use the REST API directly to provision and manage resources. Through all these methods, you basically use individual commands or write scripts or you own applications to provision and manage resources. This approach is more imperative in nature. You write a script to implement what you need and at the same time you define how that needs to be done. In an imperative method, you perform checks to see if the resource that you are trying to provision already exists or not and provision only if it does not exist. You perform all error handling yourself in the imperative approach. And, if you were to create a lot of resources that do not necessarily depend on each other, you can write some parallel jobs to perform simultaneous execution of resource creation. But, the onus is on you to write this code and make sure it works.&lt;/p&gt;
&lt;h2 id=&#34;azure-resource-manager-templates&#34;&gt;Azure Resource Manager Templates&lt;/h2&gt;
&lt;p&gt;ARM templates help eliminate the need for the tedious and error-prone development of automation scripts using any of the methods you read about earlier. These templates are JSON files that provide a declarative syntax to provision Azure resources. Using the &lt;strong&gt;declarative&lt;/strong&gt; syntax of ARM templates, you define what infrastructure you need to provision and not how. With the increasing focus on Agile infrastructure practices and DevOps, this declarative template becomes a part of your application code and lives in the same source control repositories as your application. Any changes to the infrastructure configuration go through the same source control and application development procedures such as automation validations, continuous integration and delivery / deployment. This is what we describe as Infrastructure as Code (IaC).&lt;/p&gt;
&lt;p&gt;The ARM templates also offer a way to repeatedly deploy your infrastructure in Azure cloud. This is done in an &lt;strong&gt;idempotent&lt;/strong&gt; way. Idempotency means that the result of a provisioning task (state of the resources defined in the template) would be same irrespective of how many times you run the task.&lt;/p&gt;
&lt;p&gt;With ARM templates, unlike imperative scripting, you don&amp;rsquo;t have to worry about simultaneous resource creation or resource provisioning dependencies or error handling. ARM can infer these dependencies from what is defined in the template and also perform parallel execution when possible. This ensures &lt;strong&gt;reliable&lt;/strong&gt; deployment of resources defined in the template.&lt;/p&gt;
&lt;p&gt;In summary, &lt;em&gt;&lt;strong&gt;ARM templates offer a declarative method to provision your infrastructure resources in a reliable and idempotent manner&lt;/strong&gt;&lt;/em&gt;. There are several other aspects of ARM templates such as validation, extensions, and modularity / composability. You will read more about these characteristics in the upcoming parts of this series with relevant examples.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Apart from ARM templates, there are 3rd party providers such as &lt;a href=&#34;https://docs.microsoft.com/en-us/azure/developer/terraform/overview#:~:text=%20Terraform%20with%20Azure%20%201%20Automate%20infrastructure,configuring%20it%20to%20use%20Azure.%20%20More%20&#34;&gt;Terraform&lt;/a&gt; and &lt;a href=&#34;https://www.pulumi.com/azure/&#34;&gt;Pulumi&lt;/a&gt; for provisioning Azure infrastructure. These methods provide the same characteristics as ARM templates. Each of these methods have their pros and cons. This series of articles will only use ARM templates as a way to provision infrastructure.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;If you are interested in exploring what ARM templates look like or looking for a quick start for a specific resource type or scenario, you may look up &lt;a href=&#34;https://github.com/Azure/azure-quickstart-templates&#34;&gt;Azure Quickstart templates GitHub repository&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Writing and reading ARM templates can be very complex and may get boring as well! At Build 2020, Microsoft announced &lt;a href=&#34;https://youtu.be/UaVCNpD3pvg?t=986&#34;&gt;language revision&lt;/a&gt; that intends to provide a Domain Specific Language (DSL) abstraction that complies to a JSON template underneath and makes it easy for you to author complex ARM templates.&lt;/p&gt;

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/UaVCNpD3pvg?t=986&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;As this preview becomes available, I will write more about this new method here.&lt;/p&gt;
&lt;p&gt;After you author the ARM templates, you can deploy these templates using a variety of methods. You will read more about these methods in the next part of this series.&lt;/p&gt;
&lt;h2 id=&#34;azure-deployment-manager&#34;&gt;Azure Deployment Manager&lt;/h2&gt;
&lt;p&gt;As your organization grows and you start using Azure with multiple subscriptions and may be in multiple regions too, it becomes complex to perform an ordered and monitored rollout of Azure deployments. This is where &lt;a href=&#34;https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/deployment-manager-overview&#34;&gt;Azure Deployment Manager&lt;/a&gt; (ADM) comes into play. ADM extends ARM by enabling new features called &lt;em&gt;Service Topologies&lt;/em&gt; and &lt;em&gt;Rollouts&lt;/em&gt;.  ADM makes it easy to define complex deployments that span multiple regions and subscriptions and allows repeated deployments of these topologies using &lt;a href=&#34;https://docs.microsoft.com/en-us/rest/api/deploymentmanager/rollouts&#34;&gt;Rollouts&lt;/a&gt;. You will learn about this in-depth in later parts of this series.&lt;/p&gt;
&lt;h2 id=&#34;azure-governance&#34;&gt;Azure Governance&lt;/h2&gt;
&lt;p&gt;While knowing how to author and deploy ARM templates is an important part of working with Azure, it is equally important to know how to govern those resources and services deployed in Azure. As cloud architect, you would want control over who can create what type resources, where can they create those resources and how many. You would also want to standardize on the deployments so that the configuration of resources is in compliance with your organization standards. Among many other aspects like this you would want the ability to track your cloud cost more granularly for every service deployed in the cloud and for every business unit or group within your organization. To address this and to implement efficient governance Azure offers features and services such as &lt;a href=&#34;https://docs.microsoft.com/en-us/azure/governance/policy/overview&#34;&gt;Policies&lt;/a&gt;, &lt;a href=&#34;https://docs.microsoft.com/en-us/azure/governance/management-groups/&#34;&gt;Management Groups&lt;/a&gt;, &lt;a href=&#34;https://azure.microsoft.com/en-us/features/resource-graph/&#34;&gt;Resource Graph&lt;/a&gt;, and &lt;a href=&#34;https://docs.microsoft.com/en-us/azure/governance/blueprints/overview&#34;&gt;Blueprints&lt;/a&gt;. Here is an excellent depiction of Azure governance architecture from the &lt;a href=&#34;https://www.microsoft.com/en-us/us-partner-blog/2019/07/24/azure-governance/&#34;&gt;partner blog&lt;/a&gt;.&lt;/p&gt;

    &lt;figure &gt;
        
            &lt;img src=&#34;https://ravichaganti.com/images/armin30/d1-azuregovernance.png&#34; width=&#34;800&#34; /&gt;
        
        
    &lt;/figure&gt;
    
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Azure Policy&lt;/strong&gt;&lt;/em&gt; helps enforce your organizational IT and business standards for resource consistency, compliance to regulatory requirements, management, security, and cost. Azure offers a set of built-in policy definitions that are readily available for some of the common use cases in your Azure environment. You can, of course, create your own custom policy definitions as well.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Azure Management Groups&lt;/strong&gt;&lt;/em&gt; allow organizing subscriptions into containers called management groups and then perform governance on these management groups. The subscriptions under the management groups inherit the governance conditions (policies) applied at the management group level.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Azure Resource Graph&lt;/strong&gt;&lt;/em&gt; offers an efficient and performant way to query resources across multiple environments and subscriptions. This service can be used to extend management of Azure resources by enabling the ability to query resources with complex filtering, grouping, and sorting by resource properties. To use Azure Graph, you need to understand the Kusto Query Language (&lt;a href=&#34;https://docs.microsoft.com/en-us/azure/governance/resource-graph/concepts/query-language&#34;&gt;KQL&lt;/a&gt;). In this series of articles, you will see a basic overview of KQL and using Azure CLI to query the Resource Graph.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Azure Blueprints&lt;/strong&gt;&lt;/em&gt; enable streamlining of resource deployments by packaging ARM templates, policies, and role assignments. Blueprints are a declarative way to orchestrate these templates and other related artifacts. Blueprints enable efficient tracking and auditing of deployments. The knowledge you gain around ARM templates can be directly used with Azure Blueprints.&lt;/p&gt;
&lt;p&gt;With this quick overview of Azure governance features and service, you have an understanding of Azure Resource Manager and services that complement ARM. This brings us to the end of today&amp;rsquo;s article. The next few parts of this series will focus on authoring ARM templates. As described earlier, the ARM templates are JSON files and can be authored in notepad as well. But, there are some very good authoring tools and we will take a look at that in the next part of this series. Stay tuned!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Slides: Global Azure Bootcamp - Azure CLI 2.0</title>
      <link>https://ravichaganti.com/blog/slides-and-demo-scripts-from-azure-cli-2-0-tips-and-tricks-session-at-globalazurebootcamp/</link>
      <pubDate>Mon, 29 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ravichaganti.com/blog/slides-and-demo-scripts-from-azure-cli-2-0-tips-and-tricks-session-at-globalazurebootcamp/</guid>
      <description>&lt;p&gt;I had the opportunity over the weekend to speak at the Global Azure Bootcamp organized by local Microsoft user groups. This event was held at ABB office in Bangalore and I must say that they have done a splendid job. It was a very well organized event. I had only one session and it was about Azure CLI 2.0 Tips and Tricks. I mentioned earlier that I am using CLI mostly these days to work with Azure resources and in this session I shared some tips and tricks around making it easier to work with Azure resource management using Azure CLI 2.0.&lt;/p&gt;

    &lt;iframe
        src=&#34;//www.slideshare.net/slideshow/embed_code/key/exlTOlYe4c0N2o&#34;
        title=&#34;SlideShare Presentation&#34;
        height=&#34;400&#34;
        frameborder=&#34;0&#34;
        marginwidth=&#34;0&#34;
        marginheight=&#34;0&#34;
        scrolling=&#34;no&#34;
        style=&#34;border: 1px solid #CCC; border-width: 1px; margin-bottom: 20px; width: 100%;&#34;
        allowfullscreen=&#34;true&#34;&gt;
    &lt;/iframe&gt;

&lt;p&gt;The demo scripts I used for this session can be downloaded from&lt;br&gt;
&lt;a href=&#34;https://github.com/rchaganti/Presentations/tree/master/GAB2019-BLR&#34;&gt;https://github.com/rchaganti/Presentations/tree/master/GAB2019-BLR&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Slides: Experts Live India – Azure at the command line</title>
      <link>https://ravichaganti.com/blog/session-slides-experts-live-india-azure-at-the-command-line/</link>
      <pubDate>Sun, 20 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ravichaganti.com/blog/session-slides-experts-live-india-azure-at-the-command-line/</guid>
      <description>&lt;p&gt;I had the opportunity to speak at the inaugural edition of Experts Live India 2019 over the weekend. It was a great experience. The organizers did a great job even when there were teething facilities issues that plagued the event right from the start.&lt;/p&gt;
&lt;p&gt;My first session was on Azure at the command line. In this session, I walked through both Az CLI 2.0 and Az PowerShell modules and explained the differences to help the audience choose the right tool for their job. The slides do not contain a huge deal of information as I preferred showing the audience a good demo to understand the differences.&lt;/p&gt;

    &lt;iframe
        src=&#34;//www.slideshare.net/slideshow/embed_code/key/gKG58Jis0XZUzj&#34;
        title=&#34;SlideShare Presentation&#34;
        height=&#34;400&#34;
        frameborder=&#34;0&#34;
        marginwidth=&#34;0&#34;
        marginheight=&#34;0&#34;
        scrolling=&#34;no&#34;
        style=&#34;border: 1px solid #CCC; border-width: 1px; margin-bottom: 20px; width: 100%;&#34;
        allowfullscreen=&#34;true&#34;&gt;
    &lt;/iframe&gt;

&lt;p&gt;The demo scripts are available at &lt;!-- raw HTML omitted --&gt;&lt;a href=&#34;https://github.com/rchaganti/Presentations/tree/master/ExpertsLiveIN2019/AzCommandline&#34;&gt;https://github.com/rchaganti/Presentations/tree/master/ExpertsLiveIN2019/AzCommandline&lt;/a&gt;&lt;!-- raw HTML omitted --&gt;.&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Slides: Azure MVP Bootcamp – Microsoft Azure Cloud and DevOps</title>
      <link>https://ravichaganti.com/blog/slides-from-azure-mvp-bootcamp-microsoft-azure-cloud-and-devops/</link>
      <pubDate>Sat, 12 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ravichaganti.com/blog/slides-from-azure-mvp-bootcamp-microsoft-azure-cloud-and-devops/</guid>
      <description>&lt;p&gt;I had the privilege to join the &lt;a href=&#34;http://www.miraclesoft.com/&#34;&gt;Miracle &lt;/a&gt;team at Visakhapatnam today for an Azure MVP bootcamp. I spoke about &lt;a href=&#34;https://github.com/rchaganti/Presentations/tree/master/Azure-Boot-Camp-Vizag2016&#34;&gt;Microsoft Azure Cloud and DevOps&lt;/a&gt;. This event, I must say, it a very well organized and orchestrated. I have been to conferences and events in India and outside India and never seen this level of care of speakers and attendees anywhere.&lt;/p&gt;
&lt;p&gt;I started my day with a good morning walk along the beach and just loved it. I wish I get to do this often.&lt;/p&gt;
&lt;p&gt;Finally, in my session, there were 100+ attendees and it was very interactive. Here are the slides from that session.&lt;/p&gt;

    &lt;iframe
        src=&#34;//www.slideshare.net/slideshow/embed_code/key/9I392jmqcxwHLF&#34;
        title=&#34;SlideShare Presentation&#34;
        height=&#34;400&#34;
        frameborder=&#34;0&#34;
        marginwidth=&#34;0&#34;
        marginheight=&#34;0&#34;
        scrolling=&#34;no&#34;
        style=&#34;border: 1px solid #CCC; border-width: 1px; margin-bottom: 20px; width: 100%;&#34;
        allowfullscreen=&#34;true&#34;&gt;
    &lt;/iframe&gt;

</description>
    </item>
    
    <item>
      <title>Custom Template Deployment Improvements in Azure Portal</title>
      <link>https://ravichaganti.com/blog/custom-template-deployment-improvements-in-azure-portal/</link>
      <pubDate>Tue, 29 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ravichaganti.com/blog/custom-template-deployment-improvements-in-azure-portal/</guid>
      <description>&lt;p&gt;When testing ARM templates, I typically use the custom template deployment option in the Azure Portal. This UI option just got better! This deployment option now supports lists the parameters, variables, and resources used in template in a nice treeview navigation.&lt;/p&gt;
&lt;p&gt;To start a new deployment, you can click on New -&amp;gt; Template Deployment.&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&#34;https://ravichaganti.com/images/armtemplate11-1.png&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;This opens up the Custom Deployment blade. Click on Edit Template.&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&#34;https://ravichaganti.com/images/armtemplate11-2.png&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;In the Edit Template blade, copy/paste your template JSON in the editor.&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&#34;https://ravichaganti.com/images/armtemplate11-3.png&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;In a few seconds, you will see the treeview built for the template. You can expand each node to see the individual elements within each category. Selecting a specific element within a node navigates to the definition for that selection within the JSON template.&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&#34;https://ravichaganti.com/images/armtemplate11-4.png&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;You can click Save and then proceed to the deployment by completing the remaining steps in the custom deployment.&lt;/p&gt;
&lt;p&gt;The second enhancement is the option to pull a quick start &lt;a href=&#34;https://github.com/Azure/azure-quickstart-templates&#34;&gt;template from the Github repository&lt;/a&gt; and deploy it!&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&#34;https://ravichaganti.com/images/armtemplate11-5.png&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;In the &lt;em&gt;Load a quickstart template&lt;/em&gt; blade, you can select a template listed in the dropdown.&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&#34;https://ravichaganti.com/images/armtemplate11-6.png&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;Clicking OK in this blade opens the template in the Edit Template blade where you can make changes as needed and save it.&lt;/p&gt;
&lt;p&gt;These are two nice surprises this morning. Anymore waiting? 🙂&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Building Azure Resource Manager Templates – Forcing WMF 4.0 when using DSC Extension</title>
      <link>https://ravichaganti.com/blog/building-azure-resource-manager-templates-forcing-wmf-4-0-when-using-dsc-extension/</link>
      <pubDate>Mon, 15 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ravichaganti.com/blog/building-azure-resource-manager-templates-forcing-wmf-4-0-when-using-dsc-extension/</guid>
      <description>&lt;p&gt;This subject won&amp;rsquo;t really need a post of its own but I will do it anyway. In the previous part of this &lt;a href=&#34;http://azrs.tk/armseries&#34;&gt;ARM series&lt;/a&gt;, I showed how we can use the domain join extension instead of DSC to join a VM to an existing AD domain. This resulted is huge savings in time taken to deploy the entire scenario. When I was talking to my good friend, fellow PowerShell MVP and all-things-Azure guru, &lt;a href=&#34;https://twitter.com/bgelens&#34;&gt;Ben Gelens&lt;/a&gt;, he was quick to point that the delays when using DSC extension here could be due to the install of WMF 5.0. Indeed!&lt;/p&gt;
&lt;p&gt;When you use Azure DSC extension, it by default installs latest available version of WMF 5.0 (production preview at the time of this writing) which requires a reboot! Therefore, using DSC extension in ARM templates for down-level OS such as Windows Server 2012 or 2012 R2, there will be delays. But, there is a workaround. We can force DSC extension to use WMF 4.0. Here is how we do that.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;{
    &amp;#34;type&amp;#34;: &amp;#34;Microsoft.Compute/virtualMachines/extensions&amp;#34;,
    &amp;#34;copy&amp;#34;: {
        &amp;#34;name&amp;#34;: &amp;#34;vmDomainLoop&amp;#34;,
        &amp;#34;count&amp;#34;: &amp;#34;[variables(&amp;#39;selectedDeployment&amp;#39;).instancesCount]&amp;#34;
    },
    &amp;#34;name&amp;#34;: &amp;#34;[concat(&amp;#39;vm&amp;#39;,copyIndex(1),&amp;#39;/domainjoin&amp;#39;)]&amp;#34;,
    &amp;#34;apiVersion&amp;#34;: &amp;#34;2015-05-01-preview&amp;#34;,
    &amp;#34;location&amp;#34;: &amp;#34;[resourceGroup().location]&amp;#34;,
    &amp;#34;dependsOn&amp;#34;: [
        &amp;#34;vmLoop&amp;#34;
    ],
    &amp;#34;properties&amp;#34;: {
        &amp;#34;publisher&amp;#34;: &amp;#34;Microsoft.Powershell&amp;#34;,
        &amp;#34;type&amp;#34;: &amp;#34;DSC&amp;#34;,
        &amp;#34;typeHandlerVersion&amp;#34;: &amp;#34;2.8&amp;#34;,
        &amp;#34;settings&amp;#34;: {
            &amp;#34;ModulesUrl&amp;#34;: &amp;#34;[concat(parameters(&amp;#39;assetLocation&amp;#39;),&amp;#39;/Configuration.zip&amp;#39;)]&amp;#34;,
            &amp;#34;WmfVersion&amp;#34;:  &amp;#34;4.0&amp;#34;,
            &amp;#34;ConfigurationFunction&amp;#34;: &amp;#34;Configuration.ps1\\DomainJoin&amp;#34;,
            &amp;#34;Properties&amp;#34;: {
                &amp;#34;DomainName&amp;#34;: &amp;#34;[parameters(&amp;#39;adDomainName&amp;#39;)]&amp;#34;,
                &amp;#34;AdminCreds&amp;#34;: {
                    &amp;#34;UserName&amp;#34;: &amp;#34;[parameters(&amp;#39;adminUsername&amp;#39;)]&amp;#34;,
                    &amp;#34;Password&amp;#34;: &amp;#34;PrivateSettingsRef:adminPassword&amp;#34;
                }
            }
        },
        &amp;#34;protectedSettings&amp;#34;: {
            &amp;#34;Items&amp;#34;: {
                &amp;#34;adminPassword&amp;#34;: &amp;#34;[parameters(&amp;#39;adminPassword&amp;#39;)]&amp;#34;
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Observe line number 19. We use the WmfVersion property and set it to 4.0. This forces DSC extension to use WMF 4.0 instead of installing latest WMF 5.0 bits. Remember to use this method, for down-level OS where WMF / PS 5.0 isn’t available by default and where you don’t need any features provided by WMF / PS 5.0, to make sure deployment times are optimized.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; If you need to do this outside an ARM template, &lt;a href=&#34;https://blogs.msdn.microsoft.com/powershell/2015/10/01/how-to-use-wmf-4-with-azure-dsc-extension-in-azure-cloud-service-manager-asm/&#34;&gt;you can do so by creating the JSON needed for this and then use the Azure PowerShell cmdlets&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;You can click the Deploy to Azure button below to deploy the sample scenario detailed in this article series.&lt;/p&gt;

    &lt;a href=&#34;https://portal.azure.com/#create/Microsoft.Template/uri/https%3a%2f%2fportal.azure.com%2f%23create%2fMicrosoft.Template%2furi%2fhttps%253A%252F%252Fraw.githubusercontent.com%252Frchaganti%252Farmseries%252Fmaster%252Farm-series_Storage-VirtualNet-LinkedTemplate-Complete.json&#34; target=&#34;_blank&#34;&gt;
        &lt;img src=&#34;https://raw.githubusercontent.com/Azure/azure-quickstart-templates/master/1-CONTRIBUTION-GUIDE/images/deploytoazure.svg?sanitize=true&#34; alt=&#34;&#34;&gt;
    &lt;/a&gt;
    &lt;br /&gt;

&lt;p&gt;By forcing DSC extension to use WMF 4.0, the complete sample scenario (with one AD VM and three VMs joining the domain) was completed in 33 mins!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Building Azure Resource Manager Templates – Using Domain Join Extension</title>
      <link>https://ravichaganti.com/blog/building-azure-resource-manager-templates-using-domain-join-extension/</link>
      <pubDate>Sat, 13 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ravichaganti.com/blog/building-azure-resource-manager-templates-using-domain-join-extension/</guid>
      <description>&lt;p&gt;The scenario that we used to understand and build ARM templates contained a domain controller VM along with one or more VMs that joined the domain service hosted by the DC VM.&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&#34;https://ravichaganti.com/images/armtemplate9-1.png&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;To make sure the VMs join the domain, we used PowerShell DSC configuration. One of the biggest quirks, at least what I faced, with DSC extension with ARM templates is that it takes little longer to complete. For example, the complete scenario deployment took almost 48 minutes to deploy. I am not making up that number. Here is the proof.&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&#34;https://ravichaganti.com/images/armtemplate9-2.png&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;Now, 48 minutes may not sound that worse but imagine deploying tens of VMs that need to join the domain using the DSC configuration as we saw in the earlier example in this series.&lt;/p&gt;
&lt;p&gt;This is where the new JsonADDomainExtension helps! Instead of using DSC configuration to add VMs to a AD domain, we will now use this VM extension. Within the [earlier template that deployed this scenario][1], we will remove the domainJoin resource definition and replace that with JsonADDomainExtension.&lt;/p&gt;
&lt;p&gt;Here is how that new resource definition looks.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&amp;#34;resources&amp;#34;: [
    {
        &amp;#34;apiVersion&amp;#34;: &amp;#34;2015-06-15&amp;#34;,
        &amp;#34;type&amp;#34;: &amp;#34;Microsoft.Compute/virtualMachines/extensions&amp;#34;,
        &amp;#34;name&amp;#34;: &amp;#34;[concat(concat(&amp;#39;vm&amp;#39;,copyIndex(1)),&amp;#39;/joindomain&amp;#39;)]&amp;#34;,
        &amp;#34;location&amp;#34;: &amp;#34;[resourceGroup().location]&amp;#34;,
        &amp;#34;dependsOn&amp;#34;: [
                &amp;#34;[concat(&amp;#39;Microsoft.Compute/virtualMachines/&amp;#39;, concat(&amp;#39;vm&amp;#39;,copyIndex(1)))]&amp;#34;
        ],                    
        &amp;#34;properties&amp;#34;: {
            &amp;#34;publisher&amp;#34;: &amp;#34;Microsoft.Compute&amp;#34;,
            &amp;#34;type&amp;#34;: &amp;#34;JsonADDomainExtension&amp;#34;,
            &amp;#34;typeHandlerVersion&amp;#34;: &amp;#34;1.0&amp;#34;,
            &amp;#34;settings&amp;#34;: {
                &amp;#34;Name&amp;#34;: &amp;#34;[parameters(&amp;#39;adDomainName&amp;#39;)]&amp;#34;,
                &amp;#34;User&amp;#34;: &amp;#34;[concat(parameters(&amp;#39;adDomainName&amp;#39;), &amp;#39;\\&amp;#39;, parameters(&amp;#39;adminUserName&amp;#39;))]&amp;#34;,
                &amp;#34;Restart&amp;#34;: &amp;#34;true&amp;#34;,
                &amp;#34;Options&amp;#34;: &amp;#34;3&amp;#34;,
                &amp;#34;OUPath&amp;#34;: &amp;#34;[parameters(&amp;#39;OUPath&amp;#39;)]&amp;#34;
            },
            &amp;#34;protectedsettings&amp;#34;: {
                &amp;#34;Password&amp;#34;: &amp;#34;[parameters(&amp;#39;adminPassword&amp;#39;)]&amp;#34;
            }
        }
    }
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In this extension settings, I am re-using a few parameters such as &lt;em&gt;adDomainName&lt;/em&gt;, &lt;em&gt;adminUserName&lt;/em&gt;, and &lt;em&gt;adminPassword&lt;/em&gt;. I added a new parameter called &lt;em&gt;OUPath&lt;/em&gt;. This specifies the organization unit for the VM computer account and it is not mandatory to specify this. Let’s take a quick look at the properties of this resource.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;Property Name&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Name&lt;/td&gt;
&lt;td&gt;Name of the Active Directory Domain to join&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;User&lt;/td&gt;
&lt;td&gt;Administrator account name to authenticate&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Restart&lt;/td&gt;
&lt;td&gt;Specifies if the VM should restart after domain join. Possible values: true or false&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Options&lt;/td&gt;
&lt;td&gt;Domain join options. Default option is 3.Refer to &lt;a href=&#34;https://msdn.microsoft.com/en-us/library/windows/desktop/aa370433(v=vs.85).aspx&#34;&gt;NetJoin options on MSDN&lt;/a&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;OUPath&lt;/td&gt;
&lt;td&gt;Organization Unit for the VM computer account. It is not mandatory to specify this value.Example specification: OU=testOU; DC=domain; DC=Domain; DC=com&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;The &lt;a href=&#34;https://github.com/rchaganti/armseries/blob/master/arm-series_Final-JoinDomain-Extension.json&#34;&gt;complete template that uses this new extension&lt;/a&gt; is rather lengthy. So, click on the below Deploy to Azure button to deploy this template.&lt;/p&gt;

    &lt;a href=&#34;https://portal.azure.com/#create/Microsoft.Template/uri/https%3a%2f%2fportal.azure.com%2f%23create%2fMicrosoft.Template%2furi%2fhttps%253A%252F%252Fraw.githubusercontent.com%252Frchaganti%252Farmseries%252Fmaster%252Farm-series_Final-JoinDomain-Extension.json&#34; target=&#34;_blank&#34;&gt;
        &lt;img src=&#34;https://raw.githubusercontent.com/Azure/azure-quickstart-templates/master/1-CONTRIBUTION-GUIDE/images/deploytoazure.svg?sanitize=true&#34; alt=&#34;&#34;&gt;
    &lt;/a&gt;
    &lt;br /&gt;

&lt;p&gt;As compared to the DSC way of joining a domain, the new domain join extension method took only 31 minutes. This is it for now! Try this template and let me know what you think.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Building Azure Resource Manager Templates – Putting it all together</title>
      <link>https://ravichaganti.com/blog/building-azure-resource-manager-templates-putting-it-all-together/</link>
      <pubDate>Fri, 18 Dec 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ravichaganti.com/blog/building-azure-resource-manager-templates-putting-it-all-together/</guid>
      <description>&lt;p&gt;In this series so far, we looked at building ARM templates by example. The focus was not really on the resource types or how to use resource definitions. Instead, our focus was on learning the basics of template language. To that extent, we have a scenario that we want to deploy and we are incrementally building the template for it.&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&#34;https://ravichaganti.com/images/armtemplate8-1.png&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;While building an ARM template for this, we looked at how to use parameters and variables. We looked at using copy object to create multiple instances of a resource type without really writing the resource definition multiple times. We went on to find out how we can define dependencies between different resource types so they are orchestrated in the right order. We looked at how we can decompose the template into purpose-specific external templates and how to link them together. While learning these concepts, we created a template that almost built the scenario we started with.&lt;/p&gt;
&lt;p&gt;We will now add the remaining VMs based on the &lt;em&gt;environmentType&lt;/em&gt; selected by the user. So, based on the VM instance count we need, we have to create network interfaces and virtual machines. We have already provisioned the inbound NAT rules needed for the RDP access to these virtual machine consoles post deployment.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;{
  &amp;#34;apiVersion&amp;#34;: &amp;#34;2015-06-15&amp;#34;,
  &amp;#34;type&amp;#34;: &amp;#34;Microsoft.Network/loadBalancers/inboundNatRules&amp;#34;,
  &amp;#34;copy&amp;#34;: {
    &amp;#34;name&amp;#34;: &amp;#34;lbRdpNatLoop&amp;#34;,
    &amp;#34;count&amp;#34;: &amp;#34;[variables(&amp;#39;selectedDeployment&amp;#39;).instancesCount]&amp;#34;
  },
  &amp;#34;name&amp;#34;: &amp;#34;[concat(&amp;#39;/loadBalancer/&amp;#39;,&amp;#39;VM&amp;#39;, copyIndex(1),&amp;#39;-RDP&amp;#39;)]&amp;#34;,
  &amp;#34;location&amp;#34;: &amp;#34;[resourceGroup().location]&amp;#34;,
  &amp;#34;dependsOn&amp;#34;: [
    &amp;#34;Microsoft.Network/loadBalancers/loadBalancer&amp;#34;
  ],
  &amp;#34;properties&amp;#34;: {
    &amp;#34;frontendIPConfiguration&amp;#34;: {
      &amp;#34;id&amp;#34;: &amp;#34;[concat(resourceId(&amp;#39;Microsoft.Network/loadBalancers&amp;#39;,&amp;#39;loadBalancer&amp;#39;),&amp;#39;/frontendIPConfigurations/LBFrontEnd&amp;#39;)]&amp;#34;
    },
    &amp;#34;protocol&amp;#34;: &amp;#34;tcp&amp;#34;,
    &amp;#34;frontendPort&amp;#34;: &amp;#34;[add(3389, copyIndex(1))]&amp;#34;,
    &amp;#34;backendPort&amp;#34;: 3389,
    &amp;#34;enableFloatingIP&amp;#34;: false
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Look at line number 8. We are building the name of the inbound NAT rule using &lt;em&gt;copyIndex()&lt;/em&gt;. This gives us the ability to differentiate between NAT rules for different VMs. We now have to create the equal number of VM network interfaces based on the instance count selected. Here is how we do it.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;{
    &amp;#34;apiVersion&amp;#34;: &amp;#34;2015-05-01-preview&amp;#34;,
    &amp;#34;type&amp;#34;: &amp;#34;Microsoft.Network/networkInterfaces&amp;#34;,
    &amp;#34;name&amp;#34;: &amp;#34;[concat(&amp;#39;vm&amp;#39;, copyIndex(1), &amp;#39;-nif&amp;#39;)]&amp;#34;,
    &amp;#34;location&amp;#34;: &amp;#34;[resourceGroup().location]&amp;#34;,
    &amp;#34;copy&amp;#34;: {
        &amp;#34;name&amp;#34;: &amp;#34;vmNetworkLoop&amp;#34;,
        &amp;#34;count&amp;#34;: &amp;#34;[variables(&amp;#39;selectedDeployment&amp;#39;).instancesCount]&amp;#34;
    },
    &amp;#34;dependsOn&amp;#34;: [
        &amp;#34;Microsoft.Network/loadBalancers/loadBalancer&amp;#34;,
        &amp;#34;[concat(&amp;#39;Microsoft.Network/virtualNetworks/&amp;#39;, parameters(&amp;#39;vNetName&amp;#39;))]&amp;#34;,
        &amp;#34;Microsoft.Resources/deployments/updatevnetdns&amp;#34;,
        &amp;#34;lbRdpNatLoop&amp;#34;
    ],
    &amp;#34;properties&amp;#34;: {
        &amp;#34;ipConfigurations&amp;#34;: [
            {
                &amp;#34;name&amp;#34;: &amp;#34;[concat(&amp;#39;vm&amp;#39;, copyIndex(1), &amp;#39;-ipconfig&amp;#39;)]&amp;#34;,
                &amp;#34;properties&amp;#34;: {
                    &amp;#34;privateIPAllocationMethod&amp;#34;: &amp;#34;dynamic&amp;#34;,
                    &amp;#34;subnet&amp;#34;: {
                        &amp;#34;id&amp;#34;: &amp;#34;[variables(&amp;#39;vNetSubnet1ID&amp;#39;)]&amp;#34;
                    },
                    &amp;#34;loadBalancerBackendAddressPools&amp;#34;: [
                        {
                            &amp;#34;id&amp;#34;: &amp;#34;[concat(resourceId(&amp;#39;Microsoft.Network/loadBalancers&amp;#39;,&amp;#39;loadBalancer&amp;#39;),&amp;#39;/backendAddressPools/LBBackEnd&amp;#39;)]&amp;#34;
                        }
                    ],
                    &amp;#34;loadBalancerInboundNatRules&amp;#34;: [
                        {
                            &amp;#34;id&amp;#34;: &amp;#34;[concat(resourceId(&amp;#39;Microsoft.Network/loadBalancers&amp;#39;,&amp;#39;loadBalancer&amp;#39;),concat(&amp;#39;/inboundNatRules/VM&amp;#39;,copyIndex(1),&amp;#39;-RDP&amp;#39;))]&amp;#34;
                        }
                    ]
                }
            }
        ]
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Let us discuss this definition a bit. We need to ensure that the network interfaces are bound to the load balancer. Without this, the RDP endpoints that we created within the NAT rules will not apply to the VMs. To achieve this, we defined dependency (line number 14) on the NAT rules resource definition identified using &lt;em&gt;lbRdpNatLoop&lt;/em&gt;. So, this is how we depend on the copy loop within the ARM template language. Line number 32 attaches the right RDP NAT rule for the VM by using the &lt;em&gt;copyIndex()&lt;/em&gt; function again.&lt;/p&gt;
&lt;p&gt;Now that we have the network interfaces required (based on the instance count), we can create the virtual machines needed based on the &lt;em&gt;envrionmentType&lt;/em&gt; (Development or Test or Production). Based on this choice, there may be more than one virtual machine that gets created. Where there is more than one VM behind a load balancer, we would need an availability set attached to those VMs. So, let us add the resource definition for the availability set.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;{
    &amp;#34;type&amp;#34;: &amp;#34;Microsoft.Compute/availabilitySets&amp;#34;,
    &amp;#34;name&amp;#34;: &amp;#34;availabilitySet&amp;#34;,
    &amp;#34;apiVersion&amp;#34;: &amp;#34;2015-06-15&amp;#34;,
    &amp;#34;location&amp;#34;: &amp;#34;[resourceGroup().location]&amp;#34;,
    &amp;#34;properties&amp;#34;: {}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;We can now go ahead create the virtual machines we need.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;{
    &amp;#34;apiVersion&amp;#34;: &amp;#34;2015-05-01-preview&amp;#34;,
    &amp;#34;type&amp;#34;: &amp;#34;Microsoft.Compute/virtualMachines&amp;#34;,
    &amp;#34;copy&amp;#34;: {
        &amp;#34;name&amp;#34;: &amp;#34;vmLoop&amp;#34;,
        &amp;#34;count&amp;#34;: &amp;#34;[variables(&amp;#39;selectedDeployment&amp;#39;).instancesCount]&amp;#34;
    },
    &amp;#34;name&amp;#34;: &amp;#34;[concat(&amp;#39;vm&amp;#39;,copyIndex(1))]&amp;#34;,
    &amp;#34;location&amp;#34;: &amp;#34;[resourceGroup().location]&amp;#34;,
    &amp;#34;dependsOn&amp;#34;: [
        &amp;#34;[concat(&amp;#39;Microsoft.Compute/virtualMachines/&amp;#39;, parameters(&amp;#39;dcVMName&amp;#39;))]&amp;#34;,
        &amp;#34;[concat(&amp;#39;Microsoft.Storage/storageAccounts/&amp;#39;, parameters(&amp;#39;storageAccountName&amp;#39;))]&amp;#34;,
        &amp;#34;vmNetworkLoop&amp;#34;
    ],
    &amp;#34;properties&amp;#34;: {
        &amp;#34;availabilitySet&amp;#34;: {
            &amp;#34;id&amp;#34;: &amp;#34;[resourceId(&amp;#39;Microsoft.Compute/availabilitySets&amp;#39;,&amp;#39;availabilitySet&amp;#39;)]&amp;#34;
        },
        &amp;#34;hardwareProfile&amp;#34;: {
            &amp;#34;vmSize&amp;#34;: &amp;#34;[parameters(&amp;#39;vmSize&amp;#39;)]&amp;#34;
        },
        &amp;#34;osProfile&amp;#34;: {
            &amp;#34;computername&amp;#34;: &amp;#34;[concat(&amp;#39;vm&amp;#39;,copyIndex(1))]&amp;#34;,
            &amp;#34;adminUsername&amp;#34;: &amp;#34;[parameters(&amp;#39;adminUsername&amp;#39;)]&amp;#34;,
            &amp;#34;adminPassword&amp;#34;: &amp;#34;[parameters(&amp;#39;adminPassword&amp;#39;)]&amp;#34;
        },
        &amp;#34;storageProfile&amp;#34;: {
            &amp;#34;imageReference&amp;#34;: {
                &amp;#34;publisher&amp;#34;: &amp;#34;[variables(&amp;#39;imagePublisher&amp;#39;)]&amp;#34;,
                &amp;#34;offer&amp;#34;: &amp;#34;[variables(&amp;#39;imageOffer&amp;#39;)]&amp;#34;,
                &amp;#34;sku&amp;#34;: &amp;#34;[parameters(&amp;#39;windowsOSVersion&amp;#39;)]&amp;#34;,
                &amp;#34;version&amp;#34;: &amp;#34;latest&amp;#34;
            },
            &amp;#34;osDisk&amp;#34;: {
                &amp;#34;name&amp;#34;: &amp;#34;osdisk&amp;#34;,
                &amp;#34;vhd&amp;#34;: {
                    &amp;#34;uri&amp;#34;: &amp;#34;[concat(&amp;#39;http://&amp;#39;,parameters(&amp;#39;storageAccountName&amp;#39;),&amp;#39;.blob.core.windows.net/vhds/&amp;#39;, concat(&amp;#39;vm&amp;#39;,copyIndex(1),&amp;#39;-osdisk.vhd&amp;#39;))]&amp;#34;
                },
                &amp;#34;caching&amp;#34;: &amp;#34;ReadWrite&amp;#34;,
                &amp;#34;createOption&amp;#34;: &amp;#34;FromImage&amp;#34;
            }
        },
        &amp;#34;networkProfile&amp;#34;: {
            &amp;#34;networkInterfaces&amp;#34;: [
                {
                    &amp;#34;id&amp;#34;: &amp;#34;[resourceId(&amp;#39;Microsoft.Network/networkInterfaces&amp;#39;,concat(&amp;#39;vm&amp;#39;,CopyIndex(1),&amp;#39;-nif&amp;#39;))]&amp;#34;
                }
            ]
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;We, once again, use a copy object in this definition to create as many virtual machines as we need based on the derived instance count. We also attach (line number 46) the network interfaces created in an earlier step. Once these VMs are created, we need to join them to the domain we created using DSC extension earlier. This is done using DSC again!&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;{
    &amp;#34;type&amp;#34;: &amp;#34;Microsoft.Compute/virtualMachines/extensions&amp;#34;,
    &amp;#34;copy&amp;#34;: {
        &amp;#34;name&amp;#34;: &amp;#34;vmDomainLoop&amp;#34;,
        &amp;#34;count&amp;#34;: &amp;#34;[variables(&amp;#39;selectedDeployment&amp;#39;).instancesCount]&amp;#34;
    },
    &amp;#34;name&amp;#34;: &amp;#34;[concat(&amp;#39;vm&amp;#39;,copyIndex(1),&amp;#39;/domainjoin&amp;#39;)]&amp;#34;,
    &amp;#34;apiVersion&amp;#34;: &amp;#34;2015-05-01-preview&amp;#34;,
    &amp;#34;location&amp;#34;: &amp;#34;[resourceGroup().location]&amp;#34;,
    &amp;#34;dependsOn&amp;#34;: [
        &amp;#34;vmLoop&amp;#34;
    ],
    &amp;#34;properties&amp;#34;: {
        &amp;#34;publisher&amp;#34;: &amp;#34;Microsoft.Powershell&amp;#34;,
        &amp;#34;type&amp;#34;: &amp;#34;DSC&amp;#34;,
        &amp;#34;typeHandlerVersion&amp;#34;: &amp;#34;2.8&amp;#34;,
        &amp;#34;settings&amp;#34;: {
            &amp;#34;ModulesUrl&amp;#34;: &amp;#34;[concat(parameters(&amp;#39;assetLocation&amp;#39;),&amp;#39;/Configuration.zip&amp;#39;)]&amp;#34;,
            &amp;#34;ConfigurationFunction&amp;#34;: &amp;#34;Configuration.ps1\\DomainJoin&amp;#34;,
            &amp;#34;Properties&amp;#34;: {
                &amp;#34;DomainName&amp;#34;: &amp;#34;[parameters(&amp;#39;adDomainName&amp;#39;)]&amp;#34;,
                &amp;#34;AdminCreds&amp;#34;: {
                    &amp;#34;UserName&amp;#34;: &amp;#34;[parameters(&amp;#39;adminUsername&amp;#39;)]&amp;#34;,
                    &amp;#34;Password&amp;#34;: &amp;#34;PrivateSettingsRef:adminPassword&amp;#34;
                }
            }
        },
        &amp;#34;protectedSettings&amp;#34;: {
            &amp;#34;Items&amp;#34;: {
                &amp;#34;adminPassword&amp;#34;: &amp;#34;[parameters(&amp;#39;adminPassword&amp;#39;)]&amp;#34;
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Line numbers 18 and 19 got the real magic that we need to join an existing domain. I packaged all DSC configurations I need for the DC creation and domain join into the configuration.zip file. We give this path to the DSC extension and tell this extension to use the &lt;em&gt;DomainJoin&lt;/em&gt; configuration from the Configuration.ps1 file from the zip package.&lt;/p&gt;
&lt;p&gt;This completes the resource definitions needed for the scenario we have. The complete ARM template is rather lengthy. So, I will not put the entire contents here but you can find it at &lt;a href=&#34;https://github.com/rchaganti/armseries/blob/master/arm-series_Storage-VirtualNet-LinkedTemplate-Complete.json&#34;&gt;https://github.com/rchaganti/armseries/blob/master/arm-series_Storage-VirtualNet-LinkedTemplate-Complete.json&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;You can optionally click on the below button to deploy the complete template right away.&lt;/p&gt;

    &lt;a href=&#34;https://portal.azure.com/#create/Microsoft.Template/uri/https%3a%2f%2fportal.azure.com%2f%23create%2fMicrosoft.Template%2furi%2fhttps%253A%252F%252Fraw.githubusercontent.com%252Frchaganti%252Farmseries%252Fmaster%252Farm-series_Storage-VirtualNet-LinkedTemplate-Complete.json&#34; target=&#34;_blank&#34;&gt;
        &lt;img src=&#34;https://raw.githubusercontent.com/Azure/azure-quickstart-templates/master/1-CONTRIBUTION-GUIDE/images/deploytoazure.svg?sanitize=true&#34; alt=&#34;&#34;&gt;
    &lt;/a&gt;
    &lt;br /&gt;

&lt;p&gt;Once you deploy this, you can verify that we have the configuration done in the right away by looking at the load balancer NAT rules and how they are mapped to the VMs in the backendpool.&lt;/p&gt;
&lt;p&gt;This completes our learning of the basics of ARM template language. Hope you have learned enough to go get started with writing ARM templates. I will continue this series writing about the best practices, tips and tricks around ARM template authoring. Stay tuned for more.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Building Azure Resource Manager Templates – Using Linked Templates</title>
      <link>https://ravichaganti.com/blog/building-azure-resource-manager-templates-using-linked-templates/</link>
      <pubDate>Mon, 14 Dec 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ravichaganti.com/blog/building-azure-resource-manager-templates-using-linked-templates/</guid>
      <description>&lt;p&gt;One of the ARM template authoring best practices is to decompose the JSON template, if applicable, into multiple target-specific templates. Think of this as creating re-usable code. You can leverage the re-usable parts of your code within multiple aspects of your application or the deployment.&lt;/p&gt;
&lt;p&gt;For linking different external templates within the main template, we need to define the &lt;em&gt;Microsoft.Resources/deployments&lt;/em&gt; resource instance. Before we proceed let us look at the scenario for which we are building an ARM template.&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&#34;https://ravichaganti.com/images/armtemplate7-1.png&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;So far in this series, we have looked at building an ARM template that deploys the following components of this scenario:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A storage account&lt;/li&gt;
&lt;li&gt;A virtual network&lt;/li&gt;
&lt;li&gt;A public IP address&lt;/li&gt;
&lt;li&gt;A load balancer&lt;/li&gt;
&lt;li&gt;Virtual network interfaces for the DC and other VMs based on the environment type.&lt;/li&gt;
&lt;li&gt;Finally, a VM with DNS and Directory Services running in it.&lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;
    &lt;img src=&#34;https://ravichaganti.com/images/armtemplate7-2&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;By default, the Azure based IaaS deployments use the Azure DNS. If you have deployed the template that we built in the previous part of this series, you will notice that the virtual network us configured to use Azure DNS.&lt;/p&gt;
&lt;p&gt;Since we deployed a VM that runs our own DNS and directory services, we now want to use the custom DNS in the Azure deployment so that other VMs in the deployment can join the domain that we created using the PowerShell DSC configuration.&lt;/p&gt;
&lt;p&gt;For this, we will use an external template and call it inside our main template. What we essentially need to do here is to update the existing virtual network to use the custom DNS. Here is how it looks.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;{
  &amp;#34;$schema&amp;#34;: &amp;#34;https://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#&amp;#34;,
  &amp;#34;contentVersion&amp;#34;: &amp;#34;1.0.0.0&amp;#34;,
  &amp;#34;parameters&amp;#34;: {
    &amp;#34;virtualNetworkName&amp;#34;: {
      &amp;#34;type&amp;#34;: &amp;#34;string&amp;#34;,
      &amp;#34;metadata&amp;#34;: {
        &amp;#34;description&amp;#34;: &amp;#34;The name of the Virtual Network to Create&amp;#34;
      }
    },
    &amp;#34;virtualNetworkAddressRange&amp;#34;: {
      &amp;#34;type&amp;#34;: &amp;#34;string&amp;#34;,
      &amp;#34;metadata&amp;#34;: {
        &amp;#34;description&amp;#34;: &amp;#34;The address range of the new VNET in CIDR format&amp;#34;
      },
      &amp;#34;defaultValue&amp;#34;: &amp;#34;10.0.0.0/16&amp;#34;
    },
    &amp;#34;subnetName&amp;#34;: {
      &amp;#34;type&amp;#34;: &amp;#34;string&amp;#34;,
      &amp;#34;metadata&amp;#34;: {
        &amp;#34;description&amp;#34;: &amp;#34;The name of the subnet created in the new VNET&amp;#34;
      }
    },
    &amp;#34;subnetRange&amp;#34;: {
      &amp;#34;type&amp;#34;: &amp;#34;string&amp;#34;,
      &amp;#34;metadata&amp;#34;: {
        &amp;#34;description&amp;#34;: &amp;#34;The address range of the subnet created in the new VNET&amp;#34;
      },
      &amp;#34;defaultValue&amp;#34;: &amp;#34;10.0.0.0/24&amp;#34;
    },
    &amp;#34;DNSServerAddress&amp;#34;: {
      &amp;#34;type&amp;#34;: &amp;#34;array&amp;#34;,
      &amp;#34;metadata&amp;#34;: {
        &amp;#34;description&amp;#34;: &amp;#34;The DNS address(es) of the DNS Server(s) used by the VNET&amp;#34;
      }
    }
  },
  &amp;#34;resources&amp;#34;: [
    {
      &amp;#34;apiVersion&amp;#34;: &amp;#34;2015-05-01-preview&amp;#34;,
      &amp;#34;name&amp;#34;: &amp;#34;[parameters(&amp;#39;virtualNetworkName&amp;#39;)]&amp;#34;,
      &amp;#34;type&amp;#34;: &amp;#34;Microsoft.Network/virtualNetworks&amp;#34;,
      &amp;#34;location&amp;#34;: &amp;#34;[resourceGroup().location]&amp;#34;,
      &amp;#34;properties&amp;#34;: {
        &amp;#34;addressSpace&amp;#34;: {
          &amp;#34;addressPrefixes&amp;#34;: [
            &amp;#34;[parameters(&amp;#39;virtualNetworkAddressRange&amp;#39;)]&amp;#34;
          ]
        },
        &amp;#34;dhcpOptions&amp;#34;: {
          &amp;#34;dnsServers&amp;#34;: &amp;#34;[parameters(&amp;#39;DNSServerAddress&amp;#39;)]&amp;#34;
        },
        &amp;#34;subnets&amp;#34;: [
          {
            &amp;#34;name&amp;#34;: &amp;#34;[parameters(&amp;#39;subnetName&amp;#39;)]&amp;#34;,
            &amp;#34;properties&amp;#34;: {
              &amp;#34;addressPrefix&amp;#34;: &amp;#34;[parameters(&amp;#39;subnetRange&amp;#39;)]&amp;#34;
            }
          }
        ]
      }
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The above template is just another ARM JSON template. It has the same syntax. We have defined parameters that are needed for updating the virtual network to use the custom DNS that we just configured. let us save this as &lt;em&gt;vnet-with-dns-server.json&lt;/em&gt; and store it at a location that is accessible to the ARM deployment engine. I chose to store it in a &lt;a href=&#34;https://github.com/rchaganti/azure-quickstart-templates/blob/master/201-vm-domain-join/vnet-with-dns-server.json&#34;&gt;public Github repository&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Now, we need to link this template to the main ARM template that we have been authoring. Here is how it is done in the main template.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;{
    &amp;#34;apiVersion&amp;#34;: &amp;#34;2015-01-01&amp;#34;,
    &amp;#34;type&amp;#34;: &amp;#34;Microsoft.Resources/deployments&amp;#34;,
    &amp;#34;name&amp;#34;: &amp;#34;updatevnetdns&amp;#34;,
    &amp;#34;dependsOn&amp;#34;: [
        &amp;#34;[concat(&amp;#39;Microsoft.Compute/virtualMachines/&amp;#39;, parameters(&amp;#39;dcVMName&amp;#39;),&amp;#39;/extensions/createadforest&amp;#39;)]&amp;#34;
    ],
    &amp;#34;properties&amp;#34;: {
        &amp;#34;mode&amp;#34;: &amp;#34;Incremental&amp;#34;,
        &amp;#34;templateLink&amp;#34;: {
            &amp;#34;uri&amp;#34;: &amp;#34;[concat(parameters(&amp;#39;assetLocation&amp;#39;),&amp;#39;/vnet-with-dns-server.json&amp;#39;)]&amp;#34;,
            &amp;#34;contentVersion&amp;#34;: &amp;#34;1.0.0.0&amp;#34;
        },
        &amp;#34;parameters&amp;#34;: {
            &amp;#34;virtualNetworkName&amp;#34;: {
                &amp;#34;value&amp;#34;: &amp;#34;[parameters(&amp;#39;vNetName&amp;#39;)]&amp;#34;
            },
            &amp;#34;virtualNetworkAddressRange&amp;#34;: {
                &amp;#34;value&amp;#34;: &amp;#34;[variables(&amp;#39;vNetPrefix&amp;#39;)]&amp;#34;
            },
            &amp;#34;subnetName&amp;#34;: {
                &amp;#34;value&amp;#34;: &amp;#34;[variables(&amp;#39;vNetSubnet1Name&amp;#39;)]&amp;#34;
            },
            &amp;#34;subnetRange&amp;#34;: {
                &amp;#34;value&amp;#34;: &amp;#34;[variables(&amp;#39;vNetSubnet1Prefix&amp;#39;)]&amp;#34;
            },
            &amp;#34;DNSServerAddress&amp;#34;: {
                &amp;#34;value&amp;#34;: [
                    &amp;#34;[variables(&amp;#39;dnsServerPrivateIp&amp;#39;)]&amp;#34;
                ]
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Within this resource instance, we defined a dependency (line number 6) on the PowerShell DSC extension that creates the AD forest. We don’t want the linked template to execute until the DNS service is created in the DC VM. Line number 11 defines the link our external template that will configure the custom DNS settings. _vnet-with-dns-server.json _has a few parameters defined for collecting required custom DNS configuration.&lt;/p&gt;
&lt;p&gt;Within the main template, we need to pass the parameter values to the external template. This is done using the parameters element within the &lt;em&gt;Microsoft.Resources/deployments&lt;/em&gt; resource instance. For the parameter values, we use either what is already gathered from the user using the main template or what is defined in the variables element of the main template. This is how state can be shared between multiple templates. If we need to return some data from the linked template to the main template, we can do so using the outputs element within the linked template. In our scenario, we don’t need any information from the linked template and therefore we will not use the outputs element.&lt;/p&gt;
&lt;p&gt;Also, notice line number 9. The mode property within the properties element is set to incremental. This is needed because we already have some of the components within the template deployed. By setting the deployment mode to incremental, we tell the deployment engine to add the new resources or update existing resource configuration within the resource group without deleting any existing resources in the group. In our example, we are updating the configuration of an existing virtual network to use the custom DNS. so, the incremental deployment mode is necessary here.&lt;/p&gt;

    &lt;a href=&#34;https://portal.azure.com/#create/Microsoft.Template/uri/https%3a%2f%2fportal.azure.com%2f%23create%2fMicrosoft.Template%2furi%2fhttps%253A%252F%252Fraw.githubusercontent.com%252Frchaganti%252Farmseries%252Fmaster%252Farm-series_Storage-VirtualNet-LinkedTemplate-DNS_Update.json&#34; target=&#34;_blank&#34;&gt;
        &lt;img src=&#34;https://raw.githubusercontent.com/Azure/azure-quickstart-templates/master/1-CONTRIBUTION-GUIDE/images/deploytoazure.svg?sanitize=true&#34; alt=&#34;&#34;&gt;
    &lt;/a&gt;
    &lt;br /&gt;

&lt;figure&gt;
    &lt;img src=&#34;https://ravichaganti.com/images/armtemplate7-3.png&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;Once you deploy this updated template, you will see that the virtual network within the resource group gets set to use the custom DNS deployed using the PowerShell DSC extension.&lt;/p&gt;
&lt;p&gt;In the next part of this series, we will look at adding more virtual machines to the deployment based on the &lt;em&gt;environmentType&lt;/em&gt; selected within the template parameters. By the end of next part, we will completely functional ARM template that deploys our scenario end to end.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Building Azure Resource Manager Templates – Defining Resource Dependencies</title>
      <link>https://ravichaganti.com/blog/building-azure-resource-manager-templates-defining-resource-dependencies/</link>
      <pubDate>Tue, 08 Dec 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ravichaganti.com/blog/building-azure-resource-manager-templates-defining-resource-dependencies/</guid>
      <description>&lt;p&gt;We will continue learning about building ARM templates by looking at how we can define dependencies between resources. To recap, here is the scenario we are working on.&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&#34;https://ravichaganti.com/images/armtemplate6-1.png&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;In the earlier parts of this series, we created the storage account, virtual network, a public IP, a load balancer, and added all inbound NAT rules required for the virtual machine RDP access. If you notice, we have components that depend on others. For example, the inbound NAT rules depend on the load balancer. Similarly, VMs depend on network interfaces which in turn depend on the virtual network. In the absence of dependencies, ARM will attempt to deploy these resources in parallel which may result in errors. So, within the resource template, we need to define these dependencies so that ARM can make decisions about the deployment sequence. There are multiple ways of doing this.&lt;/p&gt;
&lt;h4 id=&#34;using-dependson&#34;&gt;Using DependsOn&lt;/h4&gt;
&lt;p&gt;If you have noticed in the earlier parts of this series, we have used &lt;em&gt;DependsOn&lt;/em&gt; property within the resource element.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;{
    &amp;#34;apiVersion&amp;#34;: &amp;#34;2015-06-15&amp;#34;,
    &amp;#34;type&amp;#34;: &amp;#34;Microsoft.Network/loadBalancers/inboundNatRules&amp;#34;,
    &amp;#34;copy&amp;#34;: {
        &amp;#34;name&amp;#34;: &amp;#34;lbRdpNatLoop&amp;#34;,
        &amp;#34;count&amp;#34;: &amp;#34;[variables(&amp;#39;selectedDeployment&amp;#39;).instancesCount]&amp;#34;
    },
    &amp;#34;name&amp;#34;: &amp;#34;[concat(&amp;#39;/loadbalancer/&amp;#39;,&amp;#39;VM-&amp;#39;, copyIndex(1),&amp;#39;-RDP&amp;#39;)]&amp;#34;,
    &amp;#34;location&amp;#34;: &amp;#34;[resourceGroup().location]&amp;#34;,
    &amp;#34;dependsOn&amp;#34;: [
        &amp;#34;Microsoft.Network/loadBalancers/loadBalancer&amp;#34;
    ],
    &amp;#34;properties&amp;#34;: {
        &amp;#34;frontendIPConfiguration&amp;#34;: {
            &amp;#34;id&amp;#34;: &amp;#34;[resourceId(&amp;#39;Microsoft.Network/loadBalancers/frontendIPConfigurations&amp;#39;,&amp;#39;loadBalancer&amp;#39;,variables(&amp;#39;lbFrontend&amp;#39;))]&amp;#34;
        },
        &amp;#34;protocol&amp;#34;: &amp;#34;tcp&amp;#34;,
        &amp;#34;frontendPort&amp;#34;: &amp;#34;[add(3389, copyIndex(1))]&amp;#34;,
        &amp;#34;backendPort&amp;#34;: 3389,
        &amp;#34;enableFloatingIP&amp;#34;: false
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;If you look at line number 11, we added &lt;em&gt;DependsOn&lt;/em&gt; property to define that the &lt;em&gt;inboundNatRules&lt;/em&gt; depend on the load balancer configuration. This is straightforward and very easy to define. You can use template language functions such as &lt;em&gt;ResourceId()&lt;/em&gt; or &lt;em&gt;concat()&lt;/em&gt; as well within the value of &lt;em&gt;DependsOn&lt;/em&gt; and dynamically build these dependencies. You can provide more than one value here as a comma-separated list.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&amp;#34;dependsOn&amp;#34;: [
    &amp;#34;Microsoft.Network/loadBalancers/loadBalancer&amp;#34;,
    &amp;#34;Microsoft.Network/virtualNetworks/vNet1&amp;#34;
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;using-references&#34;&gt;Using References&lt;/h4&gt;
&lt;p&gt;The second method is to define reference to the dependent resource. Let us create a virtual network interface the AD VM in our scenario. This depends on the virtual network resource that we already created.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;{
    &amp;#34;apiVersion&amp;#34;: &amp;#34;2015-05-01-preview&amp;#34;,
    &amp;#34;type&amp;#34;: &amp;#34;Microsoft.Network/networkInterfaces&amp;#34;,
    &amp;#34;name&amp;#34;: &amp;#34;dcvmnif&amp;#34;,
    &amp;#34;location&amp;#34;: &amp;#34;[resourceGroup().location]&amp;#34;,
    &amp;#34;properties&amp;#34;: {
        &amp;#34;ipConfigurations&amp;#34;: [
            {
                &amp;#34;name&amp;#34;: &amp;#34;[concat(reference(parameters(&amp;#39;vNetName&amp;#39;)).subnets[0].name,parameters(&amp;#39;dcVmName&amp;#39;),&amp;#39;-nifconfig&amp;#39;)]&amp;#34;,
                &amp;#34;properties&amp;#34;: {
                    &amp;#34;privateIPAllocationMethod&amp;#34;: &amp;#34;Static&amp;#34;,
                    &amp;#34;privateIPAddress&amp;#34;: &amp;#34;[variables(&amp;#39;dnsServerPrivateIp&amp;#39;)]&amp;#34;,
                    &amp;#34;subnet&amp;#34;: {
                        &amp;#34;id&amp;#34;: &amp;#34;[variables(&amp;#39;vNetSubnet1ID&amp;#39;)]&amp;#34;
                    }
                }
            }
        ]
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Observe line number 9. We used the reference() function to get a reference to the virtual network object we created and get the subnet name from there and use it to construct the &lt;em&gt;IPConfiguration&lt;/em&gt; name. When ARM engine finds this reference, it creates an implicit dependency on the virtual network that we referenced. There is no need here to specify &lt;em&gt;DependsOn&lt;/em&gt; property.&lt;/p&gt;
&lt;p&gt;Note that we cannot use the reference() function as a part of the resource instance name. This is because the ARM engine must know the names of the resource instances before the deployment can start.&lt;/p&gt;
&lt;h4 id=&#34;child-or-nested-resources&#34;&gt;Child or Nested Resources&lt;/h4&gt;
&lt;p&gt;The 3rd way to define dependencies is to use child resources. Let us see an example before we discuss this further.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;{
    &amp;#34;apiVersion&amp;#34;: &amp;#34;2015-06-15&amp;#34;,
    &amp;#34;type&amp;#34;: &amp;#34;Microsoft.Compute/virtualMachines&amp;#34;,
    &amp;#34;name&amp;#34;: &amp;#34;[Parameters(&amp;#39;dcVMName&amp;#39;)]&amp;#34;,
    &amp;#34;location&amp;#34;: &amp;#34;[resourceGroup().location]&amp;#34;,
    &amp;#34;dependsOn&amp;#34;: [
        &amp;#34;[resourceId(&amp;#39;Microsoft.Storage/storageAccounts&amp;#39;,parameters(&amp;#39;storageAccount&amp;#39;))]&amp;#34;,
        &amp;#34;[resourceId(&amp;#39;Microsoft.Network/networkInterfaces&amp;#39;,concat(parameters(&amp;#39;dcVMName&amp;#39;),&amp;#39;-nif&amp;#39;))]&amp;#34;
    ],
    &amp;#34;properties&amp;#34;: {
        &amp;#34;hardwareProfile&amp;#34;: {
            &amp;#34;vmSize&amp;#34;: &amp;#34;[parameters(&amp;#39;vmSize&amp;#39;)]&amp;#34;
        },
        &amp;#34;osProfile&amp;#34;: {
            &amp;#34;computerName&amp;#34;: &amp;#34;[parameters(&amp;#39;dcVMName&amp;#39;)]&amp;#34;,
            &amp;#34;adminUsername&amp;#34;: &amp;#34;[parameters(&amp;#39;adminUsername&amp;#39;)]&amp;#34;,
            &amp;#34;adminPassword&amp;#34;: &amp;#34;[parameters(&amp;#39;adminPassword&amp;#39;)]&amp;#34;
        },
        &amp;#34;storageProfile&amp;#34;: {
            &amp;#34;imageReference&amp;#34;: {
                &amp;#34;publisher&amp;#34;: &amp;#34;[variables(&amp;#39;imagePublisher&amp;#39;)]&amp;#34;,
                &amp;#34;offer&amp;#34;: &amp;#34;[variables(&amp;#39;imageOffer&amp;#39;)]&amp;#34;,
                &amp;#34;sku&amp;#34;: &amp;#34;[parameters(&amp;#39;windowsOSVersion&amp;#39;)]&amp;#34;,
                &amp;#34;version&amp;#34;: &amp;#34;latest&amp;#34;
            },
            &amp;#34;osDisk&amp;#34;: {
                &amp;#34;name&amp;#34;: &amp;#34;[concat(parameters(&amp;#39;dcVMName&amp;#39;), &amp;#39;-osdisk.vhd&amp;#39;)]&amp;#34;,
                &amp;#34;vhd&amp;#34;: {
                    &amp;#34;uri&amp;#34;: &amp;#34;[concat(&amp;#39;http://&amp;#39;,parameters(&amp;#39;storageAccount&amp;#39;),&amp;#39;.blob.core.windows.net/vhds/&amp;#39;, parameters(&amp;#39;dcVMName&amp;#39;), &amp;#39;-osdisk.vhd&amp;#39;)]&amp;#34;
                },
                &amp;#34;caching&amp;#34;: &amp;#34;ReadWrite&amp;#34;,
                &amp;#34;createOption&amp;#34;: &amp;#34;FromImage&amp;#34;
            },
            &amp;#34;dataDisks&amp;#34;: [
                {
                    &amp;#34;name&amp;#34;: &amp;#34;[concat(parameters(&amp;#39;dcVMName&amp;#39;), &amp;#39;-data-disk1.vhd&amp;#39;)]&amp;#34;,
                    &amp;#34;vhd&amp;#34;: {
                        &amp;#34;uri&amp;#34;: &amp;#34;[concat(&amp;#39;http://&amp;#39;,parameters(&amp;#39;storageAccount&amp;#39;),&amp;#39;.blob.core.windows.net/vhds/&amp;#39;, parameters(&amp;#39;dcVMName&amp;#39;), &amp;#39;-data-disk1.vhd&amp;#39;)]&amp;#34;
                    },
                    &amp;#34;caching&amp;#34;: &amp;#34;None&amp;#34;,
                    &amp;#34;createOption&amp;#34;: &amp;#34;Empty&amp;#34;,
                    &amp;#34;diskSizeGB&amp;#34;: &amp;#34;1000&amp;#34;,
                    &amp;#34;lun&amp;#34;: 0
                }
            ]
        },
        &amp;#34;networkProfile&amp;#34;: {
            &amp;#34;networkInterfaces&amp;#34;: [
                {
                    &amp;#34;id&amp;#34;: &amp;#34;[resourceId(&amp;#39;Microsoft.Network/networkInterfaces&amp;#39;,concat(parameters(&amp;#39;dcVMName&amp;#39;),&amp;#39;-nif&amp;#39;))]&amp;#34;
                }
            ]
        },
        &amp;#34;diagnosticsProfile&amp;#34;: {
            &amp;#34;bootDiagnostics&amp;#34;: {
                &amp;#34;enabled&amp;#34;: &amp;#34;true&amp;#34;,
                &amp;#34;storageUri&amp;#34;: &amp;#34;[concat(&amp;#39;http://&amp;#39;,parameters(&amp;#39;storageAccount&amp;#39;),&amp;#39;.blob.core.windows.net&amp;#39;)]&amp;#34;
            }
        }
    },
    &amp;#34;resources&amp;#34;: [
        {
            &amp;#34;type&amp;#34;: &amp;#34;extensions&amp;#34;,
            &amp;#34;name&amp;#34;: &amp;#34;createadforest&amp;#34;,
            &amp;#34;apiVersion&amp;#34;: &amp;#34;2015-05-01-preview&amp;#34;,
            &amp;#34;location&amp;#34;: &amp;#34;[resourceGroup().location]&amp;#34;,
            &amp;#34;dependsOn&amp;#34;: [
                &amp;#34;[concat(&amp;#39;Microsoft.Compute/virtualMachines/&amp;#39;,parameters(&amp;#39;dcVMName&amp;#39;))]&amp;#34;
            ],
            &amp;#34;properties&amp;#34;: {
                &amp;#34;publisher&amp;#34;: &amp;#34;Microsoft.Powershell&amp;#34;,
                &amp;#34;type&amp;#34;: &amp;#34;DSC&amp;#34;,
                &amp;#34;typeHandlerVersion&amp;#34;: &amp;#34;2.8&amp;#34;,
                &amp;#34;settings&amp;#34;: {
                    &amp;#34;ModulesUrl&amp;#34;: &amp;#34;[concat(parameters(&amp;#39;assetLocation&amp;#39;),&amp;#39;/Configuration.zip&amp;#39;)]&amp;#34;,
                    &amp;#34;ConfigurationFunction&amp;#34;: &amp;#34;CreateADPDC.ps1\\CreateADPDC&amp;#34;,
                    &amp;#34;Properties&amp;#34;: {
                        &amp;#34;DomainName&amp;#34;: &amp;#34;[parameters(&amp;#39;adDomainName&amp;#39;)]&amp;#34;,
                        &amp;#34;AdminCreds&amp;#34;: {
                            &amp;#34;UserName&amp;#34;: &amp;#34;[parameters(&amp;#39;adminUsername&amp;#39;)]&amp;#34;,
                            &amp;#34;Password&amp;#34;: &amp;#34;PrivateSettingsRef:AdminPassword&amp;#34;
                        }
                    }
                },
                &amp;#34;protectedSettings&amp;#34;: {
                    &amp;#34;Items&amp;#34;: {
                        &amp;#34;AdminPassword&amp;#34;: &amp;#34;[parameters(&amp;#39;adminPassword&amp;#39;)]&amp;#34;
                    }
                }
            }
        }
    ]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This example is quite long. It is the virtual machine resource instance that we need for the domain controller. Apart from all the virtual machine properties such as storage profile and OS profile, we have something interesting at line number 61. We have another resources element within the VM resource definition. As with the top-level resources element, this is also a JSON array and contains the resource definition for the &lt;a href=&#34;http://www.powershellmagazine.com/2014/08/05/understanding-azure-vm-dsc-extension/&#34;&gt;VM DSC extension&lt;/a&gt;. It is obvious that VM DSC extension without a VM is meaningless. By defining this as a child or nested resource inside the VM resource definition, we are creating an implicit dependency between the VM and the VM DSC extension. When ARM engine looks at this in the template, it schedules VM creation before the DSC extension. BTW, this VM DSC extension has the DSC configuration required to build the domain controller in this deployment.&lt;/p&gt;
&lt;p&gt;Always make sure you that you create enough flexibility within the template for someone else to take this and deploy the template in their own environment.To this extent, I have used a parameter called &lt;em&gt;assetLocation&lt;/em&gt; (line 75) in the DSC extension properties. You can call this whatever you want. This parameter specifies where all the template assets such as DSC configuration scripts and any additional template files are stored.&lt;/p&gt;
&lt;p&gt;So far in this part, we have seen three different ways of defining dependencies between resources. If you check the template that we &lt;a href=&#34;https://github.com/rchaganti/armseries/blob/master/arm-series_Storage-VirtualNet-LB_vNIC-VM.json&#34;&gt;built so far for this scenario&lt;/a&gt;, you will observe that I have added a few more variables and parameters needed for the DC VM and its configuration.&lt;/p&gt;
&lt;p&gt;Go ahead and deploy this.&lt;/p&gt;

    &lt;a href=&#34;https://portal.azure.com/#create/Microsoft.Template/uri/https%3a%2f%2fportal.azure.com%2f%23create%2fMicrosoft.Template%2furi%2fhttps%253A%252F%252Fraw.githubusercontent.com%252Frchaganti%252Farmseries%252Fmaster%252Farm-series_Storage-VirtualNet-LB_vNIC-VM.json&#34; target=&#34;_blank&#34;&gt;
        &lt;img src=&#34;https://raw.githubusercontent.com/Azure/azure-quickstart-templates/master/1-CONTRIBUTION-GUIDE/images/deploytoazure.svg?sanitize=true&#34; alt=&#34;&#34;&gt;
    &lt;/a&gt;
    &lt;br /&gt;

&lt;p&gt;In the next part, we will look at the nested template deployments.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Building Azure Resource Manager Templates – Using Copy Object</title>
      <link>https://ravichaganti.com/blog/building-azure-resource-manager-templates-using-copy-object/</link>
      <pubDate>Tue, 17 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ravichaganti.com/blog/building-azure-resource-manager-templates-using-copy-object/</guid>
      <description>&lt;p&gt;If you are following this series, by now you know how to use parameters and variables in ARM template language. We used that knowledge to create a template that creates relevant things to like storage account and virtual network. Let us revisit the scenario.&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&#34;https://ravichaganti.com/images/armtemplate5-1.png&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;In this part, we will extend the template to add publicIP, load balancer, and RDP endpoints for the virtual machines. Before we do that, let us review what we need. To achieve what we want in this, we will use copy object in the template.&lt;/p&gt;
&lt;h4 id=&#34;what-iscopy-object&#34;&gt;What is Copy Object?&lt;/h4&gt;
&lt;p&gt;In our template, we already have the storage account and virtual network configuration defined. What we now need is a load balancer with a public IP so that we can access this deployment from the Internet. Also, we need the inbound NAT rules for enabling RDP access to the VMs in this deployment. But before we create the RDP rules for each VM, we need to know how many VM instances we are deploying. As shown in the scenario diagram, we need to be able to deploy this template within development, test, or production environment. Depending on the selected environment, we will have one AD DC VM along with 1 (development) or 2 (test) or 3 (production) VMs that join the AD domain. Therefore, we need a way to capture the environment type as an input parameter. Also, based on the environment type selected by the user, we need to decide on the number of VM instances required for the deployment and then create only relevant number of inbound NAT rules within the load balancer.&lt;/p&gt;
&lt;p&gt;There are multiple ways to achieve this.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Add multiple resource definitions; one for each resource instance we need. This does not give the flexibility to dynamically add or remove instances based on the VM count we need. This method is not efficient.&lt;/li&gt;
&lt;li&gt;Use some kind of iterator, like other programming languages, within a resource definition and tell ARM how many resource instances we need. This can be achieved using copy object technique in ARM templates.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Before we go to the copy object discussion, let us first add more parameters and variables that are needed for this template. These additional parameters will also help us with defining the iteration count within the copy object.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;parameters&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f00&#34;&gt;:&lt;/span&gt; {
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;storageAccount&amp;#34;&lt;/span&gt;: {
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;string&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;metadata&amp;#34;&lt;/span&gt;: {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;description&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Unique name for the storage account.&amp;#34;&lt;/span&gt;
        }
    },
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;storageAccountType&amp;#34;&lt;/span&gt;: {
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;string&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;defaultValue&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Standard_LRS&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;allowedValues&amp;#34;&lt;/span&gt;: [
            &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Standard_LRS&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Standard_GRS&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Standard_ZRS&amp;#34;&lt;/span&gt;
        ],
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;metadata&amp;#34;&lt;/span&gt;: {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;description&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Account type based on the storage redundancy requirements.&amp;#34;&lt;/span&gt;
        }
    },
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;vNetName&amp;#34;&lt;/span&gt;: {
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;string&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;metadata&amp;#34;&lt;/span&gt;: {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;description&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Name for the virtual network.&amp;#34;&lt;/span&gt;
        }
    },
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;DnsName&amp;#34;&lt;/span&gt;: {
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;string&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;metadata&amp;#34;&lt;/span&gt;: {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;description&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Unique public DNS prefix for the deployment. The fqdn will look something like &amp;#39;&amp;amp;lt;dnsname&amp;amp;gt;.westus.cloudapp.azure.com&amp;#39;.&amp;#34;&lt;/span&gt;
        }
    },
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;environmentType&amp;#34;&lt;/span&gt;: {
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;string&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;allowedValues&amp;#34;&lt;/span&gt;: [
            &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Development&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Test&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Production&amp;#34;&lt;/span&gt;
        ],
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;defaultValue&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Development&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;metadata&amp;#34;&lt;/span&gt;: {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;description&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Type of environment where this deployment should occur. This has an impact on the number of VMs to be depoloyed.&amp;#34;&lt;/span&gt;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Within the new parameters, we have the &lt;em&gt;dnsName&lt;/em&gt; parameter that will be for external access. The &lt;em&gt;environmentType&lt;/em&gt; parameter is used to capture whether the user is deploying this template for dev, test, or production. However, based on this selection, we need a way to find out the number of VMs we need in the domain. That is, we need know the instance count for each environment. Remember our discussion on free-form vs known configurations? We don’t want to leave such choices to the end user. So, the place where this decision can be made will be in the variables element.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;variables&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f00&#34;&gt;:&lt;/span&gt; {
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;vNetPrefix&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;10.0.0.0/16&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;vNetSubnet1Name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[concat(resourceGroup().Location, &amp;#39;-&amp;#39;, parameters(&amp;#39;vNetName&amp;#39;), &amp;#39;-&amp;#39;, &amp;#39;Subnet&amp;#39;)]&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;vNetSubnet1Prefix&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;10.0.0.0/24&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;vNetSubnet1ID&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[concat(resourceId(&amp;#39;Microsoft.Network/virtualNetworks&amp;#39;,parameters(&amp;#39;vNetName&amp;#39;)),&amp;#39;/subnets/&amp;#39;,variables(&amp;#39;vNetSubnet1Name&amp;#39;))]&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;dnsServerPrivateIp&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;10.0.0.8&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;deploymentSize&amp;#34;&lt;/span&gt;: {
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;Development&amp;#34;&lt;/span&gt;: {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;instancesCount&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;
        },
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;Test&amp;#34;&lt;/span&gt;: {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;instancesCount&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;
        },
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;Production&amp;#34;&lt;/span&gt;: {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;instancesCount&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;3&lt;/span&gt;
        }
    },
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;selectedDeployment&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[variables(&amp;#39;deploymentSize&amp;#39;)[parameters(&amp;#39;environmentType&amp;#39;)]]&amp;#34;&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Within the variables element, we defined new variables for making it easier to select the environment type. The &lt;em&gt;deploymentSize&lt;/em&gt; variable defines a JSON object. Within this, we are associating &lt;em&gt;instancesCount&lt;/em&gt; to every deployment type.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;deploymentSize&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f00&#34;&gt;:&lt;/span&gt; {
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;Development&amp;#34;&lt;/span&gt;: {
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;instancesCount&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;
    },
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;Test&amp;#34;&lt;/span&gt;: {
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;instancesCount&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;
    },
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;Production&amp;#34;&lt;/span&gt;: {
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;instancesCount&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;3&lt;/span&gt;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;We use the &lt;em&gt;selectedDeployment&lt;/em&gt; variable to retrieve the value of &lt;em&gt;deploymentSize&lt;/em&gt; variable. This is done by associating the value of environmentType parameter and looking up for that in the &lt;em&gt;deploymentSize&lt;/em&gt; variable.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;selectedDeployment&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f00&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[variables(&amp;#39;deploymentSize&amp;#39;)[parameters(&amp;#39;environmentType&amp;#39;)]]&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This works because &lt;em&gt;deploymentSize&lt;/em&gt; is a JSON object similar to a dictionary. We can index into it using one of the key names. So, in this case, the key names will match the value passed to the &lt;em&gt;environmentType&lt;/em&gt; parameter and indexing into that will give us the right object within _deploymentSize. _Once we have the selectedDeployment variable populated, we can access the &lt;em&gt;instancesCount&lt;/em&gt; value by dot-referencing the property name. For example,&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;[variables(&amp;#39;selectedDeployment&amp;#39;).instancesCount]&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This should not be alien to us. We use &lt;em&gt;variables()&lt;/em&gt; function and pass the &lt;em&gt;selectedDeployment&lt;/em&gt; variable name to it. The resulting object has the &lt;em&gt;instancesCount&lt;/em&gt; property which can then be retrieved using dot-referencing. Now that we figured this out, let us go back to the discussion around multiple instance creation within a template.&lt;/p&gt;
&lt;h4 id=&#34;working-with-copy-object&#34;&gt;Working with Copy Object&lt;/h4&gt;
&lt;p&gt;As stated earlier, the reason we need &lt;em&gt;instancesCount&lt;/em&gt; value is because we need to tell ARM how many times it has to iterate for creating the resource for which we need multiple instances. This is done within the &lt;a href=&#34;https://azure.microsoft.com/en-us/documentation/articles/resource-group-create-multiple/#copy-copyindex-and-length&#34;&gt;copy object syntax&lt;/a&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&amp;#34;copy&amp;#34;: { 
    &amp;#34;name&amp;#34;: &amp;#34;copy loop name&amp;#34;, 
    &amp;#34;count&amp;#34;: &amp;#34;integer value&amp;#34; 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The &lt;em&gt;name&lt;/em&gt; property within the &lt;em&gt;copy&lt;/em&gt; element defines a name for the iterator which can later be used for defining dependencies. The _count _property defines the number of times the iterator has to run. In our case, we will set the value of count property to the &lt;em&gt;instancesCount&lt;/em&gt; value we retrieve from the &lt;em&gt;selectedDeployment.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;We place this inside the resource definition. In our scenario, we will use the copy object within &lt;em&gt;Microsoft.Network/loadBalancers/inboundNatRules&lt;/em&gt; resource type. Let us first see the new resources that we need to enable public IP and load balancer configuration. We will then review the resource definition to understand how we use the copy object.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;resources&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f00&#34;&gt;:&lt;/span&gt; [
    {
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[parameters(&amp;#39;storageAccountName&amp;#39;)]&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Microsoft.Storage/storageAccounts&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;location&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[ResourceGroup().Location]&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;apiVersion&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;2015-05-01-preview&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;properties&amp;#34;&lt;/span&gt;: {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;accountType&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[parameters(&amp;#39;storageAccountType&amp;#39;)]&amp;#34;&lt;/span&gt;
        }
    },
    {
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[parameters(&amp;#39;vNetName&amp;#39;)]&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Microsoft.Network/virtualNetworks&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;location&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[ResourceGroup().Location]&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;apiVersion&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;2015-05-01-preview&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;properties&amp;#34;&lt;/span&gt;: {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;addressSpace&amp;#34;&lt;/span&gt;: {
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;addressPrefixes&amp;#34;&lt;/span&gt;: [
                    &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[variables(&amp;#39;vNetPrefix&amp;#39;)]&amp;#34;&lt;/span&gt;
                ]
            },
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;subnets&amp;#34;&lt;/span&gt;: [
                {
                    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[variables(&amp;#39;vNetSubnet1Name&amp;#39;)]&amp;#34;&lt;/span&gt;,
                    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;properties&amp;#34;&lt;/span&gt;: {
                        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;addressPrefix&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[variables(&amp;#39;vNetSubnet1Prefix&amp;#39;)]&amp;#34;&lt;/span&gt;
                    }
                }
            ]
        }
    },
    {
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;apiVersion&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;2015-05-01-preview&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Microsoft.Network/publicIPAddresses&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;publicIp&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;location&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[resourceGroup().location]&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;properties&amp;#34;&lt;/span&gt;: {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;publicIPAllocationMethod&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Dynamic&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;dnsSettings&amp;#34;&lt;/span&gt;: {
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;domainNameLabel&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[parameters(&amp;#39;DnsName&amp;#39;)]&amp;#34;&lt;/span&gt;
            }
        }
    },
    {
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;apiVersion&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;2015-05-01-preview&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;loadBalancer&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Microsoft.Network/loadBalancers&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;location&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[resourceGroup().location]&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;dependsOn&amp;#34;&lt;/span&gt;: [
            &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Microsoft.Network/publicIPAddresses/publicIp&amp;#34;&lt;/span&gt;
        ],
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;properties&amp;#34;&lt;/span&gt;: {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;frontendIPConfigurations&amp;#34;&lt;/span&gt;: [
                {
                    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[variables(&amp;#39;lbFrontend&amp;#39;)]&amp;#34;&lt;/span&gt;,
                    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;properties&amp;#34;&lt;/span&gt;: {
                        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;publicIPAddress&amp;#34;&lt;/span&gt;: {
                            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;id&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[resourceId(&amp;#39;Microsoft.Network/publicIPAddresses&amp;#39;,&amp;#39;publicIp&amp;#39;)]&amp;#34;&lt;/span&gt;
                        }
                    }
                }
            ],
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;backendAddressPools&amp;#34;&lt;/span&gt;: [
                {
                    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[variables(&amp;#39;lbBackendAddrPool&amp;#39;)]&amp;#34;&lt;/span&gt;
                }
            ]
        }
    },
    {
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;apiVersion&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;2015-06-15&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Microsoft.Network/loadBalancers/inboundNatRules&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;copy&amp;#34;&lt;/span&gt;: {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;lbRdpNatLoop&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;count&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[variables(&amp;#39;selectedDeployment&amp;#39;).instancesCount]&amp;#34;&lt;/span&gt;
        },
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[concat(&amp;#39;/loadbalancer/&amp;#39;,&amp;#39;VM-&amp;#39;, copyIndex(1),&amp;#39;-RDP&amp;#39;)]&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;location&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[resourceGroup().location]&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;dependsOn&amp;#34;&lt;/span&gt;: [
            &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[concat(&amp;#39;Microsoft.Network/loadBalancers/loadBalancer&amp;#39;)]&amp;#34;&lt;/span&gt;
        ],
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;properties&amp;#34;&lt;/span&gt;: {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;frontendIPConfiguration&amp;#34;&lt;/span&gt;: {
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;id&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[resourceId(&amp;#39;Microsoft.Network/loadBalancers/frontendIPConfigurations&amp;#39;,&amp;#39;loadBalancer&amp;#39;,variables(&amp;#39;lbFrontend&amp;#39;))]&amp;#34;&lt;/span&gt;
            },
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;protocol&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;tcp&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;frontendPort&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[add(3389, copyIndex(1))]&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;backendPort&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;3389&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;enableFloatingIP&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;false&lt;/span&gt;
        }
    }
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In this updated resource collection, we have added three resource types. A public IP address to assign it to the load balancer, a load balancer that will act as a container for the VM endpoints, and finally, RDP endpoints based on the number of VM instances we need.&lt;/p&gt;
&lt;p&gt;Observe the highlighted lines in the resource collection. The copy object that we used within the inboundNATRules resource type tells ARM how many instances we need to create based on the VM count we need.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&amp;#34;copy&amp;#34;: {
    &amp;#34;name&amp;#34;: &amp;#34;lbRdpNatLoop&amp;#34;,
    &amp;#34;count&amp;#34;: &amp;#34;[variables(&amp;#39;selectedDeployment&amp;#39;).instancesCount]&amp;#34;
},
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Within an ARM template, for each resource type and its instances, the &lt;em&gt;name&lt;/em&gt; property should carry a unique value. Without this, you will see an error during deployment that multiple instances cannot use the same name. So, if you look at line number 77, we are dynamically constructing the value for &lt;em&gt;name.&lt;/em&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&amp;#34;name&amp;#34;: &amp;#34;[concat(&amp;#39;/loadbalancer/&amp;#39;,&amp;#39;VM-&amp;#39;, copyIndex(1),&amp;#39;-RDP&amp;#39;)]&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As you see here, we are concatenating ‘/loadbalancer/’ with ‘VM-‘ and then using the &lt;a href=&#34;https://azure.microsoft.com/en-us/documentation/articles/resource-group-template-functions/#copyindex&#34;&gt;&lt;em&gt;copyIndex()&lt;/em&gt;&lt;/a&gt; function and finally add ‘-RDP’. The &lt;em&gt;copyIndex()&lt;/em&gt; function gives us the iteration number. So, if we are creating three VM endpoints within this resource definition, we get iteration values 0, 1, and 2. The index always starts from 0. However, if we want to offset it to different value than zero, we can specify the value inside the &lt;em&gt;copyIndex()&lt;/em&gt; function. In my example, I am using 1 so that the values the template receives will be 1, 2, and 3. Since we are using the iteration number within the name value, we always get an unique identifier.&lt;/p&gt;
&lt;p&gt;Another function that we are using within this template update is the &lt;em&gt;&lt;a href=&#34;https://azure.microsoft.com/en-us/documentation/articles/resource-group-template-functions/#add&#34;&gt;add()&lt;/a&gt;&lt;/em&gt; function. This function, as its name suggests, adds integers. I am using this function to dynamically derive the frontend port number for the VM RDP endpoint.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&amp;#34;frontendPort&amp;#34;: &amp;#34;[add(3389, copyIndex(1))]&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;We are doing this since all VM RDP endpoints should be accessible through the load balancer. By using add function, we are adding the iteration value to the RDP port (3389) to derive a unique value.&lt;/p&gt;
&lt;p&gt;Now that we have completed our discussion on the copy object and its usage, let us move on to see the ARM template update that creates storage account, virtual network, public IP, load balancer, and finally the VM RDP endpoints. We are not creating an RDP endpoint for the DC VM.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;{
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;$schema&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;https://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;contentVersion&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;1.0.0.0&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;parameters&amp;#34;&lt;/span&gt;: {
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;storageAccountName&amp;#34;&lt;/span&gt;: {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;string&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;metadata&amp;#34;&lt;/span&gt;: {
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;description&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Unique name for the storage account.&amp;#34;&lt;/span&gt;
            }
        },
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;storageAccountType&amp;#34;&lt;/span&gt;: {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;string&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;defaultValue&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Standard_LRS&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;allowedValues&amp;#34;&lt;/span&gt;: [
                &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Standard_LRS&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Standard_GRS&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Standard_ZRS&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Premium_LRS&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Standard_RAGRS&amp;#34;&lt;/span&gt;
            ],
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;metadata&amp;#34;&lt;/span&gt;: {
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;description&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Account type based on the storage redundancy requirements.&amp;#34;&lt;/span&gt;
            }
        },
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;vNetName&amp;#34;&lt;/span&gt;: {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;string&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;metadata&amp;#34;&lt;/span&gt;: {
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;description&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Name for the virtual network.&amp;#34;&lt;/span&gt;
            }
        },
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;DnsName&amp;#34;&lt;/span&gt;: {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;string&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;metadata&amp;#34;&lt;/span&gt;: {
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;description&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Unique public DNS prefix for the deployment. The fqdn will look something like &amp;#39;&amp;amp;lt;dnsname&amp;amp;gt;.westus.cloudapp.azure.com&amp;#39;.&amp;#34;&lt;/span&gt;
            }
        },
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;environmentType&amp;#34;&lt;/span&gt;: {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;string&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;allowedValues&amp;#34;&lt;/span&gt;: [
                &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Development&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Test&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Production&amp;#34;&lt;/span&gt;
            ],
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;defaultValue&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Development&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;metadata&amp;#34;&lt;/span&gt;: {
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;description&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Type of environment where this deployment should occur. This has an impact on the number of VMs to be depoloyed.&amp;#34;&lt;/span&gt;
            }
        }
    },
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;variables&amp;#34;&lt;/span&gt;: {
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;vNetPrefix&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;10.0.0.0/16&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;vNetSubnet1Name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[concat(resourceGroup().Location, &amp;#39;-&amp;#39;, parameters(&amp;#39;vNetName&amp;#39;), &amp;#39;-&amp;#39;, &amp;#39;Subnet&amp;#39;)]&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;vNetSubnet1Prefix&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;10.0.0.0/24&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;vNetSubnet1ID&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[concat(resourceId(&amp;#39;Microsoft.Network/virtualNetworks&amp;#39;,parameters(&amp;#39;vNetName&amp;#39;)),&amp;#39;/subnets/&amp;#39;,variables(&amp;#39;vNetSubnet1Name&amp;#39;))]&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;dnsServerPrivateIp&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;10.0.0.8&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;lbFrontend&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;lbFrontEnd&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;lbBackendAddrPool&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;lbBackEndPool&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;deploymentSize&amp;#34;&lt;/span&gt;: {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;Development&amp;#34;&lt;/span&gt;: {
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;instancesCount&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;
            },
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;Test&amp;#34;&lt;/span&gt;: {
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;instancesCount&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;
            },
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;Production&amp;#34;&lt;/span&gt;: {
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;instancesCount&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;3&lt;/span&gt;
            }
        },
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;selectedDeployment&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[variables(&amp;#39;deploymentSize&amp;#39;)[parameters(&amp;#39;environmentType&amp;#39;)]]&amp;#34;&lt;/span&gt;
    },
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;resources&amp;#34;&lt;/span&gt;: [
        {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[parameters(&amp;#39;storageAccountName&amp;#39;)]&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Microsoft.Storage/storageAccounts&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;location&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[ResourceGroup().Location]&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;apiVersion&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;2015-05-01-preview&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;properties&amp;#34;&lt;/span&gt;: {
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;accountType&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[parameters(&amp;#39;storageAccountType&amp;#39;)]&amp;#34;&lt;/span&gt;
            }
        },
        {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[parameters(&amp;#39;vNetName&amp;#39;)]&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Microsoft.Network/virtualNetworks&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;location&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[ResourceGroup().Location]&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;apiVersion&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;2015-05-01-preview&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;properties&amp;#34;&lt;/span&gt;: {
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;addressSpace&amp;#34;&lt;/span&gt;: {
                    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;addressPrefixes&amp;#34;&lt;/span&gt;: [
                        &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[variables(&amp;#39;vNetPrefix&amp;#39;)]&amp;#34;&lt;/span&gt;
                    ]
                },
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;subnets&amp;#34;&lt;/span&gt;: [
                    {
                        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[variables(&amp;#39;vNetSubnet1Name&amp;#39;)]&amp;#34;&lt;/span&gt;,
                        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;properties&amp;#34;&lt;/span&gt;: {
                            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;addressPrefix&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[variables(&amp;#39;vNetSubnet1Prefix&amp;#39;)]&amp;#34;&lt;/span&gt;
                        }
                    }
                ]
            }
        },
        {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;apiVersion&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;2015-05-01-preview&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Microsoft.Network/publicIPAddresses&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;publicIp&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;location&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[resourceGroup().location]&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;properties&amp;#34;&lt;/span&gt;: {
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;publicIPAllocationMethod&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Dynamic&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;dnsSettings&amp;#34;&lt;/span&gt;: {
                    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;domainNameLabel&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[parameters(&amp;#39;DnsName&amp;#39;)]&amp;#34;&lt;/span&gt;
                }
            }
        },
        {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;apiVersion&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;2015-05-01-preview&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;loadBalancer&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Microsoft.Network/loadBalancers&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;location&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[resourceGroup().location]&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;dependsOn&amp;#34;&lt;/span&gt;: [
                &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Microsoft.Network/publicIPAddresses/publicIp&amp;#34;&lt;/span&gt;
            ],
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;properties&amp;#34;&lt;/span&gt;: {
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;frontendIPConfigurations&amp;#34;&lt;/span&gt;: [
                    {
                        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[variables(&amp;#39;lbFrontend&amp;#39;)]&amp;#34;&lt;/span&gt;,
                        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;properties&amp;#34;&lt;/span&gt;: {
                            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;publicIPAddress&amp;#34;&lt;/span&gt;: {
                                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;id&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[resourceId(&amp;#39;Microsoft.Network/publicIPAddresses&amp;#39;,&amp;#39;publicIp&amp;#39;)]&amp;#34;&lt;/span&gt;
                            }
                        }
                    }
                ],
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;backendAddressPools&amp;#34;&lt;/span&gt;: [
                    {
                        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[variables(&amp;#39;lbBackendAddrPool&amp;#39;)]&amp;#34;&lt;/span&gt;
                    }
                ]
            }
        },
        {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;apiVersion&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;2015-06-15&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Microsoft.Network/loadBalancers/inboundNatRules&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;copy&amp;#34;&lt;/span&gt;: {
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;lbRdpNatLoop&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;count&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[variables(&amp;#39;selectedDeployment&amp;#39;).instancesCount]&amp;#34;&lt;/span&gt;
            },
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[concat(&amp;#39;/loadbalancer/&amp;#39;,&amp;#39;VM-&amp;#39;, copyIndex(1),&amp;#39;-RDP&amp;#39;)]&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;location&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[resourceGroup().location]&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;dependsOn&amp;#34;&lt;/span&gt;: [
                &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[concat(&amp;#39;Microsoft.Network/loadBalancers/loadBalancer&amp;#39;)]&amp;#34;&lt;/span&gt;
            ],
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;properties&amp;#34;&lt;/span&gt;: {
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;frontendIPConfiguration&amp;#34;&lt;/span&gt;: {
                    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;id&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[resourceId(&amp;#39;Microsoft.Network/loadBalancers/frontendIPConfigurations&amp;#39;,&amp;#39;loadBalancer&amp;#39;,variables(&amp;#39;lbFrontend&amp;#39;))]&amp;#34;&lt;/span&gt;
                },
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;protocol&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;tcp&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;frontendPort&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[add(3389, copyIndex(1))]&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;backendPort&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;3389&lt;/span&gt;,
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;enableFloatingIP&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;false&lt;/span&gt;
            }
        }
    ]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;You can go ahead and deploy this update by clicking on the button below. &lt;/p&gt;

    &lt;a href=&#34;https://portal.azure.com/#create/Microsoft.Template/uri/https%3a%2f%2fportal.azure.com%2f%23create%2fMicrosoft.Template%2furi%2fhttps%253A%252F%252Fraw.githubusercontent.com%252Frchaganti%252Farmseries%252Fmaster%252Farm-series_Storage-VirtualNet-LB.json&#34; target=&#34;_blank&#34;&gt;
        &lt;img src=&#34;https://raw.githubusercontent.com/Azure/azure-quickstart-templates/master/1-CONTRIBUTION-GUIDE/images/deploytoazure.svg?sanitize=true&#34; alt=&#34;&#34;&gt;
    &lt;/a&gt;
    &lt;br /&gt;

&lt;figure&gt;
    &lt;img src=&#34;https://ravichaganti.com/images/armtemplate5-2.png&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;This brings up the portal and prompts for the parameter values we need for the deployment. Within the parameters, you will see the &lt;em&gt;environmentType&lt;/em&gt; dropdown with three possible values. I have selected Production as the input here and I expect to see three RDP endpoints created at the end of template deployment. Let us see if this worked.&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&#34;https://ravichaganti.com/images/armtemplate5-3.png&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;&lt;a href=&#34;http://139.59.40.198/blog/uploads/2015/11/RDPEndpoints.png&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;As you see here, the endpoints with respective frontend port numbers are created. We will have to associate these endpoints to VM network interfaces and we will take that up in a later part. Stay tuned.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Building Azure Resource Manager Templates – Using Variables</title>
      <link>https://ravichaganti.com/blog/building-azure-resource-manager-templates-using-variables/</link>
      <pubDate>Sun, 15 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ravichaganti.com/blog/building-azure-resource-manager-templates-using-variables/</guid>
      <description>&lt;p&gt;If you have been following this series on &lt;a href=&#34;http://139.59.40.198/blog/series/arm-templates/&#34;&gt;ARM templates&lt;/a&gt;, in the last part, we started with a sample scenario that we are using to build an ARM template. Here it is again.&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&#34;https://ravichaganti.com/images/armtemplate4-1.png&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;In the &lt;a href=&#34;http://139.59.40.198/blog/building-azure-resource-manager-templates-using-parameters/&#34;&gt;last part&lt;/a&gt;, we completed creation of storage account required for backing the OS and data disks for virtual machines in the deployment. The next step in our scenario is to create the virtual network for the VM connectivity. A virtual network and any subnets required must exist before the creation of virtual machines. So, in today’s article, we will see how we can use variables in the ARM template language while incrementally building an ARM template for our scenario and add virtual network. Towards the end, we will review some best practices guidance with regards to using parameters and variables in developing ARM templates.&lt;/p&gt;
&lt;h4 id=&#34;working-with-variables&#34;&gt;Working with Variables&lt;/h4&gt;
&lt;p&gt;Variables in ARM template language can be used to simplify the template. For example, in our template, we will be using the subnet name at multiple places. There is no point repeating the same string everywhere for this. This may also lead to human errors such as unintentional misspelling of the subnet name. This type of errors will result in failure during the deployment. Instead, we can assign subnet name as a value to a variable and refer that variable within the template as needed. Also, variables in ARM template language will let us expand or construct other variable values. We will see examples of this in the template.&lt;/p&gt;
&lt;p&gt;Here is the generic syntax for variables in ARM template language.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;variables&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f00&#34;&gt;:&lt;/span&gt; {
   &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;&amp;lt;variable-name&amp;gt;&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&amp;lt;variable-value&amp;gt;&amp;#34;&lt;/span&gt;,
   &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;&amp;lt;variable-name&amp;gt;&amp;#34;&lt;/span&gt;: { 
       &lt;span style=&#34;color:#f00&#34;&gt;&amp;lt;variable-complex-type-value&amp;gt;&lt;/span&gt; 
   }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In general, variables is a JSON object which contains pairs of variable names and values. The variable value can be a complex type such as another JSON object. We will see these as examples as we add the variables needed to complete virtual network configuration.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;variables&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f00&#34;&gt;:&lt;/span&gt; {
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;vNetPrefix&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;10.0.0.0/16&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;vNetSubnet1Name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[concat(resourceGroup().Location, &amp;#39;-&amp;#39;, parameters(&amp;#39;vNetName&amp;#39;), &amp;#39;-&amp;#39;, &amp;#39;Subnet&amp;#39;)]&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;vNetSubnet1Prefix&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;10.0.0.0/24&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;vNetSubnet1ID&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[concat(resourceId(&amp;#39;Microsoft.Network/virtualNetworks&amp;#39;,parameters(&amp;#39;vNetName&amp;#39;)),&amp;#39;/subnets/&amp;#39;,variables(&amp;#39;vNetSubnet1Name&amp;#39;))]&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;dnsServerPrivateIp&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;10.0.0.8&amp;#34;&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;For the virtual network required for our scenario, we defined a variable called &lt;em&gt;vNetPrefix&lt;/em&gt; and set a value “10.0.0.0/16”. This is the overall virtual network address scope. Within this vNet, we intend to create one subnet with address prefix “10.0.0.0/24” and this is represented using the variable _vNetSubnet1Prefix. _I have added another variable named &lt;em&gt;dnsServerPrivateIp&lt;/em&gt; to reserve an IP address for the AD domain controller VM. This is because we don’t want a DHCP assigned IP for the AD DC.&lt;/p&gt;
&lt;p&gt;You will also see that we are using another function within this variables element called &lt;em&gt;&lt;a href=&#34;https://azure.microsoft.com/en-in/documentation/articles/resource-group-template-functions/#concat&#34;&gt;concat()&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;vNetSubnet1Name&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f00&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[concat(resourceGroup().Location, &amp;#39;-&amp;#39;, parameters(&amp;#39;vNetName&amp;#39;), &amp;#39;-&amp;#39;, &amp;#39;Subnet&amp;#39;)]&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This function can take ‘n’ strings and concatenate them together. In the example above, we are retrieving the resource group location and then concatenate that with ‘-‘ and the value of the &lt;em&gt;vNetName&lt;/em&gt; parameter. This variable value is then used to derive the value of the variable &lt;em&gt;vNetSubnet1ID.&lt;/em&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;vNetSubnet1ID&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f00&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[concat(resourceId(&amp;#39;Microsoft.Network/virtualNetworks&amp;#39;,parameters(&amp;#39;vNetName&amp;#39;)),&amp;#39;/subnets/&amp;#39;,variables(&amp;#39;vNetSubnet1Name&amp;#39;))]&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As I’d mentioned earlier, variables values can be generated dynamically based on other values. If you observe the above code snippet, we are constructing the &lt;em&gt;vNetSubnet1ID&lt;/em&gt; by retrieving the resource ID for the virtual network that we are creating. The &lt;em&gt;resourceId()&lt;/em&gt; function returns the unique identifier of a resource and it won’t be available until the vNet is created. This shows us that the values of variables can be derived from other related configuration settings. We have used the &lt;em&gt;concat()&lt;/em&gt; function again here to concatenate the resource Id value of the vNet with ‘/subnets/’ and the value of the &lt;em&gt;vNetSubnet1Name&lt;/em&gt; variable that we derived in last step. Similar to &lt;em&gt;parameters()&lt;/em&gt; function, the &lt;em&gt;&lt;a href=&#34;https://azure.microsoft.com/en-in/documentation/articles/resource-group-authoring-templates/#variables&#34;&gt;variables()&lt;/a&gt;&lt;/em&gt; function gives us the value of the variable name specified.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&amp;#34;[variables(&amp;#39;vNetSubnet1Name&amp;#39;)]&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The &lt;em&gt;variables()&lt;/em&gt; function can be used with the variables element as well as the resource definitions and outputs element. Like any other expression in template language, anytime you want to use this function, it must be enclosed in square brackets ([]).&lt;/p&gt;
&lt;p&gt;We will see more about creating variables with complex value types in a later part but fundamentals that you learned here are applicable even to complex types. Now that we have the variables needed for the vNet creation, let us go ahead and add the virtual network resource definition to our template.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;{
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;$schema&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;https://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;contentVersion&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;1.0.0.0&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;parameters&amp;#34;&lt;/span&gt;: {
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;storageAccountName&amp;#34;&lt;/span&gt;: {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;string&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;defaultValue&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;MyARMDemo&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;minLength&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;3&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;maxLength&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;24&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;metadata&amp;#34;&lt;/span&gt;: {
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;description&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Unique name for the storage account.&amp;#34;&lt;/span&gt;
            }
        },
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;storageAccountType&amp;#34;&lt;/span&gt;: {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;string&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;defaultValue&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Standard_LRS&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;allowedValues&amp;#34;&lt;/span&gt;: [
                &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Standard_LRS&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Standard_GRS&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Standard_ZRS&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Premium_LRS&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Standard_RAGRS&amp;#34;&lt;/span&gt;
            ],
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;metadata&amp;#34;&lt;/span&gt;: {
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;description&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Account type based on the storage redundancy requirements.&amp;#34;&lt;/span&gt;
            }
        },
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;vNetName&amp;#34;&lt;/span&gt;: {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;string&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;defaultValue&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;myARMDemo&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;metadata&amp;#34;&lt;/span&gt;: {
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;description&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Unique name of the virtual network for this deployment&amp;#34;&lt;/span&gt;
            }
        }
    },
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;variables&amp;#34;&lt;/span&gt;: {
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;vNetPrefix&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;10.0.0.0/16&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;vNetSubnet1Name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[concat(resourceGroup().Location, &amp;#39;-&amp;#39;, parameters(&amp;#39;vNetName&amp;#39;), &amp;#39;-&amp;#39;, &amp;#39;Subnet&amp;#39;)]&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;vNetSubnet1Prefix&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;10.0.0.0/24&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;vNetSubnet1ID&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[concat(resourceId(&amp;#39;Microsoft.Network/virtualNetworks&amp;#39;,parameters(&amp;#39;vNetName&amp;#39;)),&amp;#39;/subnets/&amp;#39;,variables(&amp;#39;vNetSubnet1Name&amp;#39;))]&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;dnsServerPrivateIp&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;10.0.0.8&amp;#34;&lt;/span&gt;
    },
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;resources&amp;#34;&lt;/span&gt;: [
        {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[parameters(&amp;#39;storageAccountName&amp;#39;)]&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Microsoft.Storage/storageAccounts&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;location&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[ResourceGroup().Location]&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;apiVersion&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;2015-05-01-preview&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;properties&amp;#34;&lt;/span&gt;: {
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;accountType&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[parameters(&amp;#39;storageAccountType&amp;#39;)]&amp;#34;&lt;/span&gt;
            }
        },
        {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[parameters(&amp;#39;vNetName&amp;#39;)]&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Microsoft.Network/virtualNetworks&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;location&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[ResourceGroup().Location]&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;apiVersion&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;2015-05-01-preview&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;properties&amp;#34;&lt;/span&gt;: {
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;addressSpace&amp;#34;&lt;/span&gt;: {
                    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;addressPrefixes&amp;#34;&lt;/span&gt;: [
                        &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[variables(&amp;#39;vNetPrefix&amp;#39;)]&amp;#34;&lt;/span&gt;
                    ]
                },
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;subnets&amp;#34;&lt;/span&gt;: [
                    {
                        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[variables(&amp;#39;vNetSubnet1Name&amp;#39;)]&amp;#34;&lt;/span&gt;,
                        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;properties&amp;#34;&lt;/span&gt;: {
                            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;addressPrefix&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[variables(&amp;#39;vNetSubnet1Prefix&amp;#39;)]&amp;#34;&lt;/span&gt;
                        }
                    }
                ]
            }
        }        
    ]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;I added a &lt;em&gt;vNetName&lt;/em&gt; parameter to the parameters element so that user deploying this template can provide that as input. We can go ahead and test if this is template is valid or not.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-powershell&#34; data-lang=&#34;powershell&#34;&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;Test-AzureRmResourceGroupDeployment&lt;/span&gt; -ResourceGroupName myARMDemo -TemplateFile .\arm-series_Storage-VirtualNet.json -storageAccountName myARMDemo -storageAccountType Standard_LRS -vNetName myARMDemo -Verbose
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Once the validation is complete, we can go ahead and deploy the same to ensure it is deploy-able. To test this immediately, click on the deploy to Azure button below.&lt;/p&gt;

    &lt;a href=&#34;https://portal.azure.com/#create/Microsoft.Template/uri/https%3a%2f%2fportal.azure.com%2f%23create%2fMicrosoft.Template%2furi%2fhttps%253A%252F%252Fraw.githubusercontent.com%252Frchaganti%252Farmseries%252Fmaster%252Farm-series_Storage-VirtualNet.json&#34; target=&#34;_blank&#34;&gt;
        &lt;img src=&#34;https://raw.githubusercontent.com/Azure/azure-quickstart-templates/master/1-CONTRIBUTION-GUIDE/images/deploytoazure.svg?sanitize=true&#34; alt=&#34;&#34;&gt;
    &lt;/a&gt;
    &lt;br /&gt;

&lt;h4 id=&#34;free-form-vs-known-configuration&#34;&gt;Free-form vs Known Configuration&lt;/h4&gt;
&lt;p&gt;We have so far looked at parameters, variables, and used them in the template that we are building. Parameters give us the flexibility to gather input from user deploying the template. We can completely parameterize the template and let the user provide every value needed for the deployment as an input parameter. This is called free-form configuration. However, using free-form configuration is not always scalable. The number of parameters that a user need to input might be overwhelming. Also, you don’t want your end user deploying this template to mess-up with the vNet and subnet address prefixes. This can have negative effects on the overall IaaS deployment. You might always want to prefix the subnet name with the resource group name to ensure there is uniformity across the resource names that you use. Some of this cannot be controlled unless you use known configurations. Known configurations help standardize resource configurations. Use variables in the template for resource settings that require no user input or you need control over. By using variables, you can simply change the value of the variable if at all you need to modify the template instead of trying to find where all the value is used.&lt;/p&gt;
&lt;p&gt;We will review more such best practices guidance and see using known configurations throughout this series. This is it for today. Stay tuned for more!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Building Azure Resource Manager Templates – Using Parameters</title>
      <link>https://ravichaganti.com/blog/building-azure-resource-manager-templates-using-parameters/</link>
      <pubDate>Tue, 10 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ravichaganti.com/blog/building-azure-resource-manager-templates-using-parameters/</guid>
      <description>&lt;p&gt;In the earlier parts of this &lt;a href=&#34;http://139.59.40.198/blog/series/arm-templates/&#34;&gt;series&lt;/a&gt;, we briefly looked at &lt;a href=&#34;http://139.59.40.198/blog/building-azure-resource-manager-templates-an-introduction/&#34;&gt;different methods of deploying ARM templates&lt;/a&gt; and then &lt;a href=&#34;http://139.59.40.198/blog/building-azure-resource-manager-templates-the-basics/&#34;&gt;basics of ARM template language&lt;/a&gt;. Starting today’s article, we will see our leaning in action. To get going with our leaning, we will start building the ARM template for the following scenario.&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&#34;https://ravichaganti.com/images/armtemplate3-1.png&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;We will incrementally build this scenario by learning different aspects of ARM template language. We won’t be covering all resource types in Azure but we will cover every aspect of the ARM template language and functions and expressions used in the template language. We will also review best practices in building these ARM templates as we proceed forward in this series.&lt;/p&gt;
&lt;p&gt;So, what is there in the scenario that we are building?&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;A resource group to host different resource types in our scenario.&lt;/li&gt;
&lt;li&gt;A storage account for hosting the VM OS and data disks.&lt;/li&gt;
&lt;li&gt;A virtual network for VM network connectivity.&lt;/li&gt;
&lt;li&gt;A public IP to connect to this deployment from external world.&lt;/li&gt;
&lt;li&gt;A load balancer that has the RDP and PowerShell remoting endpoints for the non-DC virtual machines in this scenario.&lt;/li&gt;
&lt;li&gt;Network interfaces for the AD DC and other VMs in our scenario.&lt;/li&gt;
&lt;li&gt;An Active Directory Domain Controller VM with DNS services running in it.&lt;/li&gt;
&lt;li&gt;Up to three VMs (depending on the environment type) that join the AD DS.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This scenario is not a complex deployment by any means but can be useful in building an ARM template that uses most or all of the artifacts in the template language. We will do this over a series of articles. But, at the end of each part, we will have a deploy-able template that we will test.&lt;/p&gt;
&lt;p&gt;Let us see how we can go about this.&lt;/p&gt;
&lt;h4 id=&#34;create-a-resource-group&#34;&gt;Create a Resource Group&lt;/h4&gt;
&lt;p&gt;Like I mentioned earlier, we need a resource group for deploying the components in our scenario using ARM templates. So, let us create one. You can do this using various means but I will stick to &lt;a href=&#34;https://github.com/Azure/azure-powershell/releases&#34;&gt;Azure PowerShell&lt;/a&gt; for this.&lt;/p&gt;
&lt;p&gt;Note: I will be using Azure PowerShell 1.0 cmdlets. You can get these using either PackageManagement cmdlets or Web PI or just get the &lt;!-- raw HTML omitted --&gt;MSI package from Github&lt;!-- raw HTML omitted --&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-powershell&#34; data-lang=&#34;powershell&#34;&gt;Login-AzureRmAccount
&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;New-AzureRmResourceGroup&lt;/span&gt; -Name MyARMDemo -Location &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;West US&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Note: An Azure resource group can contain &lt;!-- raw HTML omitted --&gt;resources from different regions&lt;!-- raw HTML omitted --&gt;.&lt;/p&gt;
&lt;h4 id=&#34;adding-parameters&#34;&gt;Adding Parameters&lt;/h4&gt;
&lt;p&gt;Now that we have a resource group created, let us start creating our ARM template for the scenario. First thing we need is a storage account for our resources. Storage accounts in Azure have a couple of properties — &lt;em&gt;name, type,&lt;/em&gt; and &lt;em&gt;location&lt;/em&gt; — that we can configure. We should ideally collect the values for &lt;em&gt;name&lt;/em&gt; and &lt;em&gt;type&lt;/em&gt; from the user deploying this template. This is where we will use parameters in the ARM template language. Let us first start by defining that.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;{
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;$schema&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;https://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;contentVersion&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;1.0.0.0&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;parameters&amp;#34;&lt;/span&gt;: {
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;storageAccountName&amp;#34;&lt;/span&gt;: {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;string&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;defaultValue&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;myARMDemo&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;minLength&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;3&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;maxLength&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;24&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;metadata&amp;#34;&lt;/span&gt;: {
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;description&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Unique name for the storage account.&amp;#34;&lt;/span&gt;
            }
        },
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;storageAccountType&amp;#34;&lt;/span&gt;: {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;string&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;defaultValue&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Standard_LRS&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;allowedValues&amp;#34;&lt;/span&gt;: [
                &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Standard_LRS&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Standard_GRS&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Standard_ZRS&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Premium_LRS&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Standard_RAGRS&amp;#34;&lt;/span&gt;
            ],
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;metadata&amp;#34;&lt;/span&gt;: {
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;description&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Account type based on the storage redundancy requirements.&amp;#34;&lt;/span&gt;
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In the above JSON template, we added parameters sub-element to the first two mandatory elements which are &lt;em&gt;$schema&lt;/em&gt; and &lt;em&gt;contentVersion.&lt;/em&gt; Within the parameters element, we have two parameters needed for creating storage account. Here is the generic syntax for adding parameters.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;parameters&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f00&#34;&gt;:&lt;/span&gt; {
   &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;&amp;lt;parameterName&amp;gt;&amp;#34;&lt;/span&gt; : {
     &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt; : &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&amp;lt;type-of-parameter-value&amp;gt;&amp;#34;&lt;/span&gt;,
     &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;defaultValue&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&amp;lt;optional-default-value-of-parameter&amp;gt;&amp;#34;&lt;/span&gt;,
     &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;allowedValues&amp;#34;&lt;/span&gt;: [ &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&amp;lt;optional-array-of-allowed-values&amp;gt;&amp;#34;&lt;/span&gt; ],
     &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;minValue&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#f00&#34;&gt;&amp;lt;optional-minimum-value-for-int-parameters&amp;gt;&lt;/span&gt;,
     &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;maxValue&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#f00&#34;&gt;&amp;lt;optional-maximum-value-for-int-parameters&amp;gt;&lt;/span&gt;,
     &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;minLength&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#f00&#34;&gt;&amp;lt;optional-minimum-length-for-string-secureString-array-parameters&amp;gt;&lt;/span&gt;,
     &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;maxLength&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#f00&#34;&gt;&amp;lt;optional-maximum-length-for-string-secureString-array-parameters&amp;gt;&lt;/span&gt;,
     &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;metadata&amp;#34;&lt;/span&gt;: {
         &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;description&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&amp;lt;optional-description-of-the parameter&amp;gt;&amp;#34;&lt;/span&gt; 
     }
   }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;We will be using more or less every property within the parameters element within the scenario we are developing. So, don’t worry if you don’t immediately see all of them used right away. The &lt;em&gt;storageAccountName&lt;/em&gt; parameter is of string &lt;em&gt;type&lt;/em&gt; and we set the &lt;em&gt;defaultValue&lt;/em&gt; to ‘myARMDemo’. So, when a user deploys this template it is not mandatory to supply the parameter value. The value of &lt;em&gt;type&lt;/em&gt; property should be a valid JSON type and one of the below mentioned types.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;string or secureString&lt;/li&gt;
&lt;li&gt;int&lt;/li&gt;
&lt;li&gt;bool&lt;/li&gt;
&lt;li&gt;object or secureObject&lt;/li&gt;
&lt;li&gt;array&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A storage account name must be at least 3 characters long and 24 characters at the most. The &lt;em&gt;minLength&lt;/em&gt; and &lt;em&gt;maxLength&lt;/em&gt; properties within the &lt;em&gt;storageAccountName&lt;/em&gt; parameter define these constraints. The &lt;em&gt;metadata&lt;/em&gt; property of the parameter is used to provide the help text to the end user deploying this template. You can put whatever string that best describes the parameter.&lt;/p&gt;
&lt;p&gt;For the &lt;em&gt;storageAccountType&lt;/em&gt; property, we have set &lt;em&gt;allowedValues&lt;/em&gt; property to ensure we restrict what the end user can provide as a value. This is required since there only a set of valid values for the storage account type in Azure. Note that &lt;em&gt;allowedValues&lt;/em&gt; property is a JSON array and is represented using square brackets. Since we are supplying &lt;em&gt;allowedValues,&lt;/em&gt; when a user deploys this template, they get to select one of the values either using dropdown or tab-complete when using PowerShell. For eample, in Azure PowerShell, this is achieved using the &lt;em&gt;New-AzureRmResourceGroupDeployment&lt;/em&gt; cmdlet.&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&#34;https://ravichaganti.com/images/armtemplate3-2.png&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;We would eventually add many more parameters by the time we create the final template. The basics that we discussed here should apply to all parameters that we add in future.&lt;/p&gt;
&lt;h4 id=&#34;adding-resources&#34;&gt;Adding Resources&lt;/h4&gt;
&lt;p&gt;To be able to deploy the template, we must have at least one resource type added to the &lt;em&gt;resources&lt;/em&gt; collection element. Let us go ahead and add the storage resource type to create a storage account.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;{
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;$schema&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;https://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;contentVersion&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;1.0.0.0&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;parameters&amp;#34;&lt;/span&gt;: {
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;storageAccountName&amp;#34;&lt;/span&gt;: {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;string&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;defaultValue&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;MyARMDemo&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;minLength&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;3&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;maxLength&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;24&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;metadata&amp;#34;&lt;/span&gt;: {
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;description&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Unique name for the storage account.&amp;#34;&lt;/span&gt;
            }
        },
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;storageAccountType&amp;#34;&lt;/span&gt;: {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;string&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;defaultValue&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Standard_LRS&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;allowedValues&amp;#34;&lt;/span&gt;: [
                &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Standard_LRS&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Standard_GRS&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Standard_ZRS&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Premium_LRS&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Standard_RAGRS&amp;#34;&lt;/span&gt;
            ],
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;metadata&amp;#34;&lt;/span&gt;: {
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;description&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Account type based on the storage redundancy requirements.&amp;#34;&lt;/span&gt;
            }
        }
    },
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;resources&amp;#34;&lt;/span&gt;: [
        {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[parameters(&amp;#39;storageAccountName&amp;#39;)]&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Microsoft.Storage/storageAccounts&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;location&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[ResourceGroup().Location]&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;apiVersion&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;2015-05-01-preview&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;properties&amp;#34;&lt;/span&gt;: {
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;accountType&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[parameters(&amp;#39;storageAccountType&amp;#39;)]&amp;#34;&lt;/span&gt;
            }
        }        
    ]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As we learned earlier, resources element in the ARM template is a JSON array. It is a collection of comma-separated JSON objects where each JSON object represents an instance of a resource type. For a resource type, we need to configure the &lt;em&gt;name&lt;/em&gt; property to identify the resource instance within the group. Note the way we are retrieving the value of &lt;em&gt;storageAccountName&lt;/em&gt; parameter and assigning it to the &lt;em&gt;name&lt;/em&gt; property of storage account resource. We use the &lt;a href=&#34;https://azure.microsoft.com/en-in/documentation/articles/resource-group-template-functions/#parameters&#34;&gt;&lt;em&gt;parameters()&lt;/em&gt;&lt;/a&gt; function. We supply the name of the parameter to this function to retrieve its value. Also note that the functions and expressions within the JSON syntax must be enclosed within square brackets.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&amp;#34;name&amp;#34;: &amp;#34;[parameters(&amp;#39;storageAccountName&amp;#39;)]&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The &lt;em&gt;type&lt;/em&gt; property is used to define the resource provider (Microsoft.Storage) and resource type (storageAccounts) within the provider. The value of &lt;em&gt;location&lt;/em&gt; property identifies the region where we want to deploy the resource type. In the case of our ARM template, we are using the &lt;em&gt;&lt;a href=&#34;https://azure.microsoft.com/en-in/documentation/articles/resource-group-template-functions/#resourcegroup&#34;&gt;resourceGroup()&lt;/a&gt;&lt;/em&gt; function to define the location for our storage account. This function returns three attributes — &lt;em&gt;id, name,&lt;/em&gt; and &lt;em&gt;location&lt;/em&gt; — for the resource group within which the resource type is getting deployed. We use dot-reference to retrieve the value of location attribute.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&amp;#34;location&amp;#34;: &amp;#34;[ResourceGroup().Location]&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The properties element within the resource definition is a JSON object that identifies all the resource specific properties. We need to configure the storage account type setting and this is collected using the &lt;em&gt;storageAccountType&lt;/em&gt; parameter. Similar to how we assigned value to the &lt;em&gt;name&lt;/em&gt; property, we use the &lt;em&gt;parameters()&lt;/em&gt; function to get the value of &lt;em&gt;storageAccountType.&lt;/em&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;{
   &amp;#34;accountType&amp;#34;: &amp;#34;[parameters(&amp;#39;storageAccountType&amp;#39;)]&amp;#34;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;With this, we have a ARM template that can be used to deploy a storage account. But, how do we know whether this is valid or not. We can either use the &lt;a href=&#34;https://msdn.microsoft.com/en-us/library/azure/dn790547.aspx&#34;&gt;REST API&lt;/a&gt; for this or PowerShell cmdlets.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Once we validate the template, we can use one of the methods we discussed in the beginning of this series to deploy this template. One of the methods we discussed is the click to deploy button. So, go ahead and click on the below button and proceed to the Azure Portal (you need a valid Azure subscription).&lt;/p&gt;

    &lt;a href=&#34;https://portal.azure.com/#create/Microsoft.Template/uri/https%3a%2f%2fportal.azure.com%2f%23create%2fMicrosoft.Template%2furi%2fhttps%253A%252F%252Fraw.githubusercontent.com%252Frchaganti%252Farmseries%252Fmaster%252Farm-series_Storage.json&#34; target=&#34;_blank&#34;&gt;
        &lt;img src=&#34;https://raw.githubusercontent.com/Azure/azure-quickstart-templates/master/1-CONTRIBUTION-GUIDE/images/deploytoazure.svg?sanitize=true&#34; alt=&#34;&#34;&gt;
    &lt;/a&gt;
    &lt;br /&gt;

&lt;p&gt;You should see Azure Portal starting a new deployment and prompting you for parameter values.&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&#34;https://ravichaganti.com/images/armtemplate3-3.png&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;if you mouse over the small ‘i’ icon next to the parameter name, you will see the contents of the &lt;em&gt;metadata&lt;/em&gt; property for the parameter displayed in a tooltip.&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&#34;https://ravichaganti.com/images/armtemplate3-4.png&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;Once you fill in all required values in the wizard and click Create, the storage account gets deployed within the resource group.&lt;/p&gt;
&lt;p&gt;This is it. We have completed the first part of the ARM template development. In the next part, we will add some more resource types to the template and also learn some more artifacts in the ARM template language.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Slides: Future Unleashed – Authoring ARM Templates</title>
      <link>https://ravichaganti.com/blog/slides-from-future-unleashed-2015-authoring-azure-resource-manager-templates/</link>
      <pubDate>Mon, 09 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ravichaganti.com/blog/slides-from-future-unleashed-2015-authoring-azure-resource-manager-templates/</guid>
      <description>&lt;figure&gt;
    &lt;img src=&#34;https://ravichaganti.com/images/futureunleashed.jpg&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;I had a great time at Future Unleashed 2015 talking about &lt;a href=&#34;http://139.59.40.198/blog/authoring-azure-resource-manager-templates-microsoft-future-unleashed-2015-futureunleased/&#34;&gt;Authoring Azure Resource Manager Templates. &lt;/a&gt;This was a one-day technical event where there were 11 tracks covering different aspects from Cloud to Data to Analytics.&lt;/p&gt;
&lt;p&gt;The breakout session setup was a little weird. There were no walls for the breakout session room (or whatever you call it). It was just a big expo hall with 11 tracks spread across like exhibitor booths. All the attendees had to wear a headset to hear the speaker.&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&#34;https://ravichaganti.com/images/futureunleashed-stage.jpg&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;This is where my session had happened. It took a few mins for me get adjusted to this but overall, it was a very good experience. My session was very interactive and the attendees showed lot of interest in learning how to build ARM templates. I used a step-by-step approach in my demo to show the ARM template authoring and discussed how to use some artifacts in the ARM template language. A 45-minutes session is certainly not enough to show everything but I certainly hope that my attendees got a good overview of the authoring process.&lt;/p&gt;

    &lt;iframe
        src=&#34;//www.slideshare.net/slideshow/embed_code/key/tpPQ7wyyll44Q9&#34;
        title=&#34;SlideShare Presentation&#34;
        height=&#34;400&#34;
        frameborder=&#34;0&#34;
        marginwidth=&#34;0&#34;
        marginheight=&#34;0&#34;
        scrolling=&#34;no&#34;
        style=&#34;border: 1px solid #CCC; border-width: 1px; margin-bottom: 20px; width: 100%;&#34;
        allowfullscreen=&#34;true&#34;&gt;
    &lt;/iframe&gt;

&lt;p&gt;At some point, this month, we should have the session recording available too. I will post the demo scripts along with the session recording. Meanwhile, if you are looking for some in-depth content around learning ARM template authoring, take a look at &lt;a href=&#34;http://139.59.40.198/blog/series/arm-templates/&#34;&gt;my ARM template series&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Building Azure Resource Manager Templates – The Basics</title>
      <link>https://ravichaganti.com/blog/building-azure-resource-manager-templates-the-basics/</link>
      <pubDate>Fri, 06 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ravichaganti.com/blog/building-azure-resource-manager-templates-the-basics/</guid>
      <description>&lt;p&gt;As a part of this series, we will go through the language semantics of writing ARM templates. We will explore each and every aspect of the ARM template language and go through multiple examples to understand the concepts better. We won’t focus much on the resource types and resource definitions until we complete the discussion around the language semantics and artifacts.&lt;/p&gt;
&lt;p&gt;Let us get started.&lt;/p&gt;
&lt;h4 id=&#34;tools-for-the-job&#34;&gt;Tools for the job&lt;/h4&gt;
&lt;p&gt;JSON templates for ARM can be edited in notepad too. But, there are better tools that can help us with this.&lt;/p&gt;
&lt;h5 id=&#34;visual-studio&#34;&gt;Visual Studio&lt;/h5&gt;
&lt;p&gt;Visual Studio, along with &lt;a href=&#34;https://azure.microsoft.com/en-us/downloads/&#34;&gt;Azure SDK&lt;/a&gt;, provides an easy way to get started with the template creation. You get started by creating a Resource Group project and just keep adding resources to the project and VS automatically generates the JSON for you. You can then customize it the way you want. More than the auto-generation of JSON, what I like is the intellisense capability that shows me the properties I can use within a template for a resource type.&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&#34;https://ravichaganti.com/images/armtemplate2-1.png&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;For more information on how to get started with using &lt;a href=&#34;https://azure.microsoft.com/en-us/blog/azure-resource-manager-2-5-for-visual-studio/&#34;&gt;Visual Studio to create ARM templates&lt;/a&gt;, read this &lt;a href=&#34;https://azure.microsoft.com/en-us/blog/azure-resource-manager-2-5-for-visual-studio/&#34;&gt;Azure team blog post&lt;/a&gt;.&lt;/p&gt;
&lt;h5 id=&#34;visual-studio-code&#34;&gt;Visual Studio Code&lt;/h5&gt;
&lt;p&gt;Visual Studio Code is my favorite. It loads up much faster than the full-blown Visual Studio and it is very easy to use. However, at the time of this writing, there is no ARM template authoring support like what VS has. However, it has some minimal auto-completion support based on what the editor understands from the schema.&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&#34;https://ravichaganti.com/images/armtemplate2-2.png&#34;/&gt; 
&lt;/figure&gt;

&lt;h5 id=&#34;sublime-text&#34;&gt;Sublime Text&lt;/h5&gt;
&lt;p&gt;Sublime Text has a &lt;a href=&#34;https://packagecontrol.io/packages/AzureResourceManager&#34;&gt;Azure Resource Manager package&lt;/a&gt; that gives a bunch of snippets for quick ARM template authoring. For example, after you activate ARM package, you can type &lt;em&gt;arm:t&lt;/em&gt; and press tab to add a skeleton of the ARM template.&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&#34;https://ravichaganti.com/images/armtemplate2-3.png&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;Sublime does provide some level of property auto-completion but it is still buggy. But, if your first choice is sublime, you have ARM template authoring support to some extent.&lt;/p&gt;
&lt;p&gt;There may be many other editors or IDEs with JSON support. Visual Studio is the first-class citizen as far as ARM template support is concerned and I hope VS code gets a similar level of template authoring support soon. Now that we know what we need to start template authoring, let us start with the language discussion.&lt;/p&gt;
&lt;h4 id=&#34;introducing-arm-template-language&#34;&gt;Introducing ARM template language&lt;/h4&gt;
&lt;p&gt;I have mentioned this several times already but will say it one more time before I start. ARM templates are based on JSON syntax. So, to be able to appreciate and understand the way we write ARM templates, you need to know how JSON synatx works. I am not going to write about the JSON syntax here but I have an article that I &lt;a href=&#34;http://www.powershellmagazine.com/2014/12/01/a-json-primer-for-administrators/&#34;&gt;published on PowerShell Magazine and that should give you a good overview&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Here is the basic structure of an ARM template.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;{
   &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;$schema&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;http://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#&amp;#34;&lt;/span&gt;,
   &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;contentVersion&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;,
   &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;parameters&amp;#34;&lt;/span&gt;: {  },
   &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;variables&amp;#34;&lt;/span&gt;: {  },
   &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;resources&amp;#34;&lt;/span&gt;: [  ],
   &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;outputs&amp;#34;&lt;/span&gt;: {  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;schema&#34;&gt;$schema&lt;/h5&gt;
&lt;p&gt;This element is mandatory and the value must be the location of JSON schema file for the ARM template language. The JSON schema is what is used to find the right set of properties for resources etc. You can find the latest schema URL listed at &lt;a href=&#34;https://github.com/Azure/azure-resource-manager-schemas/&#34;&gt;https://github.com/Azure/azure-resource-manager-schemas/&lt;/a&gt;. When you start a new resource group project using Visual Studio, this property gets filled for you.&lt;/p&gt;
&lt;h5 id=&#34;contentversion&#34;&gt;ContentVersion&lt;/h5&gt;
&lt;p&gt;This is another mandatory element and you can use this to specify the version of the template you are authoring. As a part of the ARM authoring process, I suggest that you use the source control and build process to auto-update this element value instead of manually entering a version number.&lt;/p&gt;
&lt;h5 id=&#34;parameters&#34;&gt;Parameters&lt;/h5&gt;
&lt;p&gt;Think of parameters like parameters in any other programming language. In any programming language, parameters are used to provide flexibility within the function/method and not hard code any values that are really user-specific. ARM parameters are no exception. By defining parameters, you get the capability to collect user input for resource properties prior to starting the deployment.Parameters are what we use to draw a line between the free-form and known configurations. We will discuss this in-depth later. There are several properties within the parameters element. These properties can be used to set the allowed values or default value for a parameter or even set the minimum and maximum values for a parameter. Instead of just describing what those are, we will see real examples with those properties in the upcoming parts of this series.&lt;/p&gt;
&lt;h5 id=&#34;variables&#34;&gt;Variables&lt;/h5&gt;
&lt;p&gt;Variables, once again like any other programming language, helps us simplify the template language. For example, you can use variables element to store values for different resource properties and re-use them wherever applicable instead of writing the same value again and again. Also, within the ARM template language, variables can be used to construct values at runtime. You can use the user provided input in terms of parameters and construct the value for a specific resource property. Variables in ARM template can have standard type values as well as complex types. We will see examples of all this as we move forward in this series.&lt;/p&gt;
&lt;h5 id=&#34;resources&#34;&gt;Resources&lt;/h5&gt;
&lt;p&gt;Resource is a mandatory element and defines a collection of resources that you plan to deploy as a part of the template deployment. For each resource type that you define within this collection, there are certain standard sub-elements such as name, type, apiVersion, location, properties and so on. The properties element is used to describe the resource specific properties and the valid values for this are dependent on the resource type. Within this series, we will see a different set of resource types and use them within the templates that we build. However, we will not get into the details of each and every template. You can always refer to JSON schema and online documentation to find more about the properties for any given resource type.&lt;/p&gt;
&lt;h5 id=&#34;outputs&#34;&gt;Outputs&lt;/h5&gt;
&lt;p&gt;The outputs element is used to return data and objects from a deployment. For example, once a web application deployment is complete, you may want to return the URL at which the application is hosted. Also, outputs element is what we use to share state and data between multiple templates in a nested template deployment.&lt;/p&gt;
&lt;h4 id=&#34;functions-and-expressions&#34;&gt;Functions and Expressions&lt;/h4&gt;
&lt;p&gt;Apart from the six elements I described above, the ARM template syntax provides support for different &lt;a href=&#34;https://azure.microsoft.com/en-in/documentation/articles/resource-group-authoring-templates/#expressions-and-functions&#34;&gt;functions and expressions&lt;/a&gt; to simplify the deployment. For example, when you want to construct resource property values at runtime, you may need support for concatenating strings. As a part of our exploration here, we will look different functions and expressions that we can use within the ARM templates.&lt;/p&gt;
&lt;p&gt;This brings us to the end of today’s article. In the remaining parts going forward, we will take an example scenario and start building a template for that. In the process of doing that, we will see how different elements and artifacts such as functions and expressions within the template can be used. Before we start with that, I recommend that you get yourself familiarized with a tool that can be used to build these templates. Stay tuned for more.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Building Azure Resource Manager Templates – An Introduction</title>
      <link>https://ravichaganti.com/blog/building-azure-resource-manager-templates-an-introduction/</link>
      <pubDate>Mon, 02 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ravichaganti.com/blog/building-azure-resource-manager-templates-an-introduction/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://azure.microsoft.com/en-in/documentation/articles/resource-group-overview/&#34;&gt;Azure Resource Manager&lt;/a&gt; isn’t a new thing! It was announced during &lt;a href=&#34;https://channel9.msdn.com/Events/TechEd/NorthAmerica/2014/DEV-B224&#34;&gt;Build 2014&lt;/a&gt;. ARM is certainly the preferred way, with more and more services getting ARM support, to deploy Azure services. Microsoft also announced that the upcoming &lt;a href=&#34;https://www.youtube.com/watch?v=fuAmcfmo3X0&#34;&gt;Azure Stack release&lt;/a&gt; will feature Azure Resource Manager and the template deployment. This means that learning how to use ARM and write you own templates is an essential skill not just for public cloud but also for the private and hybrid cloud administrators.&lt;/p&gt;
&lt;p&gt;There is lot of Microsoft and community content out there that describes why ARM is important and how you can use the templates to deploy multi-tier and multi-service cloud deployments and manage all of them as a single entity. I am not going to repeat all that here. My focus, here, will be a thorough coverage of template language and design patterns. Through this series, you will get a complete and in-depth coverage of what you need to know to build world-class ARM templates. ARM uses &lt;a href=&#34;http://json.org/&#34;&gt;JSON formatted&lt;/a&gt; templates to perform these cloud deployments. You can see a bunch of these sample templates in the &lt;a href=&#34;https://github.com/Azure/azure-quickstart-templates&#34;&gt;Azure quick start templates Github repo&lt;/a&gt; that you can use as a starting point to create your own template or understand how to use the template language and best practices. This series of posts is about sharing my learning – the way I learned authoring ARM templates.&lt;/p&gt;
&lt;p&gt;Before you we go ahead start our discussion of ARM template language, let us first quickly review different methods of deploying these templates. This is not a detailed walk-through of these different methods since the focus of this article series is not on the deployment but building templates. After you write a custom ARM template, you can choose between any of these methods to deploy those templates.&lt;/p&gt;
&lt;h4 id=&#34;new-template-deployment-preview-portal&#34;&gt;New Template Deployment (Preview Portal)&lt;/h4&gt;
&lt;p&gt;The Azure Preview portal has an option to supply the ARM template contents (JSON) and then use a wizard-based method to start the deployment.&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&#34;https://ravichaganti.com/images/armtemplate1-1.png&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;To start this, as shown in the picture, click on the &lt;em&gt;+ icon&lt;/em&gt; and scroll down to click on &lt;em&gt;Template Deployment&lt;/em&gt;. The wizard that starts after this pretty much self-explanatory. As with any GUI and click-here methods, this is a manual method. I do not prefer this method.&lt;/p&gt;
&lt;h4 id=&#34;azure-powershell&#34;&gt;Azure PowerShell&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/Azure/azure-powershell/releases&#34;&gt;Azure PowerShell&lt;/a&gt; (the following example uses 1.0 preview) is my preferred option. You can just supply a template file and template parameter file to the &lt;em&gt;New-AzureRmResourceGroupDeployment&lt;/em&gt; cmdlet.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-powershell&#34; data-lang=&#34;powershell&#34;&gt;Login-AzureRmAccount
&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;New-AzureRmResourceGroup&lt;/span&gt; -Name ExampleResourceGroup -Location &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;West US&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;New-AzureRmResourceGroupDeployment&lt;/span&gt; -Name ExampleDeployment -ResourceGroupName ExampleResourceGroup -TemplateFile C:\ARMTemplates\SingleVMDeploy.json -TemplateParameterFile C:\ARMTemplates\SingleVMDeploy-parameter.json
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This method, like any other PowerShell-based method, can be completely automated and can be made a part of your CI/CD pipeline.&lt;/p&gt;
&lt;p&gt;If you prefer, you can do the same with &lt;a href=&#34;https://github.com/Azure/azure-xplat-cli/releases&#34;&gt;Azure CLI&lt;/a&gt; as well.&lt;/p&gt;
&lt;h4 id=&#34;arm-rest-api&#34;&gt;ARM REST API&lt;/h4&gt;
&lt;p&gt;The &lt;a href=&#34;https://msdn.microsoft.com/en-in/library/azure/dn790549.aspx&#34;&gt;template deployment API in the ARM REST API&lt;/a&gt; provides a way to deploy custom ARM templates programatically using any language that supports REST interfaces. For example, you can use the following API request to create a template deployment. You can supply the JSON template along with all parameter information in the same request or as a link to a blob in your storage account.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://management.azure.com/subscriptions/%7Bsubscription-id%7D/resourcegroups/%7Bresource-group-name%7D/providers/microsoft.resources/deployments/%7Bdeployment-name%7D?api-version=%7Bapi-version%7D&#34;&gt;https://management.azure.com/subscriptions/{subscription-id}/resourcegroups/{resource-group-name}/providers/microsoft.resources/deployments/{deployment-name}?api-version={api-version}&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;This method, like the Azure PowerShell or CLI method, can be easily integrated into an existing CI/CD pipeline.&lt;/p&gt;
&lt;h4 id=&#34;click-to-deploy-method&#34;&gt;Click to Deploy Method&lt;/h4&gt;
&lt;p&gt;Finally, there is a click to deploy method that Azure Preview portal gets integrated into. For example, most or all of the sample templates within the Azure quick start templates gallery contain the &lt;a href=&#34;https://azure.microsoft.com/en-us/blog/deploy-to-azure-button-for-azure-websites-2/&#34;&gt;Deploy to Azure button&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Clicking on the above button will take you to the new template deployment option in the preview portal where you can add the parameter values and start the deployment. Similar to this, you can embed these buttons on any webpage and redirect the user to Azure Preview portal to start the deployment.&lt;/p&gt;
&lt;h4 id=&#34;visual-studio&#34;&gt;Visual Studio&lt;/h4&gt;
&lt;p&gt;For developers creating ARM custom templates, it might be an easier option to both author and test deployment using &lt;a href=&#34;https://azure.microsoft.com/en-in/documentation/articles/arm-template-deployment/#step-2-create-the-visual-studio-project-the-template-file-and-the-parameters-file&#34;&gt;Visual Studio&lt;/a&gt;. VS provides necessary tooling to do this. VS provides the options to add new resources through a wizard and then later use the VS editor to customize and deploy those templates. Note that VS does not have all the resource types available in the wizard interface. For some of these missing resource types, you might still have to refer to the &lt;a href=&#34;https://github.com/Azure/azure-resource-manager-schemas&#34;&gt;schema and resource definitions&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;VS is my preferred (and only option at the moment) to start ARM template development. So, in this series, going forward, we will use VS for most of our scenarios but do the deployments using Azure PowerShell.&lt;/p&gt;
&lt;p&gt;This brings us to the end of today’s article. We have not yet seen any basics of authoring Azure Resource Manager templates. We will start discussing the basics and go in-depth starting the next part in this series. Before that, familiarize yourself with at least one of the custom template deployment methods.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Slides: Reboot Camp Bangalore - Cloud Computing for IT Professionals</title>
      <link>https://ravichaganti.com/blog/slides-from-reboot-camp-bangalore-keynote-cloud-computing-for-it-professionals/</link>
      <pubDate>Sat, 31 Jan 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ravichaganti.com/blog/slides-from-reboot-camp-bangalore-keynote-cloud-computing-for-it-professionals/</guid>
      <description>&lt;p&gt;I had the opportunity to do the keynote at the &lt;a href=&#34;http://rebootblr.azurewebsites.net/&#34;&gt;Microsoft Reboot Camp Bangalore&lt;/a&gt;. This is a community driven event with support from Microsoft. The theme for the event was cloud computing and Microsoft Cloud offerings.&lt;/p&gt;
&lt;p&gt;In my keynote, I talked about what cloud computing means to the IT professionals and how they should get ready for the future.&lt;/p&gt;
&lt;p&gt;Here are the slides from my keynote.&lt;/p&gt;

    &lt;iframe
        src=&#34;//www.slideshare.net/slideshow/embed_code/key/w4XP9qWqOyvpZP&#34;
        title=&#34;SlideShare Presentation&#34;
        height=&#34;400&#34;
        frameborder=&#34;0&#34;
        marginwidth=&#34;0&#34;
        marginheight=&#34;0&#34;
        scrolling=&#34;no&#34;
        style=&#34;border: 1px solid #CCC; border-width: 1px; margin-bottom: 20px; width: 100%;&#34;
        allowfullscreen=&#34;true&#34;&gt;
    &lt;/iframe&gt;

</description>
    </item>
    
    <item>
      <title>Slides: Community Day 2014 – Introduction to Microsoft Azure Compute</title>
      <link>https://ravichaganti.com/blog/session-slides-community-day-2014-introduction-to-microsoft-azure-compute/</link>
      <pubDate>Sun, 24 Aug 2014 00:00:00 +0000</pubDate>
      
      <guid>https://ravichaganti.com/blog/session-slides-community-day-2014-introduction-to-microsoft-azure-compute/</guid>
      <description>&lt;p&gt;Microsoft Azure offers several services each categorized into one of the four major categories – Compute, Data, App, and Network Services. This session takes you through an overview of the Microsoft Azure Compute Services.&lt;/p&gt;

    &lt;iframe
        src=&#34;//www.slideshare.net/slideshow/embed_code/key/62eQ9o9FToFmEq&#34;
        title=&#34;SlideShare Presentation&#34;
        height=&#34;400&#34;
        frameborder=&#34;0&#34;
        marginwidth=&#34;0&#34;
        marginheight=&#34;0&#34;
        scrolling=&#34;no&#34;
        style=&#34;border: 1px solid #CCC; border-width: 1px; margin-bottom: 20px; width: 100%;&#34;
        allowfullscreen=&#34;true&#34;&gt;
    &lt;/iframe&gt;

&lt;!-- raw HTML omitted --&gt;
&lt;p&gt; &lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Slides: Reboot IT, Bangalore - Whats new in Server 2012 R2 Hyper-V</title>
      <link>https://ravichaganti.com/blog/reboot-it-bangalore-2014-session-slides-whats-new-in-server-2012-r2-hyper-v/</link>
      <pubDate>Wed, 19 Mar 2014 00:00:00 +0000</pubDate>
      
      <guid>https://ravichaganti.com/blog/reboot-it-bangalore-2014-session-slides-whats-new-in-server-2012-r2-hyper-v/</guid>
      <description>&lt;p&gt;Here are the slides I used for my first session at the Reboot IT conference in Bangalore. We had over 130 attendees and the entire event was very well received.&lt;/p&gt;

    &lt;iframe
        src=&#34;//www.slideshare.net/slideshow/embed_code/key/3PSBj4JU4sFGIL&#34;
        title=&#34;SlideShare Presentation&#34;
        height=&#34;400&#34;
        frameborder=&#34;0&#34;
        marginwidth=&#34;0&#34;
        marginheight=&#34;0&#34;
        scrolling=&#34;no&#34;
        style=&#34;border: 1px solid #CCC; border-width: 1px; margin-bottom: 20px; width: 100%;&#34;
        allowfullscreen=&#34;true&#34;&gt;
    &lt;/iframe&gt;

&lt;!-- raw HTML omitted --&gt;
</description>
    </item>
    
  </channel>
</rss>
