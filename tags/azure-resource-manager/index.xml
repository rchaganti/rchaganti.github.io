<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Azure Resource Manager on Ravikanth Chaganti</title>
    <link>https://ravichaganti.com/tags/azure-resource-manager/</link>
    <description>Recent content in Azure Resource Manager on Ravikanth Chaganti</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Thu, 16 Jul 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://ravichaganti.com/tags/azure-resource-manager/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Azure Resource Manager - Introduction</title>
      <link>https://ravichaganti.com/blog/azure-resource-manager-introduction/</link>
      <pubDate>Thu, 16 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ravichaganti.com/blog/azure-resource-manager-introduction/</guid>
      <description>&lt;p&gt;A while ago, I had written a &lt;a href=&#34;https://ravichaganti.com/series/arm-templates/&#34;&gt;series of articles&lt;/a&gt; introducing and diving deep into authoring Azure Resource Manager (ARM) templates. A few things have changed in authoring ARM templates and new features got added in the recent past. I thought it is probably a better time to revisit and do it all over again. At the same time, I thought why just limit to just authoring ARM templates. Over the years, I made notes around ARM and learned quite a bit. Starting today, I will share those notes with you here.&lt;/p&gt;
&lt;p&gt;In this new and improved series, I will start from the very basics and build upon that in each article. The goal is to ensure I create a set of articles that can be referenced in a zero to hero approach to understand ARM and authoring ARM templates. So, without further ado, let us get started and let us start with the very basics.&lt;/p&gt;
&lt;h2 id=&#34;what-is-azure-resource-manager-arm&#34;&gt;What is Azure Resource Manager (ARM)?&lt;/h2&gt;
&lt;p&gt;Microsoft Azure, during the early days, had a management layer called Azure Service Manager (ASM) that was responsible for deploying and managing services. These services that you deployed using ASM were all independent entities without any grouping whatsoever. There was no way to define the dependencies either. So, if you were to implement a three-tier application as a set of cloud services, each service in the three-tier application had to be deployed individually and managed individually. When you have to delete this application, you had to do it by deleting each service individually. The same applies to updates as well. Monitoring and billing was a nightmare. This approach was not scalable. So, during &lt;a href=&#34;https://channel9.msdn.com/Events/Build/2014/2-607&#34;&gt;Build 2014&lt;/a&gt;, Microsoft announced a new deployment and management service called Azure Resource Manager (ARM).&lt;/p&gt;
&lt;p&gt;Here is a super simplified view of the ARM that provides an overview of the constructs.&lt;/p&gt;

    &lt;figure &gt;
        
            &lt;img src=&#34;https://ravichaganti.com/images/armin30/d1-armarch.png&#34; width=&#34;350&#34; /&gt;
        
        
    &lt;/figure&gt;
    
&lt;p&gt;With ARM, all your &lt;em&gt;&lt;strong&gt;resources&lt;/strong&gt;&lt;/em&gt; having a common life cycle (create/update/delete) can now be grouped together under a &lt;em&gt;&lt;strong&gt;resource group&lt;/strong&gt;&lt;/em&gt; and their life cycle management can be done together. A resource group becomes the unit of management. Each resource in Azure is supplied by a service known as a &lt;em&gt;&lt;strong&gt;resource provider&lt;/strong&gt;&lt;/em&gt;. The resources in Azure can be deployed in many ways but the focus of this series will be around the declarative &lt;em&gt;&lt;strong&gt;deployment templates&lt;/strong&gt;&lt;/em&gt; through which you can provision the resources in a consistent and idempotent manner.&lt;/p&gt;
&lt;p&gt;Let us dig a bit into the terminology you read in the above paragraph.&lt;/p&gt;
&lt;h2 id=&#34;azure-resources&#34;&gt;Azure Resources&lt;/h2&gt;
&lt;p&gt;Resources are what you provision in Azure cloud. For example, as shown in the above image, web apps, virtual machines, databases, and so on. Each resource will have certain properties that you can configure. What resources you can provision depends on what is allowed and / or enabled in your subscription. We will look at this in a later article.&lt;/p&gt;
&lt;h2 id=&#34;azure-resource-groups&#34;&gt;Azure Resource Groups&lt;/h2&gt;
&lt;p&gt;Resource group is a container for all resources that share a common life cycle. A resource should always exist in a resource group and can exist only in one group. It is not necessary that resources that have inter-dependencies are provisioned in the same resource group. These resources within a resource group can exist in different regions too. Instead, the life cycle of the resources is used as a way to group the resources together.&lt;/p&gt;
&lt;h2 id=&#34;azure-resource-providers&#34;&gt;Azure Resource Providers&lt;/h2&gt;
&lt;p&gt;The resource providers enable the resource and implement the management of the resources. Each resource that you can provision in Azure will have an associated resource provider. ARM binds all this together to provide a single management pane irrespective of what type of resource you are provisioning.&lt;/p&gt;
&lt;p&gt;There are several methods to interact with ARM for all your resource creation and management needs. These methods include Azure PowerShell module, Azure CLI, Azure SDKs for Golang, Python, and other languages. You can, of course, use the REST API directly to provision and manage resources. Through all these methods, you basically use individual commands or write scripts or you own applications to provision and manage resources. This approach is more imperative in nature. You write a script to implement what you need and at the same time you define how that needs to be done. In an imperative method, you perform checks to see if the resource that you are trying to provision already exists or not and provision only if it does not exist. You perform all error handling yourself in the imperative approach. And, if you were to create a lot of resources that do not necessarily depend on each other, you can write some parallel jobs to perform simultaneous execution of resource creation. But, the onus is on you to write this code and make sure it works.&lt;/p&gt;
&lt;h2 id=&#34;azure-resource-manager-templates&#34;&gt;Azure Resource Manager Templates&lt;/h2&gt;
&lt;p&gt;ARM templates help eliminate the need for the tedious and error-prone development of automation scripts using any of the methods you read about earlier. These templates are JSON files that provide a declarative syntax to provision Azure resources. Using the &lt;strong&gt;declarative&lt;/strong&gt; syntax of ARM templates, you define what infrastructure you need to provision and not how. With the increasing focus on Agile infrastructure practices and DevOps, this declarative template becomes a part of your application code and lives in the same source control repositories as your application. Any changes to the infrastructure configuration go through the same source control and application development procedures such as automation validations, continuous integration and delivery / deployment. This is what we describe as Infrastructure as Code (IaC).&lt;/p&gt;
&lt;p&gt;The ARM templates also offer a way to repeatedly deploy your infrastructure in Azure cloud. This is done in an &lt;strong&gt;idempotent&lt;/strong&gt; way. Idempotency means that the result of a provisioning task (state of the resources defined in the template) would be same irrespective of how many times you run the task.&lt;/p&gt;
&lt;p&gt;With ARM templates, unlike imperative scripting, you don&amp;rsquo;t have to worry about simultaneous resource creation or resource provisioning dependencies or error handling. ARM can infer these dependencies from what is defined in the template and also perform parallel execution when possible. This ensures &lt;strong&gt;reliable&lt;/strong&gt; deployment of resources defined in the template.&lt;/p&gt;
&lt;p&gt;In summary, &lt;em&gt;&lt;strong&gt;ARM templates offer a declarative method to provision your infrastructure resources in a reliable and idempotent manner&lt;/strong&gt;&lt;/em&gt;. There are several other aspects of ARM templates such as validation, extensions, and modularity / composability. You will read more about these characteristics in the upcoming parts of this series with relevant examples.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Apart from ARM templates, there are 3rd party providers such as &lt;a href=&#34;https://docs.microsoft.com/en-us/azure/developer/terraform/overview#:~:text=%20Terraform%20with%20Azure%20%201%20Automate%20infrastructure,configuring%20it%20to%20use%20Azure.%20%20More%20&#34;&gt;Terraform&lt;/a&gt; and &lt;a href=&#34;https://www.pulumi.com/azure/&#34;&gt;Pulumi&lt;/a&gt; for provisioning Azure infrastructure. These methods provide the same characteristics as ARM templates. Each of these methods have their pros and cons. This series of articles will only use ARM templates as a way to provision infrastructure.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;If you are interested in exploring what ARM templates look like or looking for a quick start for a specific resource type or scenario, you may look up &lt;a href=&#34;https://github.com/Azure/azure-quickstart-templates&#34;&gt;Azure Quickstart templates GitHub repository&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Writing and reading ARM templates can be very complex and may get boring as well! At Build 2020, Microsoft announced &lt;a href=&#34;https://youtu.be/UaVCNpD3pvg?t=986&#34;&gt;language revision&lt;/a&gt; that intends to provide a Domain Specific Language (DSL) abstraction that complies to a JSON template underneath and makes it easy for you to author complex ARM templates.&lt;/p&gt;

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/UaVCNpD3pvg?t=986&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;As this preview becomes available, I will write more about this new method here.&lt;/p&gt;
&lt;p&gt;After you author the ARM templates, you can deploy these templates using a variety of methods. You will read more about these methods in the next part of this series.&lt;/p&gt;
&lt;h2 id=&#34;azure-deployment-manager&#34;&gt;Azure Deployment Manager&lt;/h2&gt;
&lt;p&gt;As your organization grows and you start using Azure with multiple subscriptions and may be in multiple regions too, it becomes complex to perform an ordered and monitored rollout of Azure deployments. This is where &lt;a href=&#34;https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/deployment-manager-overview&#34;&gt;Azure Deployment Manager&lt;/a&gt; (ADM) comes into play. ADM extends ARM by enabling new features called &lt;em&gt;Service Topologies&lt;/em&gt; and &lt;em&gt;Rollouts&lt;/em&gt;.  ADM makes it easy to define complex deployments that span multiple regions and subscriptions and allows repeated deployments of these topologies using &lt;a href=&#34;https://docs.microsoft.com/en-us/rest/api/deploymentmanager/rollouts&#34;&gt;Rollouts&lt;/a&gt;. You will learn about this in-depth in later parts of this series.&lt;/p&gt;
&lt;h2 id=&#34;azure-governance&#34;&gt;Azure Governance&lt;/h2&gt;
&lt;p&gt;While knowing how to author and deploy ARM templates is an important part of working with Azure, it is equally important to know how to govern those resources and services deployed in Azure. As cloud architect, you would want control over who can create what type resources, where can they create those resources and how many. You would also want to standardize on the deployments so that the configuration of resources is in compliance with your organization standards. Among many other aspects like this you would want the ability to track your cloud cost more granularly for every service deployed in the cloud and for every business unit or group within your organization. To address this and to implement efficient governance Azure offers features and services such as &lt;a href=&#34;https://docs.microsoft.com/en-us/azure/governance/policy/overview&#34;&gt;Policies&lt;/a&gt;, &lt;a href=&#34;https://docs.microsoft.com/en-us/azure/governance/management-groups/&#34;&gt;Management Groups&lt;/a&gt;, &lt;a href=&#34;https://azure.microsoft.com/en-us/features/resource-graph/&#34;&gt;Resource Graph&lt;/a&gt;, and &lt;a href=&#34;https://docs.microsoft.com/en-us/azure/governance/blueprints/overview&#34;&gt;Blueprints&lt;/a&gt;. Here is an excellent depiction of Azure governance architecture from the &lt;a href=&#34;https://www.microsoft.com/en-us/us-partner-blog/2019/07/24/azure-governance/&#34;&gt;partner blog&lt;/a&gt;.&lt;/p&gt;

    &lt;figure &gt;
        
            &lt;img src=&#34;https://ravichaganti.com/images/armin30/d1-azuregovernance.png&#34; width=&#34;800&#34; /&gt;
        
        
    &lt;/figure&gt;
    
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Azure Policy&lt;/strong&gt;&lt;/em&gt; helps enforce your organizational IT and business standards for resource consistency, compliance to regulatory requirements, management, security, and cost. Azure offers a set of built-in policy definitions that are readily available for some of the common use cases in your Azure environment. You can, of course, create your own custom policy definitions as well.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Azure Management Groups&lt;/strong&gt;&lt;/em&gt; allow organizing subscriptions into containers called management groups and then perform governance on these management groups. The subscriptions under the management groups inherit the governance conditions (policies) applied at the management group level.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Azure Resource Graph&lt;/strong&gt;&lt;/em&gt; offers an efficient and performant way to query resources across multiple environments and subscriptions. This service can be used to extend management of Azure resources by enabling the ability to query resources with complex filtering, grouping, and sorting by resource properties. To use Azure Graph, you need to understand the Kusto Query Language (&lt;a href=&#34;https://docs.microsoft.com/en-us/azure/governance/resource-graph/concepts/query-language&#34;&gt;KQL&lt;/a&gt;). In this series of articles, you will see a basic overview of KQL and using Azure CLI to query the Resource Graph.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Azure Blueprints&lt;/strong&gt;&lt;/em&gt; enable streamlining of resource deployments by packaging ARM templates, policies, and role assignments. Blueprints are a declarative way to orchestrate these templates and other related artifacts. Blueprints enable efficient tracking and auditing of deployments. The knowledge you gain around ARM templates can be directly used with Azure Blueprints.&lt;/p&gt;
&lt;p&gt;With this quick overview of Azure governance features and service, you have an understanding of Azure Resource Manager and services that complement ARM. This brings us to the end of today&amp;rsquo;s article. The next few parts of this series will focus on authoring ARM templates. As described earlier, the ARM templates are JSON files and can be authored in notepad as well. But, there are some very good authoring tools and we will take a look at that in the next part of this series. Stay tuned!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Custom Template Deployment Improvements in Azure Portal</title>
      <link>https://ravichaganti.com/blog/custom-template-deployment-improvements-in-azure-portal/</link>
      <pubDate>Tue, 29 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ravichaganti.com/blog/custom-template-deployment-improvements-in-azure-portal/</guid>
      <description>&lt;p&gt;When testing ARM templates, I typically use the custom template deployment option in the Azure Portal. This UI option just got better! This deployment option now supports lists the parameters, variables, and resources used in template in a nice treeview navigation.&lt;/p&gt;
&lt;p&gt;To start a new deployment, you can click on New -&amp;gt; Template Deployment.&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&#34;https://ravichaganti.com/images/armtemplate11-1.png&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;This opens up the Custom Deployment blade. Click on Edit Template.&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&#34;https://ravichaganti.com/images/armtemplate11-2.png&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;In the Edit Template blade, copy/paste your template JSON in the editor.&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&#34;https://ravichaganti.com/images/armtemplate11-3.png&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;In a few seconds, you will see the treeview built for the template. You can expand each node to see the individual elements within each category. Selecting a specific element within a node navigates to the definition for that selection within the JSON template.&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&#34;https://ravichaganti.com/images/armtemplate11-4.png&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;You can click Save and then proceed to the deployment by completing the remaining steps in the custom deployment.&lt;/p&gt;
&lt;p&gt;The second enhancement is the option to pull a quick start &lt;a href=&#34;https://github.com/Azure/azure-quickstart-templates&#34;&gt;template from the Github repository&lt;/a&gt; and deploy it!&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&#34;https://ravichaganti.com/images/armtemplate11-5.png&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;In the &lt;em&gt;Load a quickstart template&lt;/em&gt; blade, you can select a template listed in the dropdown.&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&#34;https://ravichaganti.com/images/armtemplate11-6.png&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;Clicking OK in this blade opens the template in the Edit Template blade where you can make changes as needed and save it.&lt;/p&gt;
&lt;p&gt;These are two nice surprises this morning. Anymore waiting? 🙂&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Building Azure Resource Manager Templates – Forcing WMF 4.0 when using DSC Extension</title>
      <link>https://ravichaganti.com/blog/building-azure-resource-manager-templates-forcing-wmf-4-0-when-using-dsc-extension/</link>
      <pubDate>Mon, 15 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ravichaganti.com/blog/building-azure-resource-manager-templates-forcing-wmf-4-0-when-using-dsc-extension/</guid>
      <description>&lt;p&gt;This subject won&amp;rsquo;t really need a post of its own but I will do it anyway. In the previous part of this &lt;a href=&#34;http://azrs.tk/armseries&#34;&gt;ARM series&lt;/a&gt;, I showed how we can use the domain join extension instead of DSC to join a VM to an existing AD domain. This resulted is huge savings in time taken to deploy the entire scenario. When I was talking to my good friend, fellow PowerShell MVP and all-things-Azure guru, &lt;a href=&#34;https://twitter.com/bgelens&#34;&gt;Ben Gelens&lt;/a&gt;, he was quick to point that the delays when using DSC extension here could be due to the install of WMF 5.0. Indeed!&lt;/p&gt;
&lt;p&gt;When you use Azure DSC extension, it by default installs latest available version of WMF 5.0 (production preview at the time of this writing) which requires a reboot! Therefore, using DSC extension in ARM templates for down-level OS such as Windows Server 2012 or 2012 R2, there will be delays. But, there is a workaround. We can force DSC extension to use WMF 4.0. Here is how we do that.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;{
    &amp;#34;type&amp;#34;: &amp;#34;Microsoft.Compute/virtualMachines/extensions&amp;#34;,
    &amp;#34;copy&amp;#34;: {
        &amp;#34;name&amp;#34;: &amp;#34;vmDomainLoop&amp;#34;,
        &amp;#34;count&amp;#34;: &amp;#34;[variables(&amp;#39;selectedDeployment&amp;#39;).instancesCount]&amp;#34;
    },
    &amp;#34;name&amp;#34;: &amp;#34;[concat(&amp;#39;vm&amp;#39;,copyIndex(1),&amp;#39;/domainjoin&amp;#39;)]&amp;#34;,
    &amp;#34;apiVersion&amp;#34;: &amp;#34;2015-05-01-preview&amp;#34;,
    &amp;#34;location&amp;#34;: &amp;#34;[resourceGroup().location]&amp;#34;,
    &amp;#34;dependsOn&amp;#34;: [
        &amp;#34;vmLoop&amp;#34;
    ],
    &amp;#34;properties&amp;#34;: {
        &amp;#34;publisher&amp;#34;: &amp;#34;Microsoft.Powershell&amp;#34;,
        &amp;#34;type&amp;#34;: &amp;#34;DSC&amp;#34;,
        &amp;#34;typeHandlerVersion&amp;#34;: &amp;#34;2.8&amp;#34;,
        &amp;#34;settings&amp;#34;: {
            &amp;#34;ModulesUrl&amp;#34;: &amp;#34;[concat(parameters(&amp;#39;assetLocation&amp;#39;),&amp;#39;/Configuration.zip&amp;#39;)]&amp;#34;,
            &amp;#34;WmfVersion&amp;#34;:  &amp;#34;4.0&amp;#34;,
            &amp;#34;ConfigurationFunction&amp;#34;: &amp;#34;Configuration.ps1\\DomainJoin&amp;#34;,
            &amp;#34;Properties&amp;#34;: {
                &amp;#34;DomainName&amp;#34;: &amp;#34;[parameters(&amp;#39;adDomainName&amp;#39;)]&amp;#34;,
                &amp;#34;AdminCreds&amp;#34;: {
                    &amp;#34;UserName&amp;#34;: &amp;#34;[parameters(&amp;#39;adminUsername&amp;#39;)]&amp;#34;,
                    &amp;#34;Password&amp;#34;: &amp;#34;PrivateSettingsRef:adminPassword&amp;#34;
                }
            }
        },
        &amp;#34;protectedSettings&amp;#34;: {
            &amp;#34;Items&amp;#34;: {
                &amp;#34;adminPassword&amp;#34;: &amp;#34;[parameters(&amp;#39;adminPassword&amp;#39;)]&amp;#34;
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Observe line number 19. We use the WmfVersion property and set it to 4.0. This forces DSC extension to use WMF 4.0 instead of installing latest WMF 5.0 bits. Remember to use this method, for down-level OS where WMF / PS 5.0 isn’t available by default and where you don’t need any features provided by WMF / PS 5.0, to make sure deployment times are optimized.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; If you need to do this outside an ARM template, &lt;a href=&#34;https://blogs.msdn.microsoft.com/powershell/2015/10/01/how-to-use-wmf-4-with-azure-dsc-extension-in-azure-cloud-service-manager-asm/&#34;&gt;you can do so by creating the JSON needed for this and then use the Azure PowerShell cmdlets&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;You can click the Deploy to Azure button below to deploy the sample scenario detailed in this article series.&lt;/p&gt;

    &lt;a href=&#34;https://portal.azure.com/#create/Microsoft.Template/uri/https%3a%2f%2fportal.azure.com%2f%23create%2fMicrosoft.Template%2furi%2fhttps%253A%252F%252Fraw.githubusercontent.com%252Frchaganti%252Farmseries%252Fmaster%252Farm-series_Storage-VirtualNet-LinkedTemplate-Complete.json&#34; target=&#34;_blank&#34;&gt;
        &lt;img src=&#34;https://raw.githubusercontent.com/Azure/azure-quickstart-templates/master/1-CONTRIBUTION-GUIDE/images/deploytoazure.svg?sanitize=true&#34; alt=&#34;&#34;&gt;
    &lt;/a&gt;
    &lt;br /&gt;

&lt;p&gt;By forcing DSC extension to use WMF 4.0, the complete sample scenario (with one AD VM and three VMs joining the domain) was completed in 33 mins!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Building Azure Resource Manager Templates – Using Domain Join Extension</title>
      <link>https://ravichaganti.com/blog/building-azure-resource-manager-templates-using-domain-join-extension/</link>
      <pubDate>Sat, 13 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ravichaganti.com/blog/building-azure-resource-manager-templates-using-domain-join-extension/</guid>
      <description>&lt;p&gt;The scenario that we used to understand and build ARM templates contained a domain controller VM along with one or more VMs that joined the domain service hosted by the DC VM.&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&#34;https://ravichaganti.com/images/armtemplate9-1.png&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;To make sure the VMs join the domain, we used PowerShell DSC configuration. One of the biggest quirks, at least what I faced, with DSC extension with ARM templates is that it takes little longer to complete. For example, the complete scenario deployment took almost 48 minutes to deploy. I am not making up that number. Here is the proof.&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&#34;https://ravichaganti.com/images/armtemplate9-2.png&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;Now, 48 minutes may not sound that worse but imagine deploying tens of VMs that need to join the domain using the DSC configuration as we saw in the earlier example in this series.&lt;/p&gt;
&lt;p&gt;This is where the new JsonADDomainExtension helps! Instead of using DSC configuration to add VMs to a AD domain, we will now use this VM extension. Within the [earlier template that deployed this scenario][1], we will remove the domainJoin resource definition and replace that with JsonADDomainExtension.&lt;/p&gt;
&lt;p&gt;Here is how that new resource definition looks.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&amp;#34;resources&amp;#34;: [
    {
        &amp;#34;apiVersion&amp;#34;: &amp;#34;2015-06-15&amp;#34;,
        &amp;#34;type&amp;#34;: &amp;#34;Microsoft.Compute/virtualMachines/extensions&amp;#34;,
        &amp;#34;name&amp;#34;: &amp;#34;[concat(concat(&amp;#39;vm&amp;#39;,copyIndex(1)),&amp;#39;/joindomain&amp;#39;)]&amp;#34;,
        &amp;#34;location&amp;#34;: &amp;#34;[resourceGroup().location]&amp;#34;,
        &amp;#34;dependsOn&amp;#34;: [
                &amp;#34;[concat(&amp;#39;Microsoft.Compute/virtualMachines/&amp;#39;, concat(&amp;#39;vm&amp;#39;,copyIndex(1)))]&amp;#34;
        ],                    
        &amp;#34;properties&amp;#34;: {
            &amp;#34;publisher&amp;#34;: &amp;#34;Microsoft.Compute&amp;#34;,
            &amp;#34;type&amp;#34;: &amp;#34;JsonADDomainExtension&amp;#34;,
            &amp;#34;typeHandlerVersion&amp;#34;: &amp;#34;1.0&amp;#34;,
            &amp;#34;settings&amp;#34;: {
                &amp;#34;Name&amp;#34;: &amp;#34;[parameters(&amp;#39;adDomainName&amp;#39;)]&amp;#34;,
                &amp;#34;User&amp;#34;: &amp;#34;[concat(parameters(&amp;#39;adDomainName&amp;#39;), &amp;#39;\\&amp;#39;, parameters(&amp;#39;adminUserName&amp;#39;))]&amp;#34;,
                &amp;#34;Restart&amp;#34;: &amp;#34;true&amp;#34;,
                &amp;#34;Options&amp;#34;: &amp;#34;3&amp;#34;,
                &amp;#34;OUPath&amp;#34;: &amp;#34;[parameters(&amp;#39;OUPath&amp;#39;)]&amp;#34;
            },
            &amp;#34;protectedsettings&amp;#34;: {
                &amp;#34;Password&amp;#34;: &amp;#34;[parameters(&amp;#39;adminPassword&amp;#39;)]&amp;#34;
            }
        }
    }
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In this extension settings, I am re-using a few parameters such as &lt;em&gt;adDomainName&lt;/em&gt;, &lt;em&gt;adminUserName&lt;/em&gt;, and &lt;em&gt;adminPassword&lt;/em&gt;. I added a new parameter called &lt;em&gt;OUPath&lt;/em&gt;. This specifies the organization unit for the VM computer account and it is not mandatory to specify this. Let’s take a quick look at the properties of this resource.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;Property Name&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Name&lt;/td&gt;
&lt;td&gt;Name of the Active Directory Domain to join&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;User&lt;/td&gt;
&lt;td&gt;Administrator account name to authenticate&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Restart&lt;/td&gt;
&lt;td&gt;Specifies if the VM should restart after domain join. Possible values: true or false&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Options&lt;/td&gt;
&lt;td&gt;Domain join options. Default option is 3.Refer to &lt;a href=&#34;https://msdn.microsoft.com/en-us/library/windows/desktop/aa370433(v=vs.85).aspx&#34;&gt;NetJoin options on MSDN&lt;/a&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;OUPath&lt;/td&gt;
&lt;td&gt;Organization Unit for the VM computer account. It is not mandatory to specify this value.Example specification: OU=testOU; DC=domain; DC=Domain; DC=com&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;The &lt;a href=&#34;https://github.com/rchaganti/armseries/blob/master/arm-series_Final-JoinDomain-Extension.json&#34;&gt;complete template that uses this new extension&lt;/a&gt; is rather lengthy. So, click on the below Deploy to Azure button to deploy this template.&lt;/p&gt;

    &lt;a href=&#34;https://portal.azure.com/#create/Microsoft.Template/uri/https%3a%2f%2fportal.azure.com%2f%23create%2fMicrosoft.Template%2furi%2fhttps%253A%252F%252Fraw.githubusercontent.com%252Frchaganti%252Farmseries%252Fmaster%252Farm-series_Final-JoinDomain-Extension.json&#34; target=&#34;_blank&#34;&gt;
        &lt;img src=&#34;https://raw.githubusercontent.com/Azure/azure-quickstart-templates/master/1-CONTRIBUTION-GUIDE/images/deploytoazure.svg?sanitize=true&#34; alt=&#34;&#34;&gt;
    &lt;/a&gt;
    &lt;br /&gt;

&lt;p&gt;As compared to the DSC way of joining a domain, the new domain join extension method took only 31 minutes. This is it for now! Try this template and let me know what you think.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Building Azure Resource Manager Templates – Putting it all together</title>
      <link>https://ravichaganti.com/blog/building-azure-resource-manager-templates-putting-it-all-together/</link>
      <pubDate>Fri, 18 Dec 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ravichaganti.com/blog/building-azure-resource-manager-templates-putting-it-all-together/</guid>
      <description>&lt;p&gt;In this series so far, we looked at building ARM templates by example. The focus was not really on the resource types or how to use resource definitions. Instead, our focus was on learning the basics of template language. To that extent, we have a scenario that we want to deploy and we are incrementally building the template for it.&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&#34;https://ravichaganti.com/images/armtemplate8-1.png&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;While building an ARM template for this, we looked at how to use parameters and variables. We looked at using copy object to create multiple instances of a resource type without really writing the resource definition multiple times. We went on to find out how we can define dependencies between different resource types so they are orchestrated in the right order. We looked at how we can decompose the template into purpose-specific external templates and how to link them together. While learning these concepts, we created a template that almost built the scenario we started with.&lt;/p&gt;
&lt;p&gt;We will now add the remaining VMs based on the &lt;em&gt;environmentType&lt;/em&gt; selected by the user. So, based on the VM instance count we need, we have to create network interfaces and virtual machines. We have already provisioned the inbound NAT rules needed for the RDP access to these virtual machine consoles post deployment.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;{
  &amp;#34;apiVersion&amp;#34;: &amp;#34;2015-06-15&amp;#34;,
  &amp;#34;type&amp;#34;: &amp;#34;Microsoft.Network/loadBalancers/inboundNatRules&amp;#34;,
  &amp;#34;copy&amp;#34;: {
    &amp;#34;name&amp;#34;: &amp;#34;lbRdpNatLoop&amp;#34;,
    &amp;#34;count&amp;#34;: &amp;#34;[variables(&amp;#39;selectedDeployment&amp;#39;).instancesCount]&amp;#34;
  },
  &amp;#34;name&amp;#34;: &amp;#34;[concat(&amp;#39;/loadBalancer/&amp;#39;,&amp;#39;VM&amp;#39;, copyIndex(1),&amp;#39;-RDP&amp;#39;)]&amp;#34;,
  &amp;#34;location&amp;#34;: &amp;#34;[resourceGroup().location]&amp;#34;,
  &amp;#34;dependsOn&amp;#34;: [
    &amp;#34;Microsoft.Network/loadBalancers/loadBalancer&amp;#34;
  ],
  &amp;#34;properties&amp;#34;: {
    &amp;#34;frontendIPConfiguration&amp;#34;: {
      &amp;#34;id&amp;#34;: &amp;#34;[concat(resourceId(&amp;#39;Microsoft.Network/loadBalancers&amp;#39;,&amp;#39;loadBalancer&amp;#39;),&amp;#39;/frontendIPConfigurations/LBFrontEnd&amp;#39;)]&amp;#34;
    },
    &amp;#34;protocol&amp;#34;: &amp;#34;tcp&amp;#34;,
    &amp;#34;frontendPort&amp;#34;: &amp;#34;[add(3389, copyIndex(1))]&amp;#34;,
    &amp;#34;backendPort&amp;#34;: 3389,
    &amp;#34;enableFloatingIP&amp;#34;: false
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Look at line number 8. We are building the name of the inbound NAT rule using &lt;em&gt;copyIndex()&lt;/em&gt;. This gives us the ability to differentiate between NAT rules for different VMs. We now have to create the equal number of VM network interfaces based on the instance count selected. Here is how we do it.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;{
    &amp;#34;apiVersion&amp;#34;: &amp;#34;2015-05-01-preview&amp;#34;,
    &amp;#34;type&amp;#34;: &amp;#34;Microsoft.Network/networkInterfaces&amp;#34;,
    &amp;#34;name&amp;#34;: &amp;#34;[concat(&amp;#39;vm&amp;#39;, copyIndex(1), &amp;#39;-nif&amp;#39;)]&amp;#34;,
    &amp;#34;location&amp;#34;: &amp;#34;[resourceGroup().location]&amp;#34;,
    &amp;#34;copy&amp;#34;: {
        &amp;#34;name&amp;#34;: &amp;#34;vmNetworkLoop&amp;#34;,
        &amp;#34;count&amp;#34;: &amp;#34;[variables(&amp;#39;selectedDeployment&amp;#39;).instancesCount]&amp;#34;
    },
    &amp;#34;dependsOn&amp;#34;: [
        &amp;#34;Microsoft.Network/loadBalancers/loadBalancer&amp;#34;,
        &amp;#34;[concat(&amp;#39;Microsoft.Network/virtualNetworks/&amp;#39;, parameters(&amp;#39;vNetName&amp;#39;))]&amp;#34;,
        &amp;#34;Microsoft.Resources/deployments/updatevnetdns&amp;#34;,
        &amp;#34;lbRdpNatLoop&amp;#34;
    ],
    &amp;#34;properties&amp;#34;: {
        &amp;#34;ipConfigurations&amp;#34;: [
            {
                &amp;#34;name&amp;#34;: &amp;#34;[concat(&amp;#39;vm&amp;#39;, copyIndex(1), &amp;#39;-ipconfig&amp;#39;)]&amp;#34;,
                &amp;#34;properties&amp;#34;: {
                    &amp;#34;privateIPAllocationMethod&amp;#34;: &amp;#34;dynamic&amp;#34;,
                    &amp;#34;subnet&amp;#34;: {
                        &amp;#34;id&amp;#34;: &amp;#34;[variables(&amp;#39;vNetSubnet1ID&amp;#39;)]&amp;#34;
                    },
                    &amp;#34;loadBalancerBackendAddressPools&amp;#34;: [
                        {
                            &amp;#34;id&amp;#34;: &amp;#34;[concat(resourceId(&amp;#39;Microsoft.Network/loadBalancers&amp;#39;,&amp;#39;loadBalancer&amp;#39;),&amp;#39;/backendAddressPools/LBBackEnd&amp;#39;)]&amp;#34;
                        }
                    ],
                    &amp;#34;loadBalancerInboundNatRules&amp;#34;: [
                        {
                            &amp;#34;id&amp;#34;: &amp;#34;[concat(resourceId(&amp;#39;Microsoft.Network/loadBalancers&amp;#39;,&amp;#39;loadBalancer&amp;#39;),concat(&amp;#39;/inboundNatRules/VM&amp;#39;,copyIndex(1),&amp;#39;-RDP&amp;#39;))]&amp;#34;
                        }
                    ]
                }
            }
        ]
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Let us discuss this definition a bit. We need to ensure that the network interfaces are bound to the load balancer. Without this, the RDP endpoints that we created within the NAT rules will not apply to the VMs. To achieve this, we defined dependency (line number 14) on the NAT rules resource definition identified using &lt;em&gt;lbRdpNatLoop&lt;/em&gt;. So, this is how we depend on the copy loop within the ARM template language. Line number 32 attaches the right RDP NAT rule for the VM by using the &lt;em&gt;copyIndex()&lt;/em&gt; function again.&lt;/p&gt;
&lt;p&gt;Now that we have the network interfaces required (based on the instance count), we can create the virtual machines needed based on the &lt;em&gt;envrionmentType&lt;/em&gt; (Development or Test or Production). Based on this choice, there may be more than one virtual machine that gets created. Where there is more than one VM behind a load balancer, we would need an availability set attached to those VMs. So, let us add the resource definition for the availability set.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;{
    &amp;#34;type&amp;#34;: &amp;#34;Microsoft.Compute/availabilitySets&amp;#34;,
    &amp;#34;name&amp;#34;: &amp;#34;availabilitySet&amp;#34;,
    &amp;#34;apiVersion&amp;#34;: &amp;#34;2015-06-15&amp;#34;,
    &amp;#34;location&amp;#34;: &amp;#34;[resourceGroup().location]&amp;#34;,
    &amp;#34;properties&amp;#34;: {}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;We can now go ahead create the virtual machines we need.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;{
    &amp;#34;apiVersion&amp;#34;: &amp;#34;2015-05-01-preview&amp;#34;,
    &amp;#34;type&amp;#34;: &amp;#34;Microsoft.Compute/virtualMachines&amp;#34;,
    &amp;#34;copy&amp;#34;: {
        &amp;#34;name&amp;#34;: &amp;#34;vmLoop&amp;#34;,
        &amp;#34;count&amp;#34;: &amp;#34;[variables(&amp;#39;selectedDeployment&amp;#39;).instancesCount]&amp;#34;
    },
    &amp;#34;name&amp;#34;: &amp;#34;[concat(&amp;#39;vm&amp;#39;,copyIndex(1))]&amp;#34;,
    &amp;#34;location&amp;#34;: &amp;#34;[resourceGroup().location]&amp;#34;,
    &amp;#34;dependsOn&amp;#34;: [
        &amp;#34;[concat(&amp;#39;Microsoft.Compute/virtualMachines/&amp;#39;, parameters(&amp;#39;dcVMName&amp;#39;))]&amp;#34;,
        &amp;#34;[concat(&amp;#39;Microsoft.Storage/storageAccounts/&amp;#39;, parameters(&amp;#39;storageAccountName&amp;#39;))]&amp;#34;,
        &amp;#34;vmNetworkLoop&amp;#34;
    ],
    &amp;#34;properties&amp;#34;: {
        &amp;#34;availabilitySet&amp;#34;: {
            &amp;#34;id&amp;#34;: &amp;#34;[resourceId(&amp;#39;Microsoft.Compute/availabilitySets&amp;#39;,&amp;#39;availabilitySet&amp;#39;)]&amp;#34;
        },
        &amp;#34;hardwareProfile&amp;#34;: {
            &amp;#34;vmSize&amp;#34;: &amp;#34;[parameters(&amp;#39;vmSize&amp;#39;)]&amp;#34;
        },
        &amp;#34;osProfile&amp;#34;: {
            &amp;#34;computername&amp;#34;: &amp;#34;[concat(&amp;#39;vm&amp;#39;,copyIndex(1))]&amp;#34;,
            &amp;#34;adminUsername&amp;#34;: &amp;#34;[parameters(&amp;#39;adminUsername&amp;#39;)]&amp;#34;,
            &amp;#34;adminPassword&amp;#34;: &amp;#34;[parameters(&amp;#39;adminPassword&amp;#39;)]&amp;#34;
        },
        &amp;#34;storageProfile&amp;#34;: {
            &amp;#34;imageReference&amp;#34;: {
                &amp;#34;publisher&amp;#34;: &amp;#34;[variables(&amp;#39;imagePublisher&amp;#39;)]&amp;#34;,
                &amp;#34;offer&amp;#34;: &amp;#34;[variables(&amp;#39;imageOffer&amp;#39;)]&amp;#34;,
                &amp;#34;sku&amp;#34;: &amp;#34;[parameters(&amp;#39;windowsOSVersion&amp;#39;)]&amp;#34;,
                &amp;#34;version&amp;#34;: &amp;#34;latest&amp;#34;
            },
            &amp;#34;osDisk&amp;#34;: {
                &amp;#34;name&amp;#34;: &amp;#34;osdisk&amp;#34;,
                &amp;#34;vhd&amp;#34;: {
                    &amp;#34;uri&amp;#34;: &amp;#34;[concat(&amp;#39;http://&amp;#39;,parameters(&amp;#39;storageAccountName&amp;#39;),&amp;#39;.blob.core.windows.net/vhds/&amp;#39;, concat(&amp;#39;vm&amp;#39;,copyIndex(1),&amp;#39;-osdisk.vhd&amp;#39;))]&amp;#34;
                },
                &amp;#34;caching&amp;#34;: &amp;#34;ReadWrite&amp;#34;,
                &amp;#34;createOption&amp;#34;: &amp;#34;FromImage&amp;#34;
            }
        },
        &amp;#34;networkProfile&amp;#34;: {
            &amp;#34;networkInterfaces&amp;#34;: [
                {
                    &amp;#34;id&amp;#34;: &amp;#34;[resourceId(&amp;#39;Microsoft.Network/networkInterfaces&amp;#39;,concat(&amp;#39;vm&amp;#39;,CopyIndex(1),&amp;#39;-nif&amp;#39;))]&amp;#34;
                }
            ]
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;We, once again, use a copy object in this definition to create as many virtual machines as we need based on the derived instance count. We also attach (line number 46) the network interfaces created in an earlier step. Once these VMs are created, we need to join them to the domain we created using DSC extension earlier. This is done using DSC again!&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;{
    &amp;#34;type&amp;#34;: &amp;#34;Microsoft.Compute/virtualMachines/extensions&amp;#34;,
    &amp;#34;copy&amp;#34;: {
        &amp;#34;name&amp;#34;: &amp;#34;vmDomainLoop&amp;#34;,
        &amp;#34;count&amp;#34;: &amp;#34;[variables(&amp;#39;selectedDeployment&amp;#39;).instancesCount]&amp;#34;
    },
    &amp;#34;name&amp;#34;: &amp;#34;[concat(&amp;#39;vm&amp;#39;,copyIndex(1),&amp;#39;/domainjoin&amp;#39;)]&amp;#34;,
    &amp;#34;apiVersion&amp;#34;: &amp;#34;2015-05-01-preview&amp;#34;,
    &amp;#34;location&amp;#34;: &amp;#34;[resourceGroup().location]&amp;#34;,
    &amp;#34;dependsOn&amp;#34;: [
        &amp;#34;vmLoop&amp;#34;
    ],
    &amp;#34;properties&amp;#34;: {
        &amp;#34;publisher&amp;#34;: &amp;#34;Microsoft.Powershell&amp;#34;,
        &amp;#34;type&amp;#34;: &amp;#34;DSC&amp;#34;,
        &amp;#34;typeHandlerVersion&amp;#34;: &amp;#34;2.8&amp;#34;,
        &amp;#34;settings&amp;#34;: {
            &amp;#34;ModulesUrl&amp;#34;: &amp;#34;[concat(parameters(&amp;#39;assetLocation&amp;#39;),&amp;#39;/Configuration.zip&amp;#39;)]&amp;#34;,
            &amp;#34;ConfigurationFunction&amp;#34;: &amp;#34;Configuration.ps1\\DomainJoin&amp;#34;,
            &amp;#34;Properties&amp;#34;: {
                &amp;#34;DomainName&amp;#34;: &amp;#34;[parameters(&amp;#39;adDomainName&amp;#39;)]&amp;#34;,
                &amp;#34;AdminCreds&amp;#34;: {
                    &amp;#34;UserName&amp;#34;: &amp;#34;[parameters(&amp;#39;adminUsername&amp;#39;)]&amp;#34;,
                    &amp;#34;Password&amp;#34;: &amp;#34;PrivateSettingsRef:adminPassword&amp;#34;
                }
            }
        },
        &amp;#34;protectedSettings&amp;#34;: {
            &amp;#34;Items&amp;#34;: {
                &amp;#34;adminPassword&amp;#34;: &amp;#34;[parameters(&amp;#39;adminPassword&amp;#39;)]&amp;#34;
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Line numbers 18 and 19 got the real magic that we need to join an existing domain. I packaged all DSC configurations I need for the DC creation and domain join into the configuration.zip file. We give this path to the DSC extension and tell this extension to use the &lt;em&gt;DomainJoin&lt;/em&gt; configuration from the Configuration.ps1 file from the zip package.&lt;/p&gt;
&lt;p&gt;This completes the resource definitions needed for the scenario we have. The complete ARM template is rather lengthy. So, I will not put the entire contents here but you can find it at &lt;a href=&#34;https://github.com/rchaganti/armseries/blob/master/arm-series_Storage-VirtualNet-LinkedTemplate-Complete.json&#34;&gt;https://github.com/rchaganti/armseries/blob/master/arm-series_Storage-VirtualNet-LinkedTemplate-Complete.json&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;You can optionally click on the below button to deploy the complete template right away.&lt;/p&gt;

    &lt;a href=&#34;https://portal.azure.com/#create/Microsoft.Template/uri/https%3a%2f%2fportal.azure.com%2f%23create%2fMicrosoft.Template%2furi%2fhttps%253A%252F%252Fraw.githubusercontent.com%252Frchaganti%252Farmseries%252Fmaster%252Farm-series_Storage-VirtualNet-LinkedTemplate-Complete.json&#34; target=&#34;_blank&#34;&gt;
        &lt;img src=&#34;https://raw.githubusercontent.com/Azure/azure-quickstart-templates/master/1-CONTRIBUTION-GUIDE/images/deploytoazure.svg?sanitize=true&#34; alt=&#34;&#34;&gt;
    &lt;/a&gt;
    &lt;br /&gt;

&lt;p&gt;Once you deploy this, you can verify that we have the configuration done in the right away by looking at the load balancer NAT rules and how they are mapped to the VMs in the backendpool.&lt;/p&gt;
&lt;p&gt;This completes our learning of the basics of ARM template language. Hope you have learned enough to go get started with writing ARM templates. I will continue this series writing about the best practices, tips and tricks around ARM template authoring. Stay tuned for more.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Building Azure Resource Manager Templates – Using Linked Templates</title>
      <link>https://ravichaganti.com/blog/building-azure-resource-manager-templates-using-linked-templates/</link>
      <pubDate>Mon, 14 Dec 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ravichaganti.com/blog/building-azure-resource-manager-templates-using-linked-templates/</guid>
      <description>&lt;p&gt;One of the ARM template authoring best practices is to decompose the JSON template, if applicable, into multiple target-specific templates. Think of this as creating re-usable code. You can leverage the re-usable parts of your code within multiple aspects of your application or the deployment.&lt;/p&gt;
&lt;p&gt;For linking different external templates within the main template, we need to define the &lt;em&gt;Microsoft.Resources/deployments&lt;/em&gt; resource instance. Before we proceed let us look at the scenario for which we are building an ARM template.&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&#34;https://ravichaganti.com/images/armtemplate7-1.png&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;So far in this series, we have looked at building an ARM template that deploys the following components of this scenario:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A storage account&lt;/li&gt;
&lt;li&gt;A virtual network&lt;/li&gt;
&lt;li&gt;A public IP address&lt;/li&gt;
&lt;li&gt;A load balancer&lt;/li&gt;
&lt;li&gt;Virtual network interfaces for the DC and other VMs based on the environment type.&lt;/li&gt;
&lt;li&gt;Finally, a VM with DNS and Directory Services running in it.&lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;
    &lt;img src=&#34;https://ravichaganti.com/images/armtemplate7-2&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;By default, the Azure based IaaS deployments use the Azure DNS. If you have deployed the template that we built in the previous part of this series, you will notice that the virtual network us configured to use Azure DNS.&lt;/p&gt;
&lt;p&gt;Since we deployed a VM that runs our own DNS and directory services, we now want to use the custom DNS in the Azure deployment so that other VMs in the deployment can join the domain that we created using the PowerShell DSC configuration.&lt;/p&gt;
&lt;p&gt;For this, we will use an external template and call it inside our main template. What we essentially need to do here is to update the existing virtual network to use the custom DNS. Here is how it looks.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;{
  &amp;#34;$schema&amp;#34;: &amp;#34;https://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#&amp;#34;,
  &amp;#34;contentVersion&amp;#34;: &amp;#34;1.0.0.0&amp;#34;,
  &amp;#34;parameters&amp;#34;: {
    &amp;#34;virtualNetworkName&amp;#34;: {
      &amp;#34;type&amp;#34;: &amp;#34;string&amp;#34;,
      &amp;#34;metadata&amp;#34;: {
        &amp;#34;description&amp;#34;: &amp;#34;The name of the Virtual Network to Create&amp;#34;
      }
    },
    &amp;#34;virtualNetworkAddressRange&amp;#34;: {
      &amp;#34;type&amp;#34;: &amp;#34;string&amp;#34;,
      &amp;#34;metadata&amp;#34;: {
        &amp;#34;description&amp;#34;: &amp;#34;The address range of the new VNET in CIDR format&amp;#34;
      },
      &amp;#34;defaultValue&amp;#34;: &amp;#34;10.0.0.0/16&amp;#34;
    },
    &amp;#34;subnetName&amp;#34;: {
      &amp;#34;type&amp;#34;: &amp;#34;string&amp;#34;,
      &amp;#34;metadata&amp;#34;: {
        &amp;#34;description&amp;#34;: &amp;#34;The name of the subnet created in the new VNET&amp;#34;
      }
    },
    &amp;#34;subnetRange&amp;#34;: {
      &amp;#34;type&amp;#34;: &amp;#34;string&amp;#34;,
      &amp;#34;metadata&amp;#34;: {
        &amp;#34;description&amp;#34;: &amp;#34;The address range of the subnet created in the new VNET&amp;#34;
      },
      &amp;#34;defaultValue&amp;#34;: &amp;#34;10.0.0.0/24&amp;#34;
    },
    &amp;#34;DNSServerAddress&amp;#34;: {
      &amp;#34;type&amp;#34;: &amp;#34;array&amp;#34;,
      &amp;#34;metadata&amp;#34;: {
        &amp;#34;description&amp;#34;: &amp;#34;The DNS address(es) of the DNS Server(s) used by the VNET&amp;#34;
      }
    }
  },
  &amp;#34;resources&amp;#34;: [
    {
      &amp;#34;apiVersion&amp;#34;: &amp;#34;2015-05-01-preview&amp;#34;,
      &amp;#34;name&amp;#34;: &amp;#34;[parameters(&amp;#39;virtualNetworkName&amp;#39;)]&amp;#34;,
      &amp;#34;type&amp;#34;: &amp;#34;Microsoft.Network/virtualNetworks&amp;#34;,
      &amp;#34;location&amp;#34;: &amp;#34;[resourceGroup().location]&amp;#34;,
      &amp;#34;properties&amp;#34;: {
        &amp;#34;addressSpace&amp;#34;: {
          &amp;#34;addressPrefixes&amp;#34;: [
            &amp;#34;[parameters(&amp;#39;virtualNetworkAddressRange&amp;#39;)]&amp;#34;
          ]
        },
        &amp;#34;dhcpOptions&amp;#34;: {
          &amp;#34;dnsServers&amp;#34;: &amp;#34;[parameters(&amp;#39;DNSServerAddress&amp;#39;)]&amp;#34;
        },
        &amp;#34;subnets&amp;#34;: [
          {
            &amp;#34;name&amp;#34;: &amp;#34;[parameters(&amp;#39;subnetName&amp;#39;)]&amp;#34;,
            &amp;#34;properties&amp;#34;: {
              &amp;#34;addressPrefix&amp;#34;: &amp;#34;[parameters(&amp;#39;subnetRange&amp;#39;)]&amp;#34;
            }
          }
        ]
      }
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The above template is just another ARM JSON template. It has the same syntax. We have defined parameters that are needed for updating the virtual network to use the custom DNS that we just configured. let us save this as &lt;em&gt;vnet-with-dns-server.json&lt;/em&gt; and store it at a location that is accessible to the ARM deployment engine. I chose to store it in a &lt;a href=&#34;https://github.com/rchaganti/azure-quickstart-templates/blob/master/201-vm-domain-join/vnet-with-dns-server.json&#34;&gt;public Github repository&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Now, we need to link this template to the main ARM template that we have been authoring. Here is how it is done in the main template.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;{
    &amp;#34;apiVersion&amp;#34;: &amp;#34;2015-01-01&amp;#34;,
    &amp;#34;type&amp;#34;: &amp;#34;Microsoft.Resources/deployments&amp;#34;,
    &amp;#34;name&amp;#34;: &amp;#34;updatevnetdns&amp;#34;,
    &amp;#34;dependsOn&amp;#34;: [
        &amp;#34;[concat(&amp;#39;Microsoft.Compute/virtualMachines/&amp;#39;, parameters(&amp;#39;dcVMName&amp;#39;),&amp;#39;/extensions/createadforest&amp;#39;)]&amp;#34;
    ],
    &amp;#34;properties&amp;#34;: {
        &amp;#34;mode&amp;#34;: &amp;#34;Incremental&amp;#34;,
        &amp;#34;templateLink&amp;#34;: {
            &amp;#34;uri&amp;#34;: &amp;#34;[concat(parameters(&amp;#39;assetLocation&amp;#39;),&amp;#39;/vnet-with-dns-server.json&amp;#39;)]&amp;#34;,
            &amp;#34;contentVersion&amp;#34;: &amp;#34;1.0.0.0&amp;#34;
        },
        &amp;#34;parameters&amp;#34;: {
            &amp;#34;virtualNetworkName&amp;#34;: {
                &amp;#34;value&amp;#34;: &amp;#34;[parameters(&amp;#39;vNetName&amp;#39;)]&amp;#34;
            },
            &amp;#34;virtualNetworkAddressRange&amp;#34;: {
                &amp;#34;value&amp;#34;: &amp;#34;[variables(&amp;#39;vNetPrefix&amp;#39;)]&amp;#34;
            },
            &amp;#34;subnetName&amp;#34;: {
                &amp;#34;value&amp;#34;: &amp;#34;[variables(&amp;#39;vNetSubnet1Name&amp;#39;)]&amp;#34;
            },
            &amp;#34;subnetRange&amp;#34;: {
                &amp;#34;value&amp;#34;: &amp;#34;[variables(&amp;#39;vNetSubnet1Prefix&amp;#39;)]&amp;#34;
            },
            &amp;#34;DNSServerAddress&amp;#34;: {
                &amp;#34;value&amp;#34;: [
                    &amp;#34;[variables(&amp;#39;dnsServerPrivateIp&amp;#39;)]&amp;#34;
                ]
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Within this resource instance, we defined a dependency (line number 6) on the PowerShell DSC extension that creates the AD forest. We don’t want the linked template to execute until the DNS service is created in the DC VM. Line number 11 defines the link our external template that will configure the custom DNS settings. _vnet-with-dns-server.json _has a few parameters defined for collecting required custom DNS configuration.&lt;/p&gt;
&lt;p&gt;Within the main template, we need to pass the parameter values to the external template. This is done using the parameters element within the &lt;em&gt;Microsoft.Resources/deployments&lt;/em&gt; resource instance. For the parameter values, we use either what is already gathered from the user using the main template or what is defined in the variables element of the main template. This is how state can be shared between multiple templates. If we need to return some data from the linked template to the main template, we can do so using the outputs element within the linked template. In our scenario, we don’t need any information from the linked template and therefore we will not use the outputs element.&lt;/p&gt;
&lt;p&gt;Also, notice line number 9. The mode property within the properties element is set to incremental. This is needed because we already have some of the components within the template deployed. By setting the deployment mode to incremental, we tell the deployment engine to add the new resources or update existing resource configuration within the resource group without deleting any existing resources in the group. In our example, we are updating the configuration of an existing virtual network to use the custom DNS. so, the incremental deployment mode is necessary here.&lt;/p&gt;

    &lt;a href=&#34;https://portal.azure.com/#create/Microsoft.Template/uri/https%3a%2f%2fportal.azure.com%2f%23create%2fMicrosoft.Template%2furi%2fhttps%253A%252F%252Fraw.githubusercontent.com%252Frchaganti%252Farmseries%252Fmaster%252Farm-series_Storage-VirtualNet-LinkedTemplate-DNS_Update.json&#34; target=&#34;_blank&#34;&gt;
        &lt;img src=&#34;https://raw.githubusercontent.com/Azure/azure-quickstart-templates/master/1-CONTRIBUTION-GUIDE/images/deploytoazure.svg?sanitize=true&#34; alt=&#34;&#34;&gt;
    &lt;/a&gt;
    &lt;br /&gt;

&lt;figure&gt;
    &lt;img src=&#34;https://ravichaganti.com/images/armtemplate7-3.png&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;Once you deploy this updated template, you will see that the virtual network within the resource group gets set to use the custom DNS deployed using the PowerShell DSC extension.&lt;/p&gt;
&lt;p&gt;In the next part of this series, we will look at adding more virtual machines to the deployment based on the &lt;em&gt;environmentType&lt;/em&gt; selected within the template parameters. By the end of next part, we will completely functional ARM template that deploys our scenario end to end.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Building Azure Resource Manager Templates – Defining Resource Dependencies</title>
      <link>https://ravichaganti.com/blog/building-azure-resource-manager-templates-defining-resource-dependencies/</link>
      <pubDate>Tue, 08 Dec 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ravichaganti.com/blog/building-azure-resource-manager-templates-defining-resource-dependencies/</guid>
      <description>&lt;p&gt;We will continue learning about building ARM templates by looking at how we can define dependencies between resources. To recap, here is the scenario we are working on.&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&#34;https://ravichaganti.com/images/armtemplate6-1.png&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;In the earlier parts of this series, we created the storage account, virtual network, a public IP, a load balancer, and added all inbound NAT rules required for the virtual machine RDP access. If you notice, we have components that depend on others. For example, the inbound NAT rules depend on the load balancer. Similarly, VMs depend on network interfaces which in turn depend on the virtual network. In the absence of dependencies, ARM will attempt to deploy these resources in parallel which may result in errors. So, within the resource template, we need to define these dependencies so that ARM can make decisions about the deployment sequence. There are multiple ways of doing this.&lt;/p&gt;
&lt;h4 id=&#34;using-dependson&#34;&gt;Using DependsOn&lt;/h4&gt;
&lt;p&gt;If you have noticed in the earlier parts of this series, we have used &lt;em&gt;DependsOn&lt;/em&gt; property within the resource element.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;{
    &amp;#34;apiVersion&amp;#34;: &amp;#34;2015-06-15&amp;#34;,
    &amp;#34;type&amp;#34;: &amp;#34;Microsoft.Network/loadBalancers/inboundNatRules&amp;#34;,
    &amp;#34;copy&amp;#34;: {
        &amp;#34;name&amp;#34;: &amp;#34;lbRdpNatLoop&amp;#34;,
        &amp;#34;count&amp;#34;: &amp;#34;[variables(&amp;#39;selectedDeployment&amp;#39;).instancesCount]&amp;#34;
    },
    &amp;#34;name&amp;#34;: &amp;#34;[concat(&amp;#39;/loadbalancer/&amp;#39;,&amp;#39;VM-&amp;#39;, copyIndex(1),&amp;#39;-RDP&amp;#39;)]&amp;#34;,
    &amp;#34;location&amp;#34;: &amp;#34;[resourceGroup().location]&amp;#34;,
    &amp;#34;dependsOn&amp;#34;: [
        &amp;#34;Microsoft.Network/loadBalancers/loadBalancer&amp;#34;
    ],
    &amp;#34;properties&amp;#34;: {
        &amp;#34;frontendIPConfiguration&amp;#34;: {
            &amp;#34;id&amp;#34;: &amp;#34;[resourceId(&amp;#39;Microsoft.Network/loadBalancers/frontendIPConfigurations&amp;#39;,&amp;#39;loadBalancer&amp;#39;,variables(&amp;#39;lbFrontend&amp;#39;))]&amp;#34;
        },
        &amp;#34;protocol&amp;#34;: &amp;#34;tcp&amp;#34;,
        &amp;#34;frontendPort&amp;#34;: &amp;#34;[add(3389, copyIndex(1))]&amp;#34;,
        &amp;#34;backendPort&amp;#34;: 3389,
        &amp;#34;enableFloatingIP&amp;#34;: false
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;If you look at line number 11, we added &lt;em&gt;DependsOn&lt;/em&gt; property to define that the &lt;em&gt;inboundNatRules&lt;/em&gt; depend on the load balancer configuration. This is straightforward and very easy to define. You can use template language functions such as &lt;em&gt;ResourceId()&lt;/em&gt; or &lt;em&gt;concat()&lt;/em&gt; as well within the value of &lt;em&gt;DependsOn&lt;/em&gt; and dynamically build these dependencies. You can provide more than one value here as a comma-separated list.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&amp;#34;dependsOn&amp;#34;: [
    &amp;#34;Microsoft.Network/loadBalancers/loadBalancer&amp;#34;,
    &amp;#34;Microsoft.Network/virtualNetworks/vNet1&amp;#34;
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;using-references&#34;&gt;Using References&lt;/h4&gt;
&lt;p&gt;The second method is to define reference to the dependent resource. Let us create a virtual network interface the AD VM in our scenario. This depends on the virtual network resource that we already created.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;{
    &amp;#34;apiVersion&amp;#34;: &amp;#34;2015-05-01-preview&amp;#34;,
    &amp;#34;type&amp;#34;: &amp;#34;Microsoft.Network/networkInterfaces&amp;#34;,
    &amp;#34;name&amp;#34;: &amp;#34;dcvmnif&amp;#34;,
    &amp;#34;location&amp;#34;: &amp;#34;[resourceGroup().location]&amp;#34;,
    &amp;#34;properties&amp;#34;: {
        &amp;#34;ipConfigurations&amp;#34;: [
            {
                &amp;#34;name&amp;#34;: &amp;#34;[concat(reference(parameters(&amp;#39;vNetName&amp;#39;)).subnets[0].name,parameters(&amp;#39;dcVmName&amp;#39;),&amp;#39;-nifconfig&amp;#39;)]&amp;#34;,
                &amp;#34;properties&amp;#34;: {
                    &amp;#34;privateIPAllocationMethod&amp;#34;: &amp;#34;Static&amp;#34;,
                    &amp;#34;privateIPAddress&amp;#34;: &amp;#34;[variables(&amp;#39;dnsServerPrivateIp&amp;#39;)]&amp;#34;,
                    &amp;#34;subnet&amp;#34;: {
                        &amp;#34;id&amp;#34;: &amp;#34;[variables(&amp;#39;vNetSubnet1ID&amp;#39;)]&amp;#34;
                    }
                }
            }
        ]
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Observe line number 9. We used the reference() function to get a reference to the virtual network object we created and get the subnet name from there and use it to construct the &lt;em&gt;IPConfiguration&lt;/em&gt; name. When ARM engine finds this reference, it creates an implicit dependency on the virtual network that we referenced. There is no need here to specify &lt;em&gt;DependsOn&lt;/em&gt; property.&lt;/p&gt;
&lt;p&gt;Note that we cannot use the reference() function as a part of the resource instance name. This is because the ARM engine must know the names of the resource instances before the deployment can start.&lt;/p&gt;
&lt;h4 id=&#34;child-or-nested-resources&#34;&gt;Child or Nested Resources&lt;/h4&gt;
&lt;p&gt;The 3rd way to define dependencies is to use child resources. Let us see an example before we discuss this further.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;{
    &amp;#34;apiVersion&amp;#34;: &amp;#34;2015-06-15&amp;#34;,
    &amp;#34;type&amp;#34;: &amp;#34;Microsoft.Compute/virtualMachines&amp;#34;,
    &amp;#34;name&amp;#34;: &amp;#34;[Parameters(&amp;#39;dcVMName&amp;#39;)]&amp;#34;,
    &amp;#34;location&amp;#34;: &amp;#34;[resourceGroup().location]&amp;#34;,
    &amp;#34;dependsOn&amp;#34;: [
        &amp;#34;[resourceId(&amp;#39;Microsoft.Storage/storageAccounts&amp;#39;,parameters(&amp;#39;storageAccount&amp;#39;))]&amp;#34;,
        &amp;#34;[resourceId(&amp;#39;Microsoft.Network/networkInterfaces&amp;#39;,concat(parameters(&amp;#39;dcVMName&amp;#39;),&amp;#39;-nif&amp;#39;))]&amp;#34;
    ],
    &amp;#34;properties&amp;#34;: {
        &amp;#34;hardwareProfile&amp;#34;: {
            &amp;#34;vmSize&amp;#34;: &amp;#34;[parameters(&amp;#39;vmSize&amp;#39;)]&amp;#34;
        },
        &amp;#34;osProfile&amp;#34;: {
            &amp;#34;computerName&amp;#34;: &amp;#34;[parameters(&amp;#39;dcVMName&amp;#39;)]&amp;#34;,
            &amp;#34;adminUsername&amp;#34;: &amp;#34;[parameters(&amp;#39;adminUsername&amp;#39;)]&amp;#34;,
            &amp;#34;adminPassword&amp;#34;: &amp;#34;[parameters(&amp;#39;adminPassword&amp;#39;)]&amp;#34;
        },
        &amp;#34;storageProfile&amp;#34;: {
            &amp;#34;imageReference&amp;#34;: {
                &amp;#34;publisher&amp;#34;: &amp;#34;[variables(&amp;#39;imagePublisher&amp;#39;)]&amp;#34;,
                &amp;#34;offer&amp;#34;: &amp;#34;[variables(&amp;#39;imageOffer&amp;#39;)]&amp;#34;,
                &amp;#34;sku&amp;#34;: &amp;#34;[parameters(&amp;#39;windowsOSVersion&amp;#39;)]&amp;#34;,
                &amp;#34;version&amp;#34;: &amp;#34;latest&amp;#34;
            },
            &amp;#34;osDisk&amp;#34;: {
                &amp;#34;name&amp;#34;: &amp;#34;[concat(parameters(&amp;#39;dcVMName&amp;#39;), &amp;#39;-osdisk.vhd&amp;#39;)]&amp;#34;,
                &amp;#34;vhd&amp;#34;: {
                    &amp;#34;uri&amp;#34;: &amp;#34;[concat(&amp;#39;http://&amp;#39;,parameters(&amp;#39;storageAccount&amp;#39;),&amp;#39;.blob.core.windows.net/vhds/&amp;#39;, parameters(&amp;#39;dcVMName&amp;#39;), &amp;#39;-osdisk.vhd&amp;#39;)]&amp;#34;
                },
                &amp;#34;caching&amp;#34;: &amp;#34;ReadWrite&amp;#34;,
                &amp;#34;createOption&amp;#34;: &amp;#34;FromImage&amp;#34;
            },
            &amp;#34;dataDisks&amp;#34;: [
                {
                    &amp;#34;name&amp;#34;: &amp;#34;[concat(parameters(&amp;#39;dcVMName&amp;#39;), &amp;#39;-data-disk1.vhd&amp;#39;)]&amp;#34;,
                    &amp;#34;vhd&amp;#34;: {
                        &amp;#34;uri&amp;#34;: &amp;#34;[concat(&amp;#39;http://&amp;#39;,parameters(&amp;#39;storageAccount&amp;#39;),&amp;#39;.blob.core.windows.net/vhds/&amp;#39;, parameters(&amp;#39;dcVMName&amp;#39;), &amp;#39;-data-disk1.vhd&amp;#39;)]&amp;#34;
                    },
                    &amp;#34;caching&amp;#34;: &amp;#34;None&amp;#34;,
                    &amp;#34;createOption&amp;#34;: &amp;#34;Empty&amp;#34;,
                    &amp;#34;diskSizeGB&amp;#34;: &amp;#34;1000&amp;#34;,
                    &amp;#34;lun&amp;#34;: 0
                }
            ]
        },
        &amp;#34;networkProfile&amp;#34;: {
            &amp;#34;networkInterfaces&amp;#34;: [
                {
                    &amp;#34;id&amp;#34;: &amp;#34;[resourceId(&amp;#39;Microsoft.Network/networkInterfaces&amp;#39;,concat(parameters(&amp;#39;dcVMName&amp;#39;),&amp;#39;-nif&amp;#39;))]&amp;#34;
                }
            ]
        },
        &amp;#34;diagnosticsProfile&amp;#34;: {
            &amp;#34;bootDiagnostics&amp;#34;: {
                &amp;#34;enabled&amp;#34;: &amp;#34;true&amp;#34;,
                &amp;#34;storageUri&amp;#34;: &amp;#34;[concat(&amp;#39;http://&amp;#39;,parameters(&amp;#39;storageAccount&amp;#39;),&amp;#39;.blob.core.windows.net&amp;#39;)]&amp;#34;
            }
        }
    },
    &amp;#34;resources&amp;#34;: [
        {
            &amp;#34;type&amp;#34;: &amp;#34;extensions&amp;#34;,
            &amp;#34;name&amp;#34;: &amp;#34;createadforest&amp;#34;,
            &amp;#34;apiVersion&amp;#34;: &amp;#34;2015-05-01-preview&amp;#34;,
            &amp;#34;location&amp;#34;: &amp;#34;[resourceGroup().location]&amp;#34;,
            &amp;#34;dependsOn&amp;#34;: [
                &amp;#34;[concat(&amp;#39;Microsoft.Compute/virtualMachines/&amp;#39;,parameters(&amp;#39;dcVMName&amp;#39;))]&amp;#34;
            ],
            &amp;#34;properties&amp;#34;: {
                &amp;#34;publisher&amp;#34;: &amp;#34;Microsoft.Powershell&amp;#34;,
                &amp;#34;type&amp;#34;: &amp;#34;DSC&amp;#34;,
                &amp;#34;typeHandlerVersion&amp;#34;: &amp;#34;2.8&amp;#34;,
                &amp;#34;settings&amp;#34;: {
                    &amp;#34;ModulesUrl&amp;#34;: &amp;#34;[concat(parameters(&amp;#39;assetLocation&amp;#39;),&amp;#39;/Configuration.zip&amp;#39;)]&amp;#34;,
                    &amp;#34;ConfigurationFunction&amp;#34;: &amp;#34;CreateADPDC.ps1\\CreateADPDC&amp;#34;,
                    &amp;#34;Properties&amp;#34;: {
                        &amp;#34;DomainName&amp;#34;: &amp;#34;[parameters(&amp;#39;adDomainName&amp;#39;)]&amp;#34;,
                        &amp;#34;AdminCreds&amp;#34;: {
                            &amp;#34;UserName&amp;#34;: &amp;#34;[parameters(&amp;#39;adminUsername&amp;#39;)]&amp;#34;,
                            &amp;#34;Password&amp;#34;: &amp;#34;PrivateSettingsRef:AdminPassword&amp;#34;
                        }
                    }
                },
                &amp;#34;protectedSettings&amp;#34;: {
                    &amp;#34;Items&amp;#34;: {
                        &amp;#34;AdminPassword&amp;#34;: &amp;#34;[parameters(&amp;#39;adminPassword&amp;#39;)]&amp;#34;
                    }
                }
            }
        }
    ]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This example is quite long. It is the virtual machine resource instance that we need for the domain controller. Apart from all the virtual machine properties such as storage profile and OS profile, we have something interesting at line number 61. We have another resources element within the VM resource definition. As with the top-level resources element, this is also a JSON array and contains the resource definition for the &lt;a href=&#34;http://www.powershellmagazine.com/2014/08/05/understanding-azure-vm-dsc-extension/&#34;&gt;VM DSC extension&lt;/a&gt;. It is obvious that VM DSC extension without a VM is meaningless. By defining this as a child or nested resource inside the VM resource definition, we are creating an implicit dependency between the VM and the VM DSC extension. When ARM engine looks at this in the template, it schedules VM creation before the DSC extension. BTW, this VM DSC extension has the DSC configuration required to build the domain controller in this deployment.&lt;/p&gt;
&lt;p&gt;Always make sure you that you create enough flexibility within the template for someone else to take this and deploy the template in their own environment.To this extent, I have used a parameter called &lt;em&gt;assetLocation&lt;/em&gt; (line 75) in the DSC extension properties. You can call this whatever you want. This parameter specifies where all the template assets such as DSC configuration scripts and any additional template files are stored.&lt;/p&gt;
&lt;p&gt;So far in this part, we have seen three different ways of defining dependencies between resources. If you check the template that we &lt;a href=&#34;https://github.com/rchaganti/armseries/blob/master/arm-series_Storage-VirtualNet-LB_vNIC-VM.json&#34;&gt;built so far for this scenario&lt;/a&gt;, you will observe that I have added a few more variables and parameters needed for the DC VM and its configuration.&lt;/p&gt;
&lt;p&gt;Go ahead and deploy this.&lt;/p&gt;

    &lt;a href=&#34;https://portal.azure.com/#create/Microsoft.Template/uri/https%3a%2f%2fportal.azure.com%2f%23create%2fMicrosoft.Template%2furi%2fhttps%253A%252F%252Fraw.githubusercontent.com%252Frchaganti%252Farmseries%252Fmaster%252Farm-series_Storage-VirtualNet-LB_vNIC-VM.json&#34; target=&#34;_blank&#34;&gt;
        &lt;img src=&#34;https://raw.githubusercontent.com/Azure/azure-quickstart-templates/master/1-CONTRIBUTION-GUIDE/images/deploytoazure.svg?sanitize=true&#34; alt=&#34;&#34;&gt;
    &lt;/a&gt;
    &lt;br /&gt;

&lt;p&gt;In the next part, we will look at the nested template deployments.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Building Azure Resource Manager Templates – Using Copy Object</title>
      <link>https://ravichaganti.com/blog/building-azure-resource-manager-templates-using-copy-object/</link>
      <pubDate>Tue, 17 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ravichaganti.com/blog/building-azure-resource-manager-templates-using-copy-object/</guid>
      <description>&lt;p&gt;If you are following this series, by now you know how to use parameters and variables in ARM template language. We used that knowledge to create a template that creates relevant things to like storage account and virtual network. Let us revisit the scenario.&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&#34;https://ravichaganti.com/images/armtemplate5-1.png&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;In this part, we will extend the template to add publicIP, load balancer, and RDP endpoints for the virtual machines. Before we do that, let us review what we need. To achieve what we want in this, we will use copy object in the template.&lt;/p&gt;
&lt;h4 id=&#34;what-iscopy-object&#34;&gt;What is Copy Object?&lt;/h4&gt;
&lt;p&gt;In our template, we already have the storage account and virtual network configuration defined. What we now need is a load balancer with a public IP so that we can access this deployment from the Internet. Also, we need the inbound NAT rules for enabling RDP access to the VMs in this deployment. But before we create the RDP rules for each VM, we need to know how many VM instances we are deploying. As shown in the scenario diagram, we need to be able to deploy this template within development, test, or production environment. Depending on the selected environment, we will have one AD DC VM along with 1 (development) or 2 (test) or 3 (production) VMs that join the AD domain. Therefore, we need a way to capture the environment type as an input parameter. Also, based on the environment type selected by the user, we need to decide on the number of VM instances required for the deployment and then create only relevant number of inbound NAT rules within the load balancer.&lt;/p&gt;
&lt;p&gt;There are multiple ways to achieve this.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Add multiple resource definitions; one for each resource instance we need. This does not give the flexibility to dynamically add or remove instances based on the VM count we need. This method is not efficient.&lt;/li&gt;
&lt;li&gt;Use some kind of iterator, like other programming languages, within a resource definition and tell ARM how many resource instances we need. This can be achieved using copy object technique in ARM templates.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Before we go to the copy object discussion, let us first add more parameters and variables that are needed for this template. These additional parameters will also help us with defining the iteration count within the copy object.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;parameters&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f00&#34;&gt;:&lt;/span&gt; {
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;storageAccount&amp;#34;&lt;/span&gt;: {
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;string&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;metadata&amp;#34;&lt;/span&gt;: {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;description&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Unique name for the storage account.&amp;#34;&lt;/span&gt;
        }
    },
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;storageAccountType&amp;#34;&lt;/span&gt;: {
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;string&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;defaultValue&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Standard_LRS&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;allowedValues&amp;#34;&lt;/span&gt;: [
            &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Standard_LRS&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Standard_GRS&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Standard_ZRS&amp;#34;&lt;/span&gt;
        ],
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;metadata&amp;#34;&lt;/span&gt;: {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;description&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Account type based on the storage redundancy requirements.&amp;#34;&lt;/span&gt;
        }
    },
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;vNetName&amp;#34;&lt;/span&gt;: {
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;string&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;metadata&amp;#34;&lt;/span&gt;: {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;description&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Name for the virtual network.&amp;#34;&lt;/span&gt;
        }
    },
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;DnsName&amp;#34;&lt;/span&gt;: {
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;string&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;metadata&amp;#34;&lt;/span&gt;: {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;description&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Unique public DNS prefix for the deployment. The fqdn will look something like &amp;#39;&amp;amp;lt;dnsname&amp;amp;gt;.westus.cloudapp.azure.com&amp;#39;.&amp;#34;&lt;/span&gt;
        }
    },
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;environmentType&amp;#34;&lt;/span&gt;: {
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;string&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;allowedValues&amp;#34;&lt;/span&gt;: [
            &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Development&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Test&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Production&amp;#34;&lt;/span&gt;
        ],
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;defaultValue&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Development&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;metadata&amp;#34;&lt;/span&gt;: {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;description&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Type of environment where this deployment should occur. This has an impact on the number of VMs to be depoloyed.&amp;#34;&lt;/span&gt;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Within the new parameters, we have the &lt;em&gt;dnsName&lt;/em&gt; parameter that will be for external access. The &lt;em&gt;environmentType&lt;/em&gt; parameter is used to capture whether the user is deploying this template for dev, test, or production. However, based on this selection, we need a way to find out the number of VMs we need in the domain. That is, we need know the instance count for each environment. Remember our discussion on free-form vs known configurations? We don’t want to leave such choices to the end user. So, the place where this decision can be made will be in the variables element.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;variables&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f00&#34;&gt;:&lt;/span&gt; {
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;vNetPrefix&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;10.0.0.0/16&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;vNetSubnet1Name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[concat(resourceGroup().Location, &amp;#39;-&amp;#39;, parameters(&amp;#39;vNetName&amp;#39;), &amp;#39;-&amp;#39;, &amp;#39;Subnet&amp;#39;)]&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;vNetSubnet1Prefix&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;10.0.0.0/24&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;vNetSubnet1ID&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[concat(resourceId(&amp;#39;Microsoft.Network/virtualNetworks&amp;#39;,parameters(&amp;#39;vNetName&amp;#39;)),&amp;#39;/subnets/&amp;#39;,variables(&amp;#39;vNetSubnet1Name&amp;#39;))]&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;dnsServerPrivateIp&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;10.0.0.8&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;deploymentSize&amp;#34;&lt;/span&gt;: {
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;Development&amp;#34;&lt;/span&gt;: {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;instancesCount&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;
        },
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;Test&amp;#34;&lt;/span&gt;: {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;instancesCount&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;
        },
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;Production&amp;#34;&lt;/span&gt;: {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;instancesCount&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;3&lt;/span&gt;
        }
    },
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;selectedDeployment&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[variables(&amp;#39;deploymentSize&amp;#39;)[parameters(&amp;#39;environmentType&amp;#39;)]]&amp;#34;&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Within the variables element, we defined new variables for making it easier to select the environment type. The &lt;em&gt;deploymentSize&lt;/em&gt; variable defines a JSON object. Within this, we are associating &lt;em&gt;instancesCount&lt;/em&gt; to every deployment type.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;deploymentSize&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f00&#34;&gt;:&lt;/span&gt; {
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;Development&amp;#34;&lt;/span&gt;: {
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;instancesCount&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;
    },
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;Test&amp;#34;&lt;/span&gt;: {
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;instancesCount&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;
    },
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;Production&amp;#34;&lt;/span&gt;: {
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;instancesCount&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;3&lt;/span&gt;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;We use the &lt;em&gt;selectedDeployment&lt;/em&gt; variable to retrieve the value of &lt;em&gt;deploymentSize&lt;/em&gt; variable. This is done by associating the value of environmentType parameter and looking up for that in the &lt;em&gt;deploymentSize&lt;/em&gt; variable.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;selectedDeployment&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f00&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[variables(&amp;#39;deploymentSize&amp;#39;)[parameters(&amp;#39;environmentType&amp;#39;)]]&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This works because &lt;em&gt;deploymentSize&lt;/em&gt; is a JSON object similar to a dictionary. We can index into it using one of the key names. So, in this case, the key names will match the value passed to the &lt;em&gt;environmentType&lt;/em&gt; parameter and indexing into that will give us the right object within _deploymentSize. _Once we have the selectedDeployment variable populated, we can access the &lt;em&gt;instancesCount&lt;/em&gt; value by dot-referencing the property name. For example,&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;[variables(&amp;#39;selectedDeployment&amp;#39;).instancesCount]&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This should not be alien to us. We use &lt;em&gt;variables()&lt;/em&gt; function and pass the &lt;em&gt;selectedDeployment&lt;/em&gt; variable name to it. The resulting object has the &lt;em&gt;instancesCount&lt;/em&gt; property which can then be retrieved using dot-referencing. Now that we figured this out, let us go back to the discussion around multiple instance creation within a template.&lt;/p&gt;
&lt;h4 id=&#34;working-with-copy-object&#34;&gt;Working with Copy Object&lt;/h4&gt;
&lt;p&gt;As stated earlier, the reason we need &lt;em&gt;instancesCount&lt;/em&gt; value is because we need to tell ARM how many times it has to iterate for creating the resource for which we need multiple instances. This is done within the &lt;a href=&#34;https://azure.microsoft.com/en-us/documentation/articles/resource-group-create-multiple/#copy-copyindex-and-length&#34;&gt;copy object syntax&lt;/a&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&amp;#34;copy&amp;#34;: { 
    &amp;#34;name&amp;#34;: &amp;#34;copy loop name&amp;#34;, 
    &amp;#34;count&amp;#34;: &amp;#34;integer value&amp;#34; 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The &lt;em&gt;name&lt;/em&gt; property within the &lt;em&gt;copy&lt;/em&gt; element defines a name for the iterator which can later be used for defining dependencies. The _count _property defines the number of times the iterator has to run. In our case, we will set the value of count property to the &lt;em&gt;instancesCount&lt;/em&gt; value we retrieve from the &lt;em&gt;selectedDeployment.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;We place this inside the resource definition. In our scenario, we will use the copy object within &lt;em&gt;Microsoft.Network/loadBalancers/inboundNatRules&lt;/em&gt; resource type. Let us first see the new resources that we need to enable public IP and load balancer configuration. We will then review the resource definition to understand how we use the copy object.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;resources&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f00&#34;&gt;:&lt;/span&gt; [
    {
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[parameters(&amp;#39;storageAccountName&amp;#39;)]&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Microsoft.Storage/storageAccounts&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;location&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[ResourceGroup().Location]&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;apiVersion&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;2015-05-01-preview&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;properties&amp;#34;&lt;/span&gt;: {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;accountType&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[parameters(&amp;#39;storageAccountType&amp;#39;)]&amp;#34;&lt;/span&gt;
        }
    },
    {
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[parameters(&amp;#39;vNetName&amp;#39;)]&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Microsoft.Network/virtualNetworks&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;location&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[ResourceGroup().Location]&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;apiVersion&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;2015-05-01-preview&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;properties&amp;#34;&lt;/span&gt;: {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;addressSpace&amp;#34;&lt;/span&gt;: {
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;addressPrefixes&amp;#34;&lt;/span&gt;: [
                    &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[variables(&amp;#39;vNetPrefix&amp;#39;)]&amp;#34;&lt;/span&gt;
                ]
            },
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;subnets&amp;#34;&lt;/span&gt;: [
                {
                    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[variables(&amp;#39;vNetSubnet1Name&amp;#39;)]&amp;#34;&lt;/span&gt;,
                    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;properties&amp;#34;&lt;/span&gt;: {
                        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;addressPrefix&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[variables(&amp;#39;vNetSubnet1Prefix&amp;#39;)]&amp;#34;&lt;/span&gt;
                    }
                }
            ]
        }
    },
    {
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;apiVersion&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;2015-05-01-preview&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Microsoft.Network/publicIPAddresses&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;publicIp&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;location&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[resourceGroup().location]&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;properties&amp;#34;&lt;/span&gt;: {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;publicIPAllocationMethod&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Dynamic&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;dnsSettings&amp;#34;&lt;/span&gt;: {
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;domainNameLabel&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[parameters(&amp;#39;DnsName&amp;#39;)]&amp;#34;&lt;/span&gt;
            }
        }
    },
    {
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;apiVersion&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;2015-05-01-preview&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;loadBalancer&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Microsoft.Network/loadBalancers&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;location&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[resourceGroup().location]&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;dependsOn&amp;#34;&lt;/span&gt;: [
            &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Microsoft.Network/publicIPAddresses/publicIp&amp;#34;&lt;/span&gt;
        ],
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;properties&amp;#34;&lt;/span&gt;: {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;frontendIPConfigurations&amp;#34;&lt;/span&gt;: [
                {
                    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[variables(&amp;#39;lbFrontend&amp;#39;)]&amp;#34;&lt;/span&gt;,
                    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;properties&amp;#34;&lt;/span&gt;: {
                        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;publicIPAddress&amp;#34;&lt;/span&gt;: {
                            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;id&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[resourceId(&amp;#39;Microsoft.Network/publicIPAddresses&amp;#39;,&amp;#39;publicIp&amp;#39;)]&amp;#34;&lt;/span&gt;
                        }
                    }
                }
            ],
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;backendAddressPools&amp;#34;&lt;/span&gt;: [
                {
                    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[variables(&amp;#39;lbBackendAddrPool&amp;#39;)]&amp;#34;&lt;/span&gt;
                }
            ]
        }
    },
    {
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;apiVersion&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;2015-06-15&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Microsoft.Network/loadBalancers/inboundNatRules&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;copy&amp;#34;&lt;/span&gt;: {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;lbRdpNatLoop&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;count&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[variables(&amp;#39;selectedDeployment&amp;#39;).instancesCount]&amp;#34;&lt;/span&gt;
        },
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[concat(&amp;#39;/loadbalancer/&amp;#39;,&amp;#39;VM-&amp;#39;, copyIndex(1),&amp;#39;-RDP&amp;#39;)]&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;location&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[resourceGroup().location]&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;dependsOn&amp;#34;&lt;/span&gt;: [
            &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[concat(&amp;#39;Microsoft.Network/loadBalancers/loadBalancer&amp;#39;)]&amp;#34;&lt;/span&gt;
        ],
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;properties&amp;#34;&lt;/span&gt;: {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;frontendIPConfiguration&amp;#34;&lt;/span&gt;: {
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;id&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[resourceId(&amp;#39;Microsoft.Network/loadBalancers/frontendIPConfigurations&amp;#39;,&amp;#39;loadBalancer&amp;#39;,variables(&amp;#39;lbFrontend&amp;#39;))]&amp;#34;&lt;/span&gt;
            },
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;protocol&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;tcp&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;frontendPort&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[add(3389, copyIndex(1))]&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;backendPort&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;3389&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;enableFloatingIP&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;false&lt;/span&gt;
        }
    }
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In this updated resource collection, we have added three resource types. A public IP address to assign it to the load balancer, a load balancer that will act as a container for the VM endpoints, and finally, RDP endpoints based on the number of VM instances we need.&lt;/p&gt;
&lt;p&gt;Observe the highlighted lines in the resource collection. The copy object that we used within the inboundNATRules resource type tells ARM how many instances we need to create based on the VM count we need.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&amp;#34;copy&amp;#34;: {
    &amp;#34;name&amp;#34;: &amp;#34;lbRdpNatLoop&amp;#34;,
    &amp;#34;count&amp;#34;: &amp;#34;[variables(&amp;#39;selectedDeployment&amp;#39;).instancesCount]&amp;#34;
},
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Within an ARM template, for each resource type and its instances, the &lt;em&gt;name&lt;/em&gt; property should carry a unique value. Without this, you will see an error during deployment that multiple instances cannot use the same name. So, if you look at line number 77, we are dynamically constructing the value for &lt;em&gt;name.&lt;/em&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&amp;#34;name&amp;#34;: &amp;#34;[concat(&amp;#39;/loadbalancer/&amp;#39;,&amp;#39;VM-&amp;#39;, copyIndex(1),&amp;#39;-RDP&amp;#39;)]&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As you see here, we are concatenating ‘/loadbalancer/’ with ‘VM-‘ and then using the &lt;a href=&#34;https://azure.microsoft.com/en-us/documentation/articles/resource-group-template-functions/#copyindex&#34;&gt;&lt;em&gt;copyIndex()&lt;/em&gt;&lt;/a&gt; function and finally add ‘-RDP’. The &lt;em&gt;copyIndex()&lt;/em&gt; function gives us the iteration number. So, if we are creating three VM endpoints within this resource definition, we get iteration values 0, 1, and 2. The index always starts from 0. However, if we want to offset it to different value than zero, we can specify the value inside the &lt;em&gt;copyIndex()&lt;/em&gt; function. In my example, I am using 1 so that the values the template receives will be 1, 2, and 3. Since we are using the iteration number within the name value, we always get an unique identifier.&lt;/p&gt;
&lt;p&gt;Another function that we are using within this template update is the &lt;em&gt;&lt;a href=&#34;https://azure.microsoft.com/en-us/documentation/articles/resource-group-template-functions/#add&#34;&gt;add()&lt;/a&gt;&lt;/em&gt; function. This function, as its name suggests, adds integers. I am using this function to dynamically derive the frontend port number for the VM RDP endpoint.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&amp;#34;frontendPort&amp;#34;: &amp;#34;[add(3389, copyIndex(1))]&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;We are doing this since all VM RDP endpoints should be accessible through the load balancer. By using add function, we are adding the iteration value to the RDP port (3389) to derive a unique value.&lt;/p&gt;
&lt;p&gt;Now that we have completed our discussion on the copy object and its usage, let us move on to see the ARM template update that creates storage account, virtual network, public IP, load balancer, and finally the VM RDP endpoints. We are not creating an RDP endpoint for the DC VM.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;{
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;$schema&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;https://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;contentVersion&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;1.0.0.0&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;parameters&amp;#34;&lt;/span&gt;: {
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;storageAccountName&amp;#34;&lt;/span&gt;: {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;string&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;metadata&amp;#34;&lt;/span&gt;: {
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;description&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Unique name for the storage account.&amp;#34;&lt;/span&gt;
            }
        },
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;storageAccountType&amp;#34;&lt;/span&gt;: {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;string&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;defaultValue&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Standard_LRS&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;allowedValues&amp;#34;&lt;/span&gt;: [
                &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Standard_LRS&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Standard_GRS&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Standard_ZRS&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Premium_LRS&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Standard_RAGRS&amp;#34;&lt;/span&gt;
            ],
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;metadata&amp;#34;&lt;/span&gt;: {
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;description&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Account type based on the storage redundancy requirements.&amp;#34;&lt;/span&gt;
            }
        },
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;vNetName&amp;#34;&lt;/span&gt;: {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;string&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;metadata&amp;#34;&lt;/span&gt;: {
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;description&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Name for the virtual network.&amp;#34;&lt;/span&gt;
            }
        },
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;DnsName&amp;#34;&lt;/span&gt;: {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;string&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;metadata&amp;#34;&lt;/span&gt;: {
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;description&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Unique public DNS prefix for the deployment. The fqdn will look something like &amp;#39;&amp;amp;lt;dnsname&amp;amp;gt;.westus.cloudapp.azure.com&amp;#39;.&amp;#34;&lt;/span&gt;
            }
        },
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;environmentType&amp;#34;&lt;/span&gt;: {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;string&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;allowedValues&amp;#34;&lt;/span&gt;: [
                &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Development&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Test&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Production&amp;#34;&lt;/span&gt;
            ],
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;defaultValue&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Development&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;metadata&amp;#34;&lt;/span&gt;: {
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;description&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Type of environment where this deployment should occur. This has an impact on the number of VMs to be depoloyed.&amp;#34;&lt;/span&gt;
            }
        }
    },
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;variables&amp;#34;&lt;/span&gt;: {
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;vNetPrefix&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;10.0.0.0/16&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;vNetSubnet1Name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[concat(resourceGroup().Location, &amp;#39;-&amp;#39;, parameters(&amp;#39;vNetName&amp;#39;), &amp;#39;-&amp;#39;, &amp;#39;Subnet&amp;#39;)]&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;vNetSubnet1Prefix&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;10.0.0.0/24&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;vNetSubnet1ID&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[concat(resourceId(&amp;#39;Microsoft.Network/virtualNetworks&amp;#39;,parameters(&amp;#39;vNetName&amp;#39;)),&amp;#39;/subnets/&amp;#39;,variables(&amp;#39;vNetSubnet1Name&amp;#39;))]&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;dnsServerPrivateIp&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;10.0.0.8&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;lbFrontend&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;lbFrontEnd&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;lbBackendAddrPool&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;lbBackEndPool&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;deploymentSize&amp;#34;&lt;/span&gt;: {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;Development&amp;#34;&lt;/span&gt;: {
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;instancesCount&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;
            },
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;Test&amp;#34;&lt;/span&gt;: {
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;instancesCount&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;
            },
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;Production&amp;#34;&lt;/span&gt;: {
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;instancesCount&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;3&lt;/span&gt;
            }
        },
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;selectedDeployment&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[variables(&amp;#39;deploymentSize&amp;#39;)[parameters(&amp;#39;environmentType&amp;#39;)]]&amp;#34;&lt;/span&gt;
    },
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;resources&amp;#34;&lt;/span&gt;: [
        {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[parameters(&amp;#39;storageAccountName&amp;#39;)]&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Microsoft.Storage/storageAccounts&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;location&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[ResourceGroup().Location]&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;apiVersion&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;2015-05-01-preview&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;properties&amp;#34;&lt;/span&gt;: {
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;accountType&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[parameters(&amp;#39;storageAccountType&amp;#39;)]&amp;#34;&lt;/span&gt;
            }
        },
        {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[parameters(&amp;#39;vNetName&amp;#39;)]&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Microsoft.Network/virtualNetworks&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;location&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[ResourceGroup().Location]&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;apiVersion&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;2015-05-01-preview&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;properties&amp;#34;&lt;/span&gt;: {
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;addressSpace&amp;#34;&lt;/span&gt;: {
                    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;addressPrefixes&amp;#34;&lt;/span&gt;: [
                        &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[variables(&amp;#39;vNetPrefix&amp;#39;)]&amp;#34;&lt;/span&gt;
                    ]
                },
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;subnets&amp;#34;&lt;/span&gt;: [
                    {
                        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[variables(&amp;#39;vNetSubnet1Name&amp;#39;)]&amp;#34;&lt;/span&gt;,
                        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;properties&amp;#34;&lt;/span&gt;: {
                            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;addressPrefix&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[variables(&amp;#39;vNetSubnet1Prefix&amp;#39;)]&amp;#34;&lt;/span&gt;
                        }
                    }
                ]
            }
        },
        {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;apiVersion&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;2015-05-01-preview&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Microsoft.Network/publicIPAddresses&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;publicIp&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;location&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[resourceGroup().location]&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;properties&amp;#34;&lt;/span&gt;: {
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;publicIPAllocationMethod&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Dynamic&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;dnsSettings&amp;#34;&lt;/span&gt;: {
                    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;domainNameLabel&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[parameters(&amp;#39;DnsName&amp;#39;)]&amp;#34;&lt;/span&gt;
                }
            }
        },
        {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;apiVersion&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;2015-05-01-preview&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;loadBalancer&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Microsoft.Network/loadBalancers&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;location&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[resourceGroup().location]&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;dependsOn&amp;#34;&lt;/span&gt;: [
                &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Microsoft.Network/publicIPAddresses/publicIp&amp;#34;&lt;/span&gt;
            ],
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;properties&amp;#34;&lt;/span&gt;: {
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;frontendIPConfigurations&amp;#34;&lt;/span&gt;: [
                    {
                        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[variables(&amp;#39;lbFrontend&amp;#39;)]&amp;#34;&lt;/span&gt;,
                        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;properties&amp;#34;&lt;/span&gt;: {
                            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;publicIPAddress&amp;#34;&lt;/span&gt;: {
                                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;id&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[resourceId(&amp;#39;Microsoft.Network/publicIPAddresses&amp;#39;,&amp;#39;publicIp&amp;#39;)]&amp;#34;&lt;/span&gt;
                            }
                        }
                    }
                ],
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;backendAddressPools&amp;#34;&lt;/span&gt;: [
                    {
                        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[variables(&amp;#39;lbBackendAddrPool&amp;#39;)]&amp;#34;&lt;/span&gt;
                    }
                ]
            }
        },
        {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;apiVersion&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;2015-06-15&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Microsoft.Network/loadBalancers/inboundNatRules&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;copy&amp;#34;&lt;/span&gt;: {
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;lbRdpNatLoop&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;count&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[variables(&amp;#39;selectedDeployment&amp;#39;).instancesCount]&amp;#34;&lt;/span&gt;
            },
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[concat(&amp;#39;/loadbalancer/&amp;#39;,&amp;#39;VM-&amp;#39;, copyIndex(1),&amp;#39;-RDP&amp;#39;)]&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;location&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[resourceGroup().location]&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;dependsOn&amp;#34;&lt;/span&gt;: [
                &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[concat(&amp;#39;Microsoft.Network/loadBalancers/loadBalancer&amp;#39;)]&amp;#34;&lt;/span&gt;
            ],
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;properties&amp;#34;&lt;/span&gt;: {
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;frontendIPConfiguration&amp;#34;&lt;/span&gt;: {
                    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;id&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[resourceId(&amp;#39;Microsoft.Network/loadBalancers/frontendIPConfigurations&amp;#39;,&amp;#39;loadBalancer&amp;#39;,variables(&amp;#39;lbFrontend&amp;#39;))]&amp;#34;&lt;/span&gt;
                },
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;protocol&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;tcp&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;frontendPort&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[add(3389, copyIndex(1))]&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;backendPort&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;3389&lt;/span&gt;,
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;enableFloatingIP&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;false&lt;/span&gt;
            }
        }
    ]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;You can go ahead and deploy this update by clicking on the button below. &lt;/p&gt;

    &lt;a href=&#34;https://portal.azure.com/#create/Microsoft.Template/uri/https%3a%2f%2fportal.azure.com%2f%23create%2fMicrosoft.Template%2furi%2fhttps%253A%252F%252Fraw.githubusercontent.com%252Frchaganti%252Farmseries%252Fmaster%252Farm-series_Storage-VirtualNet-LB.json&#34; target=&#34;_blank&#34;&gt;
        &lt;img src=&#34;https://raw.githubusercontent.com/Azure/azure-quickstart-templates/master/1-CONTRIBUTION-GUIDE/images/deploytoazure.svg?sanitize=true&#34; alt=&#34;&#34;&gt;
    &lt;/a&gt;
    &lt;br /&gt;

&lt;figure&gt;
    &lt;img src=&#34;https://ravichaganti.com/images/armtemplate5-2.png&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;This brings up the portal and prompts for the parameter values we need for the deployment. Within the parameters, you will see the &lt;em&gt;environmentType&lt;/em&gt; dropdown with three possible values. I have selected Production as the input here and I expect to see three RDP endpoints created at the end of template deployment. Let us see if this worked.&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&#34;https://ravichaganti.com/images/armtemplate5-3.png&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;&lt;a href=&#34;http://139.59.40.198/blog/uploads/2015/11/RDPEndpoints.png&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;As you see here, the endpoints with respective frontend port numbers are created. We will have to associate these endpoints to VM network interfaces and we will take that up in a later part. Stay tuned.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Building Azure Resource Manager Templates – Using Variables</title>
      <link>https://ravichaganti.com/blog/building-azure-resource-manager-templates-using-variables/</link>
      <pubDate>Sun, 15 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ravichaganti.com/blog/building-azure-resource-manager-templates-using-variables/</guid>
      <description>&lt;p&gt;If you have been following this series on &lt;a href=&#34;http://139.59.40.198/blog/series/arm-templates/&#34;&gt;ARM templates&lt;/a&gt;, in the last part, we started with a sample scenario that we are using to build an ARM template. Here it is again.&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&#34;https://ravichaganti.com/images/armtemplate4-1.png&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;In the &lt;a href=&#34;http://139.59.40.198/blog/building-azure-resource-manager-templates-using-parameters/&#34;&gt;last part&lt;/a&gt;, we completed creation of storage account required for backing the OS and data disks for virtual machines in the deployment. The next step in our scenario is to create the virtual network for the VM connectivity. A virtual network and any subnets required must exist before the creation of virtual machines. So, in today’s article, we will see how we can use variables in the ARM template language while incrementally building an ARM template for our scenario and add virtual network. Towards the end, we will review some best practices guidance with regards to using parameters and variables in developing ARM templates.&lt;/p&gt;
&lt;h4 id=&#34;working-with-variables&#34;&gt;Working with Variables&lt;/h4&gt;
&lt;p&gt;Variables in ARM template language can be used to simplify the template. For example, in our template, we will be using the subnet name at multiple places. There is no point repeating the same string everywhere for this. This may also lead to human errors such as unintentional misspelling of the subnet name. This type of errors will result in failure during the deployment. Instead, we can assign subnet name as a value to a variable and refer that variable within the template as needed. Also, variables in ARM template language will let us expand or construct other variable values. We will see examples of this in the template.&lt;/p&gt;
&lt;p&gt;Here is the generic syntax for variables in ARM template language.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;variables&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f00&#34;&gt;:&lt;/span&gt; {
   &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;&amp;lt;variable-name&amp;gt;&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&amp;lt;variable-value&amp;gt;&amp;#34;&lt;/span&gt;,
   &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;&amp;lt;variable-name&amp;gt;&amp;#34;&lt;/span&gt;: { 
       &lt;span style=&#34;color:#f00&#34;&gt;&amp;lt;variable-complex-type-value&amp;gt;&lt;/span&gt; 
   }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In general, variables is a JSON object which contains pairs of variable names and values. The variable value can be a complex type such as another JSON object. We will see these as examples as we add the variables needed to complete virtual network configuration.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;variables&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f00&#34;&gt;:&lt;/span&gt; {
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;vNetPrefix&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;10.0.0.0/16&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;vNetSubnet1Name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[concat(resourceGroup().Location, &amp;#39;-&amp;#39;, parameters(&amp;#39;vNetName&amp;#39;), &amp;#39;-&amp;#39;, &amp;#39;Subnet&amp;#39;)]&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;vNetSubnet1Prefix&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;10.0.0.0/24&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;vNetSubnet1ID&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[concat(resourceId(&amp;#39;Microsoft.Network/virtualNetworks&amp;#39;,parameters(&amp;#39;vNetName&amp;#39;)),&amp;#39;/subnets/&amp;#39;,variables(&amp;#39;vNetSubnet1Name&amp;#39;))]&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;dnsServerPrivateIp&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;10.0.0.8&amp;#34;&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;For the virtual network required for our scenario, we defined a variable called &lt;em&gt;vNetPrefix&lt;/em&gt; and set a value “10.0.0.0/16”. This is the overall virtual network address scope. Within this vNet, we intend to create one subnet with address prefix “10.0.0.0/24” and this is represented using the variable _vNetSubnet1Prefix. _I have added another variable named &lt;em&gt;dnsServerPrivateIp&lt;/em&gt; to reserve an IP address for the AD domain controller VM. This is because we don’t want a DHCP assigned IP for the AD DC.&lt;/p&gt;
&lt;p&gt;You will also see that we are using another function within this variables element called &lt;em&gt;&lt;a href=&#34;https://azure.microsoft.com/en-in/documentation/articles/resource-group-template-functions/#concat&#34;&gt;concat()&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;vNetSubnet1Name&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f00&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[concat(resourceGroup().Location, &amp;#39;-&amp;#39;, parameters(&amp;#39;vNetName&amp;#39;), &amp;#39;-&amp;#39;, &amp;#39;Subnet&amp;#39;)]&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This function can take ‘n’ strings and concatenate them together. In the example above, we are retrieving the resource group location and then concatenate that with ‘-‘ and the value of the &lt;em&gt;vNetName&lt;/em&gt; parameter. This variable value is then used to derive the value of the variable &lt;em&gt;vNetSubnet1ID.&lt;/em&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;vNetSubnet1ID&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f00&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[concat(resourceId(&amp;#39;Microsoft.Network/virtualNetworks&amp;#39;,parameters(&amp;#39;vNetName&amp;#39;)),&amp;#39;/subnets/&amp;#39;,variables(&amp;#39;vNetSubnet1Name&amp;#39;))]&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As I’d mentioned earlier, variables values can be generated dynamically based on other values. If you observe the above code snippet, we are constructing the &lt;em&gt;vNetSubnet1ID&lt;/em&gt; by retrieving the resource ID for the virtual network that we are creating. The &lt;em&gt;resourceId()&lt;/em&gt; function returns the unique identifier of a resource and it won’t be available until the vNet is created. This shows us that the values of variables can be derived from other related configuration settings. We have used the &lt;em&gt;concat()&lt;/em&gt; function again here to concatenate the resource Id value of the vNet with ‘/subnets/’ and the value of the &lt;em&gt;vNetSubnet1Name&lt;/em&gt; variable that we derived in last step. Similar to &lt;em&gt;parameters()&lt;/em&gt; function, the &lt;em&gt;&lt;a href=&#34;https://azure.microsoft.com/en-in/documentation/articles/resource-group-authoring-templates/#variables&#34;&gt;variables()&lt;/a&gt;&lt;/em&gt; function gives us the value of the variable name specified.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&amp;#34;[variables(&amp;#39;vNetSubnet1Name&amp;#39;)]&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The &lt;em&gt;variables()&lt;/em&gt; function can be used with the variables element as well as the resource definitions and outputs element. Like any other expression in template language, anytime you want to use this function, it must be enclosed in square brackets ([]).&lt;/p&gt;
&lt;p&gt;We will see more about creating variables with complex value types in a later part but fundamentals that you learned here are applicable even to complex types. Now that we have the variables needed for the vNet creation, let us go ahead and add the virtual network resource definition to our template.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;{
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;$schema&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;https://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;contentVersion&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;1.0.0.0&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;parameters&amp;#34;&lt;/span&gt;: {
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;storageAccountName&amp;#34;&lt;/span&gt;: {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;string&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;defaultValue&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;MyARMDemo&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;minLength&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;3&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;maxLength&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;24&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;metadata&amp;#34;&lt;/span&gt;: {
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;description&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Unique name for the storage account.&amp;#34;&lt;/span&gt;
            }
        },
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;storageAccountType&amp;#34;&lt;/span&gt;: {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;string&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;defaultValue&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Standard_LRS&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;allowedValues&amp;#34;&lt;/span&gt;: [
                &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Standard_LRS&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Standard_GRS&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Standard_ZRS&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Premium_LRS&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Standard_RAGRS&amp;#34;&lt;/span&gt;
            ],
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;metadata&amp;#34;&lt;/span&gt;: {
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;description&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Account type based on the storage redundancy requirements.&amp;#34;&lt;/span&gt;
            }
        },
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;vNetName&amp;#34;&lt;/span&gt;: {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;string&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;defaultValue&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;myARMDemo&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;metadata&amp;#34;&lt;/span&gt;: {
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;description&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Unique name of the virtual network for this deployment&amp;#34;&lt;/span&gt;
            }
        }
    },
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;variables&amp;#34;&lt;/span&gt;: {
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;vNetPrefix&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;10.0.0.0/16&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;vNetSubnet1Name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[concat(resourceGroup().Location, &amp;#39;-&amp;#39;, parameters(&amp;#39;vNetName&amp;#39;), &amp;#39;-&amp;#39;, &amp;#39;Subnet&amp;#39;)]&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;vNetSubnet1Prefix&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;10.0.0.0/24&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;vNetSubnet1ID&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[concat(resourceId(&amp;#39;Microsoft.Network/virtualNetworks&amp;#39;,parameters(&amp;#39;vNetName&amp;#39;)),&amp;#39;/subnets/&amp;#39;,variables(&amp;#39;vNetSubnet1Name&amp;#39;))]&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;dnsServerPrivateIp&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;10.0.0.8&amp;#34;&lt;/span&gt;
    },
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;resources&amp;#34;&lt;/span&gt;: [
        {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[parameters(&amp;#39;storageAccountName&amp;#39;)]&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Microsoft.Storage/storageAccounts&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;location&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[ResourceGroup().Location]&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;apiVersion&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;2015-05-01-preview&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;properties&amp;#34;&lt;/span&gt;: {
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;accountType&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[parameters(&amp;#39;storageAccountType&amp;#39;)]&amp;#34;&lt;/span&gt;
            }
        },
        {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[parameters(&amp;#39;vNetName&amp;#39;)]&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Microsoft.Network/virtualNetworks&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;location&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[ResourceGroup().Location]&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;apiVersion&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;2015-05-01-preview&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;properties&amp;#34;&lt;/span&gt;: {
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;addressSpace&amp;#34;&lt;/span&gt;: {
                    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;addressPrefixes&amp;#34;&lt;/span&gt;: [
                        &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[variables(&amp;#39;vNetPrefix&amp;#39;)]&amp;#34;&lt;/span&gt;
                    ]
                },
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;subnets&amp;#34;&lt;/span&gt;: [
                    {
                        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[variables(&amp;#39;vNetSubnet1Name&amp;#39;)]&amp;#34;&lt;/span&gt;,
                        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;properties&amp;#34;&lt;/span&gt;: {
                            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;addressPrefix&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[variables(&amp;#39;vNetSubnet1Prefix&amp;#39;)]&amp;#34;&lt;/span&gt;
                        }
                    }
                ]
            }
        }        
    ]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;I added a &lt;em&gt;vNetName&lt;/em&gt; parameter to the parameters element so that user deploying this template can provide that as input. We can go ahead and test if this is template is valid or not.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-powershell&#34; data-lang=&#34;powershell&#34;&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;Test-AzureRmResourceGroupDeployment&lt;/span&gt; -ResourceGroupName myARMDemo -TemplateFile .\arm-series_Storage-VirtualNet.json -storageAccountName myARMDemo -storageAccountType Standard_LRS -vNetName myARMDemo -Verbose
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Once the validation is complete, we can go ahead and deploy the same to ensure it is deploy-able. To test this immediately, click on the deploy to Azure button below.&lt;/p&gt;

    &lt;a href=&#34;https://portal.azure.com/#create/Microsoft.Template/uri/https%3a%2f%2fportal.azure.com%2f%23create%2fMicrosoft.Template%2furi%2fhttps%253A%252F%252Fraw.githubusercontent.com%252Frchaganti%252Farmseries%252Fmaster%252Farm-series_Storage-VirtualNet.json&#34; target=&#34;_blank&#34;&gt;
        &lt;img src=&#34;https://raw.githubusercontent.com/Azure/azure-quickstart-templates/master/1-CONTRIBUTION-GUIDE/images/deploytoazure.svg?sanitize=true&#34; alt=&#34;&#34;&gt;
    &lt;/a&gt;
    &lt;br /&gt;

&lt;h4 id=&#34;free-form-vs-known-configuration&#34;&gt;Free-form vs Known Configuration&lt;/h4&gt;
&lt;p&gt;We have so far looked at parameters, variables, and used them in the template that we are building. Parameters give us the flexibility to gather input from user deploying the template. We can completely parameterize the template and let the user provide every value needed for the deployment as an input parameter. This is called free-form configuration. However, using free-form configuration is not always scalable. The number of parameters that a user need to input might be overwhelming. Also, you don’t want your end user deploying this template to mess-up with the vNet and subnet address prefixes. This can have negative effects on the overall IaaS deployment. You might always want to prefix the subnet name with the resource group name to ensure there is uniformity across the resource names that you use. Some of this cannot be controlled unless you use known configurations. Known configurations help standardize resource configurations. Use variables in the template for resource settings that require no user input or you need control over. By using variables, you can simply change the value of the variable if at all you need to modify the template instead of trying to find where all the value is used.&lt;/p&gt;
&lt;p&gt;We will review more such best practices guidance and see using known configurations throughout this series. This is it for today. Stay tuned for more!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Building Azure Resource Manager Templates – Using Parameters</title>
      <link>https://ravichaganti.com/blog/building-azure-resource-manager-templates-using-parameters/</link>
      <pubDate>Tue, 10 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ravichaganti.com/blog/building-azure-resource-manager-templates-using-parameters/</guid>
      <description>&lt;p&gt;In the earlier parts of this &lt;a href=&#34;http://139.59.40.198/blog/series/arm-templates/&#34;&gt;series&lt;/a&gt;, we briefly looked at &lt;a href=&#34;http://139.59.40.198/blog/building-azure-resource-manager-templates-an-introduction/&#34;&gt;different methods of deploying ARM templates&lt;/a&gt; and then &lt;a href=&#34;http://139.59.40.198/blog/building-azure-resource-manager-templates-the-basics/&#34;&gt;basics of ARM template language&lt;/a&gt;. Starting today’s article, we will see our leaning in action. To get going with our leaning, we will start building the ARM template for the following scenario.&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&#34;https://ravichaganti.com/images/armtemplate3-1.png&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;We will incrementally build this scenario by learning different aspects of ARM template language. We won’t be covering all resource types in Azure but we will cover every aspect of the ARM template language and functions and expressions used in the template language. We will also review best practices in building these ARM templates as we proceed forward in this series.&lt;/p&gt;
&lt;p&gt;So, what is there in the scenario that we are building?&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;A resource group to host different resource types in our scenario.&lt;/li&gt;
&lt;li&gt;A storage account for hosting the VM OS and data disks.&lt;/li&gt;
&lt;li&gt;A virtual network for VM network connectivity.&lt;/li&gt;
&lt;li&gt;A public IP to connect to this deployment from external world.&lt;/li&gt;
&lt;li&gt;A load balancer that has the RDP and PowerShell remoting endpoints for the non-DC virtual machines in this scenario.&lt;/li&gt;
&lt;li&gt;Network interfaces for the AD DC and other VMs in our scenario.&lt;/li&gt;
&lt;li&gt;An Active Directory Domain Controller VM with DNS services running in it.&lt;/li&gt;
&lt;li&gt;Up to three VMs (depending on the environment type) that join the AD DS.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This scenario is not a complex deployment by any means but can be useful in building an ARM template that uses most or all of the artifacts in the template language. We will do this over a series of articles. But, at the end of each part, we will have a deploy-able template that we will test.&lt;/p&gt;
&lt;p&gt;Let us see how we can go about this.&lt;/p&gt;
&lt;h4 id=&#34;create-a-resource-group&#34;&gt;Create a Resource Group&lt;/h4&gt;
&lt;p&gt;Like I mentioned earlier, we need a resource group for deploying the components in our scenario using ARM templates. So, let us create one. You can do this using various means but I will stick to &lt;a href=&#34;https://github.com/Azure/azure-powershell/releases&#34;&gt;Azure PowerShell&lt;/a&gt; for this.&lt;/p&gt;
&lt;p&gt;Note: I will be using Azure PowerShell 1.0 cmdlets. You can get these using either PackageManagement cmdlets or Web PI or just get the &lt;!-- raw HTML omitted --&gt;MSI package from Github&lt;!-- raw HTML omitted --&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-powershell&#34; data-lang=&#34;powershell&#34;&gt;Login-AzureRmAccount
&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;New-AzureRmResourceGroup&lt;/span&gt; -Name MyARMDemo -Location &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;West US&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Note: An Azure resource group can contain &lt;!-- raw HTML omitted --&gt;resources from different regions&lt;!-- raw HTML omitted --&gt;.&lt;/p&gt;
&lt;h4 id=&#34;adding-parameters&#34;&gt;Adding Parameters&lt;/h4&gt;
&lt;p&gt;Now that we have a resource group created, let us start creating our ARM template for the scenario. First thing we need is a storage account for our resources. Storage accounts in Azure have a couple of properties — &lt;em&gt;name, type,&lt;/em&gt; and &lt;em&gt;location&lt;/em&gt; — that we can configure. We should ideally collect the values for &lt;em&gt;name&lt;/em&gt; and &lt;em&gt;type&lt;/em&gt; from the user deploying this template. This is where we will use parameters in the ARM template language. Let us first start by defining that.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;{
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;$schema&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;https://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;contentVersion&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;1.0.0.0&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;parameters&amp;#34;&lt;/span&gt;: {
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;storageAccountName&amp;#34;&lt;/span&gt;: {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;string&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;defaultValue&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;myARMDemo&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;minLength&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;3&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;maxLength&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;24&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;metadata&amp;#34;&lt;/span&gt;: {
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;description&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Unique name for the storage account.&amp;#34;&lt;/span&gt;
            }
        },
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;storageAccountType&amp;#34;&lt;/span&gt;: {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;string&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;defaultValue&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Standard_LRS&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;allowedValues&amp;#34;&lt;/span&gt;: [
                &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Standard_LRS&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Standard_GRS&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Standard_ZRS&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Premium_LRS&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Standard_RAGRS&amp;#34;&lt;/span&gt;
            ],
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;metadata&amp;#34;&lt;/span&gt;: {
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;description&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Account type based on the storage redundancy requirements.&amp;#34;&lt;/span&gt;
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In the above JSON template, we added parameters sub-element to the first two mandatory elements which are &lt;em&gt;$schema&lt;/em&gt; and &lt;em&gt;contentVersion.&lt;/em&gt; Within the parameters element, we have two parameters needed for creating storage account. Here is the generic syntax for adding parameters.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;parameters&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f00&#34;&gt;:&lt;/span&gt; {
   &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;&amp;lt;parameterName&amp;gt;&amp;#34;&lt;/span&gt; : {
     &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt; : &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&amp;lt;type-of-parameter-value&amp;gt;&amp;#34;&lt;/span&gt;,
     &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;defaultValue&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&amp;lt;optional-default-value-of-parameter&amp;gt;&amp;#34;&lt;/span&gt;,
     &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;allowedValues&amp;#34;&lt;/span&gt;: [ &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&amp;lt;optional-array-of-allowed-values&amp;gt;&amp;#34;&lt;/span&gt; ],
     &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;minValue&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#f00&#34;&gt;&amp;lt;optional-minimum-value-for-int-parameters&amp;gt;&lt;/span&gt;,
     &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;maxValue&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#f00&#34;&gt;&amp;lt;optional-maximum-value-for-int-parameters&amp;gt;&lt;/span&gt;,
     &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;minLength&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#f00&#34;&gt;&amp;lt;optional-minimum-length-for-string-secureString-array-parameters&amp;gt;&lt;/span&gt;,
     &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;maxLength&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#f00&#34;&gt;&amp;lt;optional-maximum-length-for-string-secureString-array-parameters&amp;gt;&lt;/span&gt;,
     &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;metadata&amp;#34;&lt;/span&gt;: {
         &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;description&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&amp;lt;optional-description-of-the parameter&amp;gt;&amp;#34;&lt;/span&gt; 
     }
   }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;We will be using more or less every property within the parameters element within the scenario we are developing. So, don’t worry if you don’t immediately see all of them used right away. The &lt;em&gt;storageAccountName&lt;/em&gt; parameter is of string &lt;em&gt;type&lt;/em&gt; and we set the &lt;em&gt;defaultValue&lt;/em&gt; to ‘myARMDemo’. So, when a user deploys this template it is not mandatory to supply the parameter value. The value of &lt;em&gt;type&lt;/em&gt; property should be a valid JSON type and one of the below mentioned types.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;string or secureString&lt;/li&gt;
&lt;li&gt;int&lt;/li&gt;
&lt;li&gt;bool&lt;/li&gt;
&lt;li&gt;object or secureObject&lt;/li&gt;
&lt;li&gt;array&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A storage account name must be at least 3 characters long and 24 characters at the most. The &lt;em&gt;minLength&lt;/em&gt; and &lt;em&gt;maxLength&lt;/em&gt; properties within the &lt;em&gt;storageAccountName&lt;/em&gt; parameter define these constraints. The &lt;em&gt;metadata&lt;/em&gt; property of the parameter is used to provide the help text to the end user deploying this template. You can put whatever string that best describes the parameter.&lt;/p&gt;
&lt;p&gt;For the &lt;em&gt;storageAccountType&lt;/em&gt; property, we have set &lt;em&gt;allowedValues&lt;/em&gt; property to ensure we restrict what the end user can provide as a value. This is required since there only a set of valid values for the storage account type in Azure. Note that &lt;em&gt;allowedValues&lt;/em&gt; property is a JSON array and is represented using square brackets. Since we are supplying &lt;em&gt;allowedValues,&lt;/em&gt; when a user deploys this template, they get to select one of the values either using dropdown or tab-complete when using PowerShell. For eample, in Azure PowerShell, this is achieved using the &lt;em&gt;New-AzureRmResourceGroupDeployment&lt;/em&gt; cmdlet.&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&#34;https://ravichaganti.com/images/armtemplate3-2.png&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;We would eventually add many more parameters by the time we create the final template. The basics that we discussed here should apply to all parameters that we add in future.&lt;/p&gt;
&lt;h4 id=&#34;adding-resources&#34;&gt;Adding Resources&lt;/h4&gt;
&lt;p&gt;To be able to deploy the template, we must have at least one resource type added to the &lt;em&gt;resources&lt;/em&gt; collection element. Let us go ahead and add the storage resource type to create a storage account.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;{
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;$schema&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;https://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;contentVersion&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;1.0.0.0&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;parameters&amp;#34;&lt;/span&gt;: {
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;storageAccountName&amp;#34;&lt;/span&gt;: {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;string&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;defaultValue&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;MyARMDemo&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;minLength&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;3&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;maxLength&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;24&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;metadata&amp;#34;&lt;/span&gt;: {
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;description&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Unique name for the storage account.&amp;#34;&lt;/span&gt;
            }
        },
        &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;storageAccountType&amp;#34;&lt;/span&gt;: {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;string&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;defaultValue&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Standard_LRS&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;allowedValues&amp;#34;&lt;/span&gt;: [
                &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Standard_LRS&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Standard_GRS&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Standard_ZRS&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Premium_LRS&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Standard_RAGRS&amp;#34;&lt;/span&gt;
            ],
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;metadata&amp;#34;&lt;/span&gt;: {
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;description&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Account type based on the storage redundancy requirements.&amp;#34;&lt;/span&gt;
            }
        }
    },
    &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;resources&amp;#34;&lt;/span&gt;: [
        {
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[parameters(&amp;#39;storageAccountName&amp;#39;)]&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Microsoft.Storage/storageAccounts&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;location&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[ResourceGroup().Location]&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;apiVersion&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;2015-05-01-preview&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;properties&amp;#34;&lt;/span&gt;: {
                &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;accountType&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[parameters(&amp;#39;storageAccountType&amp;#39;)]&amp;#34;&lt;/span&gt;
            }
        }        
    ]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As we learned earlier, resources element in the ARM template is a JSON array. It is a collection of comma-separated JSON objects where each JSON object represents an instance of a resource type. For a resource type, we need to configure the &lt;em&gt;name&lt;/em&gt; property to identify the resource instance within the group. Note the way we are retrieving the value of &lt;em&gt;storageAccountName&lt;/em&gt; parameter and assigning it to the &lt;em&gt;name&lt;/em&gt; property of storage account resource. We use the &lt;a href=&#34;https://azure.microsoft.com/en-in/documentation/articles/resource-group-template-functions/#parameters&#34;&gt;&lt;em&gt;parameters()&lt;/em&gt;&lt;/a&gt; function. We supply the name of the parameter to this function to retrieve its value. Also note that the functions and expressions within the JSON syntax must be enclosed within square brackets.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&amp;#34;name&amp;#34;: &amp;#34;[parameters(&amp;#39;storageAccountName&amp;#39;)]&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The &lt;em&gt;type&lt;/em&gt; property is used to define the resource provider (Microsoft.Storage) and resource type (storageAccounts) within the provider. The value of &lt;em&gt;location&lt;/em&gt; property identifies the region where we want to deploy the resource type. In the case of our ARM template, we are using the &lt;em&gt;&lt;a href=&#34;https://azure.microsoft.com/en-in/documentation/articles/resource-group-template-functions/#resourcegroup&#34;&gt;resourceGroup()&lt;/a&gt;&lt;/em&gt; function to define the location for our storage account. This function returns three attributes — &lt;em&gt;id, name,&lt;/em&gt; and &lt;em&gt;location&lt;/em&gt; — for the resource group within which the resource type is getting deployed. We use dot-reference to retrieve the value of location attribute.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&amp;#34;location&amp;#34;: &amp;#34;[ResourceGroup().Location]&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The properties element within the resource definition is a JSON object that identifies all the resource specific properties. We need to configure the storage account type setting and this is collected using the &lt;em&gt;storageAccountType&lt;/em&gt; parameter. Similar to how we assigned value to the &lt;em&gt;name&lt;/em&gt; property, we use the &lt;em&gt;parameters()&lt;/em&gt; function to get the value of &lt;em&gt;storageAccountType.&lt;/em&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;{
   &amp;#34;accountType&amp;#34;: &amp;#34;[parameters(&amp;#39;storageAccountType&amp;#39;)]&amp;#34;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;With this, we have a ARM template that can be used to deploy a storage account. But, how do we know whether this is valid or not. We can either use the &lt;a href=&#34;https://msdn.microsoft.com/en-us/library/azure/dn790547.aspx&#34;&gt;REST API&lt;/a&gt; for this or PowerShell cmdlets.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Once we validate the template, we can use one of the methods we discussed in the beginning of this series to deploy this template. One of the methods we discussed is the click to deploy button. So, go ahead and click on the below button and proceed to the Azure Portal (you need a valid Azure subscription).&lt;/p&gt;

    &lt;a href=&#34;https://portal.azure.com/#create/Microsoft.Template/uri/https%3a%2f%2fportal.azure.com%2f%23create%2fMicrosoft.Template%2furi%2fhttps%253A%252F%252Fraw.githubusercontent.com%252Frchaganti%252Farmseries%252Fmaster%252Farm-series_Storage.json&#34; target=&#34;_blank&#34;&gt;
        &lt;img src=&#34;https://raw.githubusercontent.com/Azure/azure-quickstart-templates/master/1-CONTRIBUTION-GUIDE/images/deploytoazure.svg?sanitize=true&#34; alt=&#34;&#34;&gt;
    &lt;/a&gt;
    &lt;br /&gt;

&lt;p&gt;You should see Azure Portal starting a new deployment and prompting you for parameter values.&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&#34;https://ravichaganti.com/images/armtemplate3-3.png&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;if you mouse over the small ‘i’ icon next to the parameter name, you will see the contents of the &lt;em&gt;metadata&lt;/em&gt; property for the parameter displayed in a tooltip.&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&#34;https://ravichaganti.com/images/armtemplate3-4.png&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;Once you fill in all required values in the wizard and click Create, the storage account gets deployed within the resource group.&lt;/p&gt;
&lt;p&gt;This is it. We have completed the first part of the ARM template development. In the next part, we will add some more resource types to the template and also learn some more artifacts in the ARM template language.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Building Azure Resource Manager Templates – The Basics</title>
      <link>https://ravichaganti.com/blog/building-azure-resource-manager-templates-the-basics/</link>
      <pubDate>Fri, 06 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ravichaganti.com/blog/building-azure-resource-manager-templates-the-basics/</guid>
      <description>&lt;p&gt;As a part of this series, we will go through the language semantics of writing ARM templates. We will explore each and every aspect of the ARM template language and go through multiple examples to understand the concepts better. We won’t focus much on the resource types and resource definitions until we complete the discussion around the language semantics and artifacts.&lt;/p&gt;
&lt;p&gt;Let us get started.&lt;/p&gt;
&lt;h4 id=&#34;tools-for-the-job&#34;&gt;Tools for the job&lt;/h4&gt;
&lt;p&gt;JSON templates for ARM can be edited in notepad too. But, there are better tools that can help us with this.&lt;/p&gt;
&lt;h5 id=&#34;visual-studio&#34;&gt;Visual Studio&lt;/h5&gt;
&lt;p&gt;Visual Studio, along with &lt;a href=&#34;https://azure.microsoft.com/en-us/downloads/&#34;&gt;Azure SDK&lt;/a&gt;, provides an easy way to get started with the template creation. You get started by creating a Resource Group project and just keep adding resources to the project and VS automatically generates the JSON for you. You can then customize it the way you want. More than the auto-generation of JSON, what I like is the intellisense capability that shows me the properties I can use within a template for a resource type.&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&#34;https://ravichaganti.com/images/armtemplate2-1.png&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;For more information on how to get started with using &lt;a href=&#34;https://azure.microsoft.com/en-us/blog/azure-resource-manager-2-5-for-visual-studio/&#34;&gt;Visual Studio to create ARM templates&lt;/a&gt;, read this &lt;a href=&#34;https://azure.microsoft.com/en-us/blog/azure-resource-manager-2-5-for-visual-studio/&#34;&gt;Azure team blog post&lt;/a&gt;.&lt;/p&gt;
&lt;h5 id=&#34;visual-studio-code&#34;&gt;Visual Studio Code&lt;/h5&gt;
&lt;p&gt;Visual Studio Code is my favorite. It loads up much faster than the full-blown Visual Studio and it is very easy to use. However, at the time of this writing, there is no ARM template authoring support like what VS has. However, it has some minimal auto-completion support based on what the editor understands from the schema.&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&#34;https://ravichaganti.com/images/armtemplate2-2.png&#34;/&gt; 
&lt;/figure&gt;

&lt;h5 id=&#34;sublime-text&#34;&gt;Sublime Text&lt;/h5&gt;
&lt;p&gt;Sublime Text has a &lt;a href=&#34;https://packagecontrol.io/packages/AzureResourceManager&#34;&gt;Azure Resource Manager package&lt;/a&gt; that gives a bunch of snippets for quick ARM template authoring. For example, after you activate ARM package, you can type &lt;em&gt;arm:t&lt;/em&gt; and press tab to add a skeleton of the ARM template.&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&#34;https://ravichaganti.com/images/armtemplate2-3.png&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;Sublime does provide some level of property auto-completion but it is still buggy. But, if your first choice is sublime, you have ARM template authoring support to some extent.&lt;/p&gt;
&lt;p&gt;There may be many other editors or IDEs with JSON support. Visual Studio is the first-class citizen as far as ARM template support is concerned and I hope VS code gets a similar level of template authoring support soon. Now that we know what we need to start template authoring, let us start with the language discussion.&lt;/p&gt;
&lt;h4 id=&#34;introducing-arm-template-language&#34;&gt;Introducing ARM template language&lt;/h4&gt;
&lt;p&gt;I have mentioned this several times already but will say it one more time before I start. ARM templates are based on JSON syntax. So, to be able to appreciate and understand the way we write ARM templates, you need to know how JSON synatx works. I am not going to write about the JSON syntax here but I have an article that I &lt;a href=&#34;http://www.powershellmagazine.com/2014/12/01/a-json-primer-for-administrators/&#34;&gt;published on PowerShell Magazine and that should give you a good overview&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Here is the basic structure of an ARM template.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;{
   &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;$schema&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;http://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#&amp;#34;&lt;/span&gt;,
   &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;contentVersion&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;,
   &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;parameters&amp;#34;&lt;/span&gt;: {  },
   &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;variables&amp;#34;&lt;/span&gt;: {  },
   &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;resources&amp;#34;&lt;/span&gt;: [  ],
   &lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;outputs&amp;#34;&lt;/span&gt;: {  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;schema&#34;&gt;$schema&lt;/h5&gt;
&lt;p&gt;This element is mandatory and the value must be the location of JSON schema file for the ARM template language. The JSON schema is what is used to find the right set of properties for resources etc. You can find the latest schema URL listed at &lt;a href=&#34;https://github.com/Azure/azure-resource-manager-schemas/&#34;&gt;https://github.com/Azure/azure-resource-manager-schemas/&lt;/a&gt;. When you start a new resource group project using Visual Studio, this property gets filled for you.&lt;/p&gt;
&lt;h5 id=&#34;contentversion&#34;&gt;ContentVersion&lt;/h5&gt;
&lt;p&gt;This is another mandatory element and you can use this to specify the version of the template you are authoring. As a part of the ARM authoring process, I suggest that you use the source control and build process to auto-update this element value instead of manually entering a version number.&lt;/p&gt;
&lt;h5 id=&#34;parameters&#34;&gt;Parameters&lt;/h5&gt;
&lt;p&gt;Think of parameters like parameters in any other programming language. In any programming language, parameters are used to provide flexibility within the function/method and not hard code any values that are really user-specific. ARM parameters are no exception. By defining parameters, you get the capability to collect user input for resource properties prior to starting the deployment.Parameters are what we use to draw a line between the free-form and known configurations. We will discuss this in-depth later. There are several properties within the parameters element. These properties can be used to set the allowed values or default value for a parameter or even set the minimum and maximum values for a parameter. Instead of just describing what those are, we will see real examples with those properties in the upcoming parts of this series.&lt;/p&gt;
&lt;h5 id=&#34;variables&#34;&gt;Variables&lt;/h5&gt;
&lt;p&gt;Variables, once again like any other programming language, helps us simplify the template language. For example, you can use variables element to store values for different resource properties and re-use them wherever applicable instead of writing the same value again and again. Also, within the ARM template language, variables can be used to construct values at runtime. You can use the user provided input in terms of parameters and construct the value for a specific resource property. Variables in ARM template can have standard type values as well as complex types. We will see examples of all this as we move forward in this series.&lt;/p&gt;
&lt;h5 id=&#34;resources&#34;&gt;Resources&lt;/h5&gt;
&lt;p&gt;Resource is a mandatory element and defines a collection of resources that you plan to deploy as a part of the template deployment. For each resource type that you define within this collection, there are certain standard sub-elements such as name, type, apiVersion, location, properties and so on. The properties element is used to describe the resource specific properties and the valid values for this are dependent on the resource type. Within this series, we will see a different set of resource types and use them within the templates that we build. However, we will not get into the details of each and every template. You can always refer to JSON schema and online documentation to find more about the properties for any given resource type.&lt;/p&gt;
&lt;h5 id=&#34;outputs&#34;&gt;Outputs&lt;/h5&gt;
&lt;p&gt;The outputs element is used to return data and objects from a deployment. For example, once a web application deployment is complete, you may want to return the URL at which the application is hosted. Also, outputs element is what we use to share state and data between multiple templates in a nested template deployment.&lt;/p&gt;
&lt;h4 id=&#34;functions-and-expressions&#34;&gt;Functions and Expressions&lt;/h4&gt;
&lt;p&gt;Apart from the six elements I described above, the ARM template syntax provides support for different &lt;a href=&#34;https://azure.microsoft.com/en-in/documentation/articles/resource-group-authoring-templates/#expressions-and-functions&#34;&gt;functions and expressions&lt;/a&gt; to simplify the deployment. For example, when you want to construct resource property values at runtime, you may need support for concatenating strings. As a part of our exploration here, we will look different functions and expressions that we can use within the ARM templates.&lt;/p&gt;
&lt;p&gt;This brings us to the end of today’s article. In the remaining parts going forward, we will take an example scenario and start building a template for that. In the process of doing that, we will see how different elements and artifacts such as functions and expressions within the template can be used. Before we start with that, I recommend that you get yourself familiarized with a tool that can be used to build these templates. Stay tuned for more.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Building Azure Resource Manager Templates – An Introduction</title>
      <link>https://ravichaganti.com/blog/building-azure-resource-manager-templates-an-introduction/</link>
      <pubDate>Mon, 02 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ravichaganti.com/blog/building-azure-resource-manager-templates-an-introduction/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://azure.microsoft.com/en-in/documentation/articles/resource-group-overview/&#34;&gt;Azure Resource Manager&lt;/a&gt; isn’t a new thing! It was announced during &lt;a href=&#34;https://channel9.msdn.com/Events/TechEd/NorthAmerica/2014/DEV-B224&#34;&gt;Build 2014&lt;/a&gt;. ARM is certainly the preferred way, with more and more services getting ARM support, to deploy Azure services. Microsoft also announced that the upcoming &lt;a href=&#34;https://www.youtube.com/watch?v=fuAmcfmo3X0&#34;&gt;Azure Stack release&lt;/a&gt; will feature Azure Resource Manager and the template deployment. This means that learning how to use ARM and write you own templates is an essential skill not just for public cloud but also for the private and hybrid cloud administrators.&lt;/p&gt;
&lt;p&gt;There is lot of Microsoft and community content out there that describes why ARM is important and how you can use the templates to deploy multi-tier and multi-service cloud deployments and manage all of them as a single entity. I am not going to repeat all that here. My focus, here, will be a thorough coverage of template language and design patterns. Through this series, you will get a complete and in-depth coverage of what you need to know to build world-class ARM templates. ARM uses &lt;a href=&#34;http://json.org/&#34;&gt;JSON formatted&lt;/a&gt; templates to perform these cloud deployments. You can see a bunch of these sample templates in the &lt;a href=&#34;https://github.com/Azure/azure-quickstart-templates&#34;&gt;Azure quick start templates Github repo&lt;/a&gt; that you can use as a starting point to create your own template or understand how to use the template language and best practices. This series of posts is about sharing my learning – the way I learned authoring ARM templates.&lt;/p&gt;
&lt;p&gt;Before you we go ahead start our discussion of ARM template language, let us first quickly review different methods of deploying these templates. This is not a detailed walk-through of these different methods since the focus of this article series is not on the deployment but building templates. After you write a custom ARM template, you can choose between any of these methods to deploy those templates.&lt;/p&gt;
&lt;h4 id=&#34;new-template-deployment-preview-portal&#34;&gt;New Template Deployment (Preview Portal)&lt;/h4&gt;
&lt;p&gt;The Azure Preview portal has an option to supply the ARM template contents (JSON) and then use a wizard-based method to start the deployment.&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&#34;https://ravichaganti.com/images/armtemplate1-1.png&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;To start this, as shown in the picture, click on the &lt;em&gt;+ icon&lt;/em&gt; and scroll down to click on &lt;em&gt;Template Deployment&lt;/em&gt;. The wizard that starts after this pretty much self-explanatory. As with any GUI and click-here methods, this is a manual method. I do not prefer this method.&lt;/p&gt;
&lt;h4 id=&#34;azure-powershell&#34;&gt;Azure PowerShell&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/Azure/azure-powershell/releases&#34;&gt;Azure PowerShell&lt;/a&gt; (the following example uses 1.0 preview) is my preferred option. You can just supply a template file and template parameter file to the &lt;em&gt;New-AzureRmResourceGroupDeployment&lt;/em&gt; cmdlet.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-powershell&#34; data-lang=&#34;powershell&#34;&gt;Login-AzureRmAccount
&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;New-AzureRmResourceGroup&lt;/span&gt; -Name ExampleResourceGroup -Location &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;West US&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;New-AzureRmResourceGroupDeployment&lt;/span&gt; -Name ExampleDeployment -ResourceGroupName ExampleResourceGroup -TemplateFile C:\ARMTemplates\SingleVMDeploy.json -TemplateParameterFile C:\ARMTemplates\SingleVMDeploy-parameter.json
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This method, like any other PowerShell-based method, can be completely automated and can be made a part of your CI/CD pipeline.&lt;/p&gt;
&lt;p&gt;If you prefer, you can do the same with &lt;a href=&#34;https://github.com/Azure/azure-xplat-cli/releases&#34;&gt;Azure CLI&lt;/a&gt; as well.&lt;/p&gt;
&lt;h4 id=&#34;arm-rest-api&#34;&gt;ARM REST API&lt;/h4&gt;
&lt;p&gt;The &lt;a href=&#34;https://msdn.microsoft.com/en-in/library/azure/dn790549.aspx&#34;&gt;template deployment API in the ARM REST API&lt;/a&gt; provides a way to deploy custom ARM templates programatically using any language that supports REST interfaces. For example, you can use the following API request to create a template deployment. You can supply the JSON template along with all parameter information in the same request or as a link to a blob in your storage account.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://management.azure.com/subscriptions/%7Bsubscription-id%7D/resourcegroups/%7Bresource-group-name%7D/providers/microsoft.resources/deployments/%7Bdeployment-name%7D?api-version=%7Bapi-version%7D&#34;&gt;https://management.azure.com/subscriptions/{subscription-id}/resourcegroups/{resource-group-name}/providers/microsoft.resources/deployments/{deployment-name}?api-version={api-version}&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;This method, like the Azure PowerShell or CLI method, can be easily integrated into an existing CI/CD pipeline.&lt;/p&gt;
&lt;h4 id=&#34;click-to-deploy-method&#34;&gt;Click to Deploy Method&lt;/h4&gt;
&lt;p&gt;Finally, there is a click to deploy method that Azure Preview portal gets integrated into. For example, most or all of the sample templates within the Azure quick start templates gallery contain the &lt;a href=&#34;https://azure.microsoft.com/en-us/blog/deploy-to-azure-button-for-azure-websites-2/&#34;&gt;Deploy to Azure button&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Clicking on the above button will take you to the new template deployment option in the preview portal where you can add the parameter values and start the deployment. Similar to this, you can embed these buttons on any webpage and redirect the user to Azure Preview portal to start the deployment.&lt;/p&gt;
&lt;h4 id=&#34;visual-studio&#34;&gt;Visual Studio&lt;/h4&gt;
&lt;p&gt;For developers creating ARM custom templates, it might be an easier option to both author and test deployment using &lt;a href=&#34;https://azure.microsoft.com/en-in/documentation/articles/arm-template-deployment/#step-2-create-the-visual-studio-project-the-template-file-and-the-parameters-file&#34;&gt;Visual Studio&lt;/a&gt;. VS provides necessary tooling to do this. VS provides the options to add new resources through a wizard and then later use the VS editor to customize and deploy those templates. Note that VS does not have all the resource types available in the wizard interface. For some of these missing resource types, you might still have to refer to the &lt;a href=&#34;https://github.com/Azure/azure-resource-manager-schemas&#34;&gt;schema and resource definitions&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;VS is my preferred (and only option at the moment) to start ARM template development. So, in this series, going forward, we will use VS for most of our scenarios but do the deployments using Azure PowerShell.&lt;/p&gt;
&lt;p&gt;This brings us to the end of today’s article. We have not yet seen any basics of authoring Azure Resource Manager templates. We will start discussing the basics and go in-depth starting the next part in this series. Before that, familiarize yourself with at least one of the custom template deployment methods.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
