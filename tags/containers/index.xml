<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Containers on Ravikanth Chaganti</title>
    <link>https://ravikanthchaganti.com/tags/containers/</link>
    <description>Recent content in Containers on Ravikanth Chaganti</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 03 Feb 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://ravikanthchaganti.com/tags/containers/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Devcontainers for cloud-native application development</title>
      <link>https://ravikanthchaganti.com/blog/devcontainers-for-cloud-native-application-development/</link>
      <pubDate>Sat, 03 Feb 2024 00:00:00 +0000</pubDate>
      <guid>https://ravikanthchaganti.com/blog/devcontainers-for-cloud-native-application-development/</guid>
      <description>&lt;p&gt;Containers changed the way we develop, package, and distribute applications. This helped teams accelerate development and ensure their code worked consistently across different environments and infrastructures. To a large extent, this enabled write once and run anywhere. Docker made this easy by providing tools to create, manage, and package application code and dependencies as images. We could run a container instance from that image wherever a container runtime exists. Standardizing image and runtime formats helped ensure we could take an image and run it anywhere and not worry about the underlying infrastructure. This also led to the proliferation of microservices-based application architectures, where an application comprises several services running within containers to deliver the expected functionality. Most cloud-native and modern application architectures use microservices to implement the necessary functionality. When developing an application with multiple microservice dependencies, a developer must ensure the development environment is suitably set up to handle all required dependencies.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Keyless git commit signing using Sigstore gitsign in a VS Code devcontainer</title>
      <link>https://ravikanthchaganti.com/blog/2022-12-13-keyless-git-commit-signing-using-sigstore-gitsign-in-a-vscode-devcontainer/</link>
      <pubDate>Tue, 13 Dec 2022 00:00:00 +0000</pubDate>
      <guid>https://ravikanthchaganti.com/blog/2022-12-13-keyless-git-commit-signing-using-sigstore-gitsign-in-a-vscode-devcontainer/</guid>
      <description>&lt;p&gt;Once a Sigstore fan, always a fan!&lt;/p&gt;&#xA;&lt;p&gt;Sigstore has become a good part of my research around SBOM and supply-chain security. I wrote about a &lt;a href=&#34;https://ravichaganti.com/blog/2022-12-12-sigstore-cosign-dev-container-feature/&#34;&gt;cosign VS Code devcontainer feature earlier&lt;/a&gt; and then stumbled upon &lt;a href=&#34;https://docs.sigstore.dev/gitsign/overview&#34;&gt;gitsign&lt;/a&gt;. In the past, I tried using GPG keys to sign my git commits but could not really sustain that as I kept changing machines and using different development environments. When I first looked at cosign, my initial thought was using it also for git commit signing but as I started reading Sigstore documentation, I discovered gitsign!&lt;/p&gt;</description>
    </item>
    <item>
      <title>Sigstore Cosign VS Code development container feature</title>
      <link>https://ravikanthchaganti.com/blog/2022-12-12-sigstore-cosign-dev-container-feature/</link>
      <pubDate>Mon, 12 Dec 2022 00:00:00 +0000</pubDate>
      <guid>https://ravikanthchaganti.com/blog/2022-12-12-sigstore-cosign-dev-container-feature/</guid>
      <description>&lt;p&gt;For those following me here or social media will know that I am a big fan of Visual Studio development containers. I wrote a &lt;a href=&#34;https://ravichaganti.com/blog/bicep-feature-in-vscode-devcontainer/&#34;&gt;bit about Visual Studio Code development containers&lt;/a&gt;. I have been using devcontainers for different development environments extensively. I have a &lt;a href=&#34;https://github.com/rchaganti/devcontainersample&#34;&gt;sample repo on GitHub&lt;/a&gt; that has all devcontainer definitions that I have been using for different projects. A latest addition to this list is the &lt;a href=&#34;https://github.com/sigstore/cosign&#34;&gt;Sigstore cosign&lt;/a&gt; devcontainer feature.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Building container images - using no tools</title>
      <link>https://ravikanthchaganti.com/blog/2022-11-28-building-container-images-using-no-tools/</link>
      <pubDate>Mon, 28 Nov 2022 00:00:00 +0000</pubDate>
      <guid>https://ravikanthchaganti.com/blog/2022-11-28-building-container-images-using-no-tools/</guid>
      <description>&lt;p&gt;In a couple of earlier articles, we looked at &lt;a href=&#34;https://ravichaganti.com/blog/2022-10-18-understanding-container-images-the-fundamentals/&#34;&gt;Linux constructs used in building container images&lt;/a&gt; and the &lt;a href=&#34;https://ravichaganti.com/blog/2022-10-28-understanding-container-images-oci-image-specification/&#34;&gt;OCI image specification&lt;/a&gt; which standardizes the container image format. It is now time to understand how we can create container images. Knowing this is important to optimize the image size and building secure container images. And, of course, this knowledge also helps us appreciate what tools like Docker CLI or Buildah among many others help us achieve. There are many tools to build container images. We shall look at each of these methods in-depth in later parts of &lt;a href=&#34;https://ravikanthchaganti.com/series/container-images/&#34;&gt;this series of articles&lt;/a&gt; on container images. For today, we will look into building container images using no tools! Actually, just using built-in OS tools.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Understanding and using Azure Container Instances service - Multi-container Applications using Bicep</title>
      <link>https://ravikanthchaganti.com/blog/2022-11-03-understanding-and-using-azure-container-instances-service-multi-container-apps-using-bicep/</link>
      <pubDate>Thu, 03 Nov 2022 00:00:00 +0000</pubDate>
      <guid>https://ravikanthchaganti.com/blog/2022-11-03-understanding-and-using-azure-container-instances-service-multi-container-apps-using-bicep/</guid>
      <description>&lt;p&gt;In the previous article, we looked at &lt;a href=&#34;https://ravichaganti.com/blog/2022-11-02-understanding-and-using-azure-container-instances-service-the-basics/&#34;&gt;getting started with Azure Container Instances service&lt;/a&gt;, learned some basic concepts of ACI, and saw an example of provisioning a hello-world application. In this article, we shall extend this knowledge by provisioning a multi-container application to ACI using Bicep templates. You can also use a YAML method of provisioning multi-container applications to ACI. We shall look at this later.&lt;/p&gt;&#xA;&lt;p&gt;As we learned earlier, a container group resembles a Kubernetes pod. The containers within the group share resources such as network and storage. The resource usage of containers can be controlled at the container group level. As a general rule of thumb, we should group containers with similar lifecycle and resource requirements into a container group. The multi-container groups are available for Linux containers only at the moment. Based on the region, there will be additional restrictions in terms of resource allocation.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Understanding and using Azure Container Instances service - The Basics</title>
      <link>https://ravikanthchaganti.com/blog/2022-11-02-understanding-and-using-azure-container-instances-service-the-basics/</link>
      <pubDate>Wed, 02 Nov 2022 00:00:00 +0000</pubDate>
      <guid>https://ravikanthchaganti.com/blog/2022-11-02-understanding-and-using-azure-container-instances-service-the-basics/</guid>
      <description>&lt;p&gt;In an earlier article, we looked at &lt;a href=&#34;https://ravikanthchaganti.com/blog/2022-11-01-containerization-in-azure&#34;&gt;different containerization options&lt;/a&gt; in Microsoft Azure. In today&amp;rsquo;s article, we shall start with Azure Container Instances (ACI) and learn the fundamentals. In a later article, we will learn how to perform multi-container applications to ACI.&lt;/p&gt;&#xA;&lt;h3 id=&#34;azure-container-instances&#34;&gt;Azure Container Instances&lt;/h3&gt;&#xA;&lt;p&gt;Azure Container Instances (ACI) service offers a quick and easy way to run containers in the Microsoft Azure cloud. It is as simple as running a container locally using the Docker engine. ACI does not provide full container orchestration. ACI is great for applications that require faster startup times and hassle-free management. ACI runs inside Azure VMs and therefore provides isolation enabled by virtualization.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Containerization in Microsoft Azure</title>
      <link>https://ravikanthchaganti.com/blog/2022-11-01-containerization-in-azure/</link>
      <pubDate>Tue, 01 Nov 2022 00:00:00 +0000</pubDate>
      <guid>https://ravikanthchaganti.com/blog/2022-11-01-containerization-in-azure/</guid>
      <description>&lt;p&gt;Containerization is everywhere &amp;ndash; from on-premises data centers to the edge and in the cloud. We have been using containers right from development to production. I wrote about VS Code development containers and how &lt;a href=&#34;https://ravichaganti.com/blog/bicep-feature-in-vscode-devcontainer/&#34;&gt;I have standardized my development environment using devcontainers.&lt;/a&gt; There are several options for companies to run containerized applications in production. we can run individual application containers on a container host using engines like Docker. We can use tools like Docker &lt;a href=&#34;https://docs.docker.com/compose/&#34;&gt;Compose&lt;/a&gt; or &lt;a href=&#34;https://docs.docker.com/engine/swarm/&#34;&gt;Swarm&lt;/a&gt; for slightly complex multi-container, multi-host environments. However, it becomes complex to manage such environments. This needs us to implement a physical or virtualized server environment and handle all operational overhead associated with running our data center.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Publish container images to Azure Container Registry</title>
      <link>https://ravikanthchaganti.com/blog/2022-10-29-publish-container-images-to-azure-container-registry/</link>
      <pubDate>Sat, 29 Oct 2022 00:00:00 +0000</pubDate>
      <guid>https://ravikanthchaganti.com/blog/2022-10-29-publish-container-images-to-azure-container-registry/</guid>
      <description>&lt;p&gt;In the &lt;a href=&#34;https://ravichaganti.com/series/container-images/&#34;&gt;previous articles in this series&lt;/a&gt;, we looked at how to build container images and understand the OCI image specification that governs how the images are built and dealt with. Once the images are built, we may want to push them to a central repository for sharing with a larger community or a private container registry such as the Azure Container Registry (ACR).&lt;/p&gt;&#xA;&lt;p&gt;In today&amp;rsquo;s article, we shall learn how to create an Azure Container Registry, push an image, and consume it back in the local environment. Let&amp;rsquo;s start!&lt;/p&gt;</description>
    </item>
    <item>
      <title>Understanding container images - OCI image specification</title>
      <link>https://ravikanthchaganti.com/blog/2022-10-28-understanding-container-images-oci-image-specification/</link>
      <pubDate>Fri, 28 Oct 2022 00:00:00 +0000</pubDate>
      <guid>https://ravikanthchaganti.com/blog/2022-10-28-understanding-container-images-oci-image-specification/</guid>
      <description>&lt;p&gt;In the &lt;a href=&#34;https://ravichaganti.com/blog/2022-10-18-understanding-container-images-the-fundamentals/&#34;&gt;previous article&lt;/a&gt;, we looked at how OverlayFS is used to work with container images. We learned how the image layers are associated with each other and how the copy-on-write layer gets created when a containers gets created from an image. Container registries such as Docker Hub and Quay offer container images for several popular applications and you can publish your images as well. There are different tools available to build and push images to container registries. Whatever container engine you use &amp;ndash; Docker or Podman &amp;ndash; you can simply pull the image [built using any tool] from the registry and use it. How is this interoperability made possible? The answer is the work &lt;a href=&#34;https://opencontainers.org/&#34;&gt;Open Container Initiative&lt;/a&gt; (OCI) is doing.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Understanding container images - The fundamentals</title>
      <link>https://ravikanthchaganti.com/blog/2022-10-18-understanding-container-images-the-fundamentals/</link>
      <pubDate>Tue, 18 Oct 2022 00:00:00 +0000</pubDate>
      <guid>https://ravikanthchaganti.com/blog/2022-10-18-understanding-container-images-the-fundamentals/</guid>
      <description>&lt;p&gt;Containers have been around for a while. There is no need for an introduction to containers anymore but If you are still looking for some background, you can read a &lt;a href=&#34;https://ravikanthchaganti.com/tags/containers/&#34;&gt;series of articles&lt;/a&gt; I have written on this blog. Docker simplified working with containers by introducing a way to package your applications and application dependencies as container images. It also provided the tooling that made running container instances from these images easy. This meant the user space tools abstracted all complex details and removed the need to know the inner workings of containers. Like every other technology, knowing the internals of how something is built becomes important when troubleshooting issues or optimizing what the technology does. And, of course, knowing / learning internals is fun too!&lt;/p&gt;</description>
    </item>
    <item>
      <title>CUE language VS Code development container feature</title>
      <link>https://ravikanthchaganti.com/blog/2022-10-10-cue-lang-dev-container-feature/</link>
      <pubDate>Mon, 10 Oct 2022 00:00:00 +0000</pubDate>
      <guid>https://ravikanthchaganti.com/blog/2022-10-10-cue-lang-dev-container-feature/</guid>
      <description>&lt;p&gt;In an earlier article, I wrote a &lt;a href=&#34;https://ravichaganti.com/blog/bicep-feature-in-vscode-devcontainer/&#34;&gt;bit about Visual Studio Code development containers&lt;/a&gt;. I have been using devcontainers for different development environments extensively. This is helping me keep the environment consistent and helps me rebuild an environment from scratch almost instantly. I use dev containers for all my Go language, Python, Rust, and now CUE language learning and development work. You can find all my dev container definition in a &lt;a href=&#34;https://github.com/rchaganti/devcontainersample&#34;&gt;sample repository I created on GitHub&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Working with Azure Bicep Public modules registry</title>
      <link>https://ravikanthchaganti.com/blog/working-with-azure-bicep-public-modules-registry/</link>
      <pubDate>Tue, 19 Apr 2022 00:00:00 +0000</pubDate>
      <guid>https://ravikanthchaganti.com/blog/working-with-azure-bicep-public-modules-registry/</guid>
      <description>&lt;p&gt;Starting with Bicep version 0.5.6, Microsoft added support for consuming from a public module&#xA;repository hosted on Microsoft Container Registry (MCR). To consume a module from Microsoft’s&#xA;pubic registry, you need to use the following syntax.&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;&#xA;&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;&#xA;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1&#xA;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&#xA;&lt;td class=&#34;lntd&#34;&gt;&#xA;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;module &amp;lt;module-id&amp;gt; &amp;#39;br/public:&amp;lt;module-group&amp;gt;/&amp;lt;module-name&amp;gt;:&amp;lt;version&amp;gt;&amp;#39; = { ... }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;&lt;code&gt;br/public&lt;/code&gt; indicates that you want to consume the module hosted on MCR. Here is an example of&#xA;creating a Azure virtual network using the virtual-network module. The version tag is mandatory.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Azure Bicep as a feature in VS Code development containers</title>
      <link>https://ravikanthchaganti.com/blog/bicep-feature-in-vscode-devcontainer/</link>
      <pubDate>Sun, 20 Mar 2022 00:00:00 +0000</pubDate>
      <guid>https://ravikanthchaganti.com/blog/bicep-feature-in-vscode-devcontainer/</guid>
      <description>&lt;p&gt;Visual Studio Code &lt;a href=&#34;https://code.visualstudio.com/docs/remote/containers&#34;&gt;development containers&lt;/a&gt; are magic! With the help of VS Code Remote - Containers extension and Docker Desktop, you can run a full-featured development environment within a container.&lt;/p&gt;&#xA;&lt;p&gt;&lt;figure class=&#34;figure &#34; style=&#34;max-width: 100%; margin: 1.5rem auto;&#34;&gt;&#xA;  &lt;a href=&#34;https://code.visualstudio.com/assets/docs/devcontainers/containers/architecture-containers.png&#34; class=&#34;glightbox&#34; data-gallery=&#34;post-images&#34; data-glightbox=&#34;description: &#34;&gt;&#xA;    &lt;img src=&#34;https://code.visualstudio.com/assets/docs/devcontainers/containers/architecture-containers.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; style=&#34;width: 100%; height: auto; border-radius: 0.5rem; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);&#34;&gt;&#xA;  &lt;/a&gt;&lt;/figure&gt;&#xA; &#xA; &lt;link rel=&#34;stylesheet&#34; href=&#34;https://cdn.jsdelivr.net/npm/glightbox@3.3.0/dist/css/glightbox.min.css&#34;&gt;&#xA; &#xA; &#xA; &lt;script src=&#34;https://cdn.jsdelivr.net/npm/glightbox@3.3.0/dist/js/glightbox.min.js&#34;&gt;&lt;/script&gt;&#xA; &#xA; &#xA; &lt;script&gt;&#xA;   document.addEventListener(&#39;DOMContentLoaded&#39;, function() {&#xA;     const lightbox = GLightbox({&#xA;       selector: &#39;.glightbox&#39;,&#xA;       touchNavigation: true,&#xA;       loop: true,&#xA;       autoplayVideos: true,&#xA;       zoomable: true,&#xA;       draggable: true,&#xA;       closeButton: true,&#xA;       moreLength: 0&#xA;     });&#xA;   });&#xA; &lt;/script&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Bicep Container Image</title>
      <link>https://ravikanthchaganti.com/blog/bicep-container-image/</link>
      <pubDate>Thu, 20 May 2021 00:00:00 +0000</pubDate>
      <guid>https://ravikanthchaganti.com/blog/bicep-container-image/</guid>
      <description>&lt;div style=&#34;max-width: 100%; margin: 1.5rem auto; text-align: center;&#34;&gt;&#xA;  &lt;img src=&#34;https://ravikanthchaganti.com/images/bicep.png&#34; alt=&#34;&#34; class=&#34;&#34; style=&#34;max-width: 100%; height: auto; border-radius: 0.5rem;&#34;&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;p&gt;While using the &lt;a href=&#34;https://hub.docker.com/_/microsoft-azure-cli&#34;&gt;Azure CLI container image&lt;/a&gt; for one of my side projects, I started looking for an image that contains Bicep CLI as well. I found &lt;a href=&#34;https://github.com/miqm&#34;&gt;Mikolaj Mackowiak&amp;rsquo;s&lt;/a&gt; &lt;a href=&#34;https://hub.docker.com/r/miqm/bicep-cli&#34;&gt;Bicep-cli image&lt;/a&gt;. This was what I really needed and it includes both Azure CLI and Bicep CLI. However, just as a fun side project, I wanted to publish my own image as well.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Containers – What are they? And, their history! – Part 2</title>
      <link>https://ravikanthchaganti.com/blog/containers-what-are-they-and-their-history-part-2/</link>
      <pubDate>Fri, 06 Feb 2015 00:00:00 +0000</pubDate>
      <guid>https://ravikanthchaganti.com/blog/containers-what-are-they-and-their-history-part-2/</guid>
      <description>&lt;p&gt;In the earlier article, I explained the &lt;a href=&#34;https://ravikanthchaganti.com/blog/containers-what-are-they-why-do-you-need-one-part-1&#34;&gt;hurdles in the traditional and virtualized ways of implementing workloads&lt;/a&gt;. Also, we looked how the DevOps challenges are demanding changes the continuous delivery and integration processes. Towards the end, I’d mentioned that Containers are an answer.&lt;/p&gt;&#xA;&lt;p&gt;In today’s article, we will see what are containers and some history behind containerization. Let us get started. In the subsequent parts, we will dig into each building block used within container technologies and understand how to use them.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Containers – What are they? Why do you need one? – Part 1</title>
      <link>https://ravikanthchaganti.com/blog/containers-what-are-they-why-do-you-need-one-part-1/</link>
      <pubDate>Tue, 20 Jan 2015 00:00:00 +0000</pubDate>
      <guid>https://ravikanthchaganti.com/blog/containers-what-are-they-why-do-you-need-one-part-1/</guid>
      <description>&lt;p&gt;Containers? No, not the shipping containers but the much-hyped container technology in the computer industry. I am sure even if you have not used any of the existing container technologies, you must have at least read or heard about them.&lt;/p&gt;&#xA;&lt;p&gt;I am not the first one to write about containers and this is certainly not an in-depth overview of container technologies. I will eventually get there and show you how you can deploy different container technologies. This series of articles is about my own thoughts and a documentation for my own reference. In the process, I wish to help my readers as well.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
