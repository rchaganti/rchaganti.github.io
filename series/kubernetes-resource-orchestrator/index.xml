<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kubernetes Resource Orchestrator on Ravikanth Chaganti</title>
    <link>https://ravikanthchaganti.com/series/kubernetes-resource-orchestrator/</link>
    <description>Recent content in Kubernetes Resource Orchestrator on Ravikanth Chaganti</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 14 Mar 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://ravikanthchaganti.com/series/kubernetes-resource-orchestrator/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Kube Resource Orchestrator (KRO) - Deploying the sample voting application</title>
      <link>https://ravikanthchaganti.com/blog/kube-resource-orchestrator-kro-deploying-the-sample-voting-application/</link>
      <pubDate>Fri, 14 Mar 2025 00:00:00 +0000</pubDate>
      <guid>https://ravikanthchaganti.com/blog/kube-resource-orchestrator-kro-deploying-the-sample-voting-application/</guid>
      <description>&lt;p&gt;In today&amp;rsquo;s article, you will build upon what you learned in the earlier article about the &lt;a href=&#34;https://cloudnativecentral.com/posts/kube-resource-orchestrator-the-basics/&#34;&gt;basics&lt;/a&gt; of &lt;code&gt;kro&lt;/code&gt;. To demonstrate a few more &lt;code&gt;kro&lt;/code&gt; concepts, we will use the famous &lt;a href=&#34;https://github.com/dockersamples/example-voting-app&#34;&gt;sample voting&lt;/a&gt; application.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/dockersamples/example-voting-app/raw/main/architecture.excalidraw.png&#34; alt=&#34;Sample voting app&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;While not very complex, this application has enough moving parts to define dependencies. In this article, we shall look at the custom API needed to instantiate this voting application on Kubernetes. In this example, we must bring up the &lt;code&gt;redis&lt;/code&gt; and &lt;code&gt;db&lt;/code&gt; services as &lt;code&gt;ClusterIP&lt;/code&gt; services before the &lt;code&gt;vote&lt;/code&gt; and &lt;code&gt;result&lt;/code&gt; services, which are &lt;code&gt;NodePort&lt;/code&gt; type.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Kube Resource Orchestrator (KRO) - The Basics</title>
      <link>https://ravikanthchaganti.com/blog/kube-resource-orchestrator-kro-the-basics/</link>
      <pubDate>Sun, 09 Mar 2025 00:00:00 +0000</pubDate>
      <guid>https://ravikanthchaganti.com/blog/kube-resource-orchestrator-kro-the-basics/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://helm.sh/&#34;&gt;Helm&lt;/a&gt; helps application developers and operators manage Kubernetes applications. It allows you to define, install, and upgrade Kubernetes applications. Helm uses a packaging format called charts, a collection of files describing a related set of Kubernetes resources. Other application packaging solutions, such as &lt;a href=&#34;https://kubectl.docs.kubernetes.io/references/kustomize/&#34;&gt;Kustomize&lt;/a&gt;, exist, but nothing comes close to the popularity Helm gained in the Cloud Native space. While Helm is certainly the most popular package manager, it comes with a few limitations. Helm does not offer an efficient dependency management solution. At deployment time, there is no way you can retrieve the dependent resource properties for subsequent resource deployment within the chart. Helm cannot handle custom resource definitions well. We must use &lt;code&gt;values.yaml&lt;/code&gt; to supply custom values to the chart and its subcharts. This has no schema validation and, therefore, results in human errors at the time of deployment. Helm does not offer any post-deployment reconciliation support, which is important to ensure any drift in application configuration can be detected and corrected. Companies in the Cloud-native space have been looking at alternatives, and a new open-source project called &lt;code&gt;kro&lt;/code&gt; may be that alternative.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
