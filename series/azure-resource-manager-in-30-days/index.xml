<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Azure Resource Manager In 30 Days on Ravikanth Chaganti</title>
    <link>https://ravichaganti.com/series/azure-resource-manager-in-30-days/</link>
    <description>Recent content in Azure Resource Manager In 30 Days on Ravikanth Chaganti</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Fri, 07 Aug 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://ravichaganti.com/series/azure-resource-manager-in-30-days/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Azure Resource Manager - Using secrets in ARM templates</title>
      <link>https://ravichaganti.com/blog/azure-resource-manager-using-secrets-in-arm-templates/</link>
      <pubDate>Fri, 07 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ravichaganti.com/blog/azure-resource-manager-using-secrets-in-arm-templates/</guid>
      <description>
    &lt;figure &gt;
        
            &lt;img src=&#34;https://ravichaganti.com/images/armin30/templatearchitecture.png&#34; width=&#34;760&#34; /&gt;
        
        
    &lt;/figure&gt;
    
&lt;p&gt;In this series so far, you have seen how you can get started with ARM templates, parameterize the templates by adding parameters, and then optimize those templates using variables, expressions, and user-defined functions. It is now time to move forward into more advanced topics and start building the template for the remaining components in the architecture shown above. In the architecture shown above, you will be implementing an ARM template that will provision virtual machines for which the administrator and domain-join credentials will have to provided as input. Also, the configuration scripts used for guest OS configuration may have to access an internal storage account blob which will require the storage connection strings and access keys. Storing these secrets in plain-text is not recommended at all. Also, as an architect, you may want to standardize on the passwords used for local administrator accounts and do not want to share the domain-join credentials with any user while provisioning an ARM template. This needs a more centralized credential and secret store. Azure Vault provides this capability. Today, you will see how to handle secrets such as passwords, access keys, certificates, and so on in an ARM template.&lt;/p&gt;
&lt;h2 id=&#34;azure-key-vault&#34;&gt;Azure Key Vault&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://azure.microsoft.com/en-us/services/key-vault/&#34;&gt;Azure Key Vault&lt;/a&gt; is a service that provides a centralized secret store. You can use the Key Vault for cryptographic keys, API keys, passwords, connection strings, and certificates. For the cryptographic keys, you can use a Hardware Security Module (HSM) as well. Once a key vault is provisioned, you can add your secrets and retrieve them in an ARM template for use with other resource types such as virtual machines.&lt;/p&gt;
&lt;h3 id=&#34;creating-a-key-vault&#34;&gt;Creating a key vault&lt;/h3&gt;
&lt;p&gt;To create a key vault, you need few mandatory input parameters such as &lt;code&gt;tenantId&lt;/code&gt;, &lt;code&gt;objectId&lt;/code&gt; of the user or service principal or the security group in Azure Active Directory (AAD), key and secret permissions. The specified tenant will be used for authenticating requests to the key vault and the object Id of the AAD user will be used to provide the necessary permissions to interact with the Key Vault.&lt;/p&gt;
&lt;p&gt;Here is a simple starter template that you can use.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/rchaganti/d7e35878c6687da07ae5fa5dfb7d54c2.js?file=azKVbeginner.azrm.json&#34;&gt;&lt;/script&gt;

&lt;p&gt;In this starter template, you see that the value of &lt;code&gt;tenantId&lt;/code&gt; defaults to the value of the &lt;code&gt;tenantId&lt;/code&gt; property from the &lt;code&gt;subscription()&lt;/code&gt; standard template function. The value to the &lt;code&gt;objectId&lt;/code&gt; property is coming from a template parameter. You can retrieve the object ID of an AAD user using &lt;code&gt;az ad user show&lt;/code&gt; command.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;az ad user show --id Ravikanth@azure.com --query objectId
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;You can deploy the above template to create a Key Vault by clicking on the Deploy To Azure button below.&lt;/p&gt;

    &lt;a href=&#34;https://portal.azure.com/#create/Microsoft.Template/uri/https%3a%2f%2fgist.githubusercontent.com%2frchaganti%2fd7e35878c6687da07ae5fa5dfb7d54c2%2fraw%2fa5b15709b6803abaf3d4eca4308052eb37c31fbd%2fazKVbeginner.azrm.json&#34; target=&#34;_blank&#34;&gt;
        &lt;img src=&#34;https://raw.githubusercontent.com/Azure/azure-quickstart-templates/master/1-CONTRIBUTION-GUIDE/images/deploytoazure.svg?sanitize=true&#34; alt=&#34;&#34;&gt;
    &lt;/a&gt;
    &lt;br /&gt;

&lt;p&gt;If you prefer Azure CLI, you can use the following commands to perform this template deployment.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/rchaganti/d7e35878c6687da07ae5fa5dfb7d54c2.js?file=azKVbeginner.azcli&#34;&gt;&lt;/script&gt;

&lt;p&gt;In the above template, as a part of the access policies [line 22], for &lt;code&gt;key&lt;/code&gt;,  &lt;code&gt;secrets&lt;/code&gt;, &lt;code&gt;certificates&lt;/code&gt; permissions, you have used &lt;code&gt;all&lt;/code&gt; as the value. As it literally means, this permission level provides full permission set to the service principal specified using &lt;code&gt;objectId&lt;/code&gt; property. This is not recommended in a production Key Vault. You must secure the key vault as well and restrict access to what is really needed. The allowed values for the key and secret permissions can be seen in the &lt;a href=&#34;https://docs.microsoft.com/en-us/azure/templates/microsoft.keyvault/2015-06-01/vaults&#34;&gt;resource provider reference&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;To this extent, the above template can be modified to add a few more parameters to enable permission value specification.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/rchaganti/d7e35878c6687da07ae5fa5dfb7d54c2.js?file=azKVbeginnerParameterized.azrm.json&#34;&gt;&lt;/script&gt;

&lt;p&gt;In this updated template, three additional parameters are added to gather key, secret, and certificate permissions. While there are default values for these parameters, you can provide updated set of permissions as an array during deployment time. If you notice, there are additional resource properties as well added to the Key Vault resource definition.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;enabledForDeployment&lt;/strong&gt; spcifies whether Azure virtual machines can retrieve the certificates from the key vault or not.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;enabledForTemplateDeployment&lt;/strong&gt; specifies whether Azure Resource Manager is allowed to retrieve secrets from the vault or not.&lt;/p&gt;
&lt;p&gt;For the architecture that you are building, both these properties need to be set to &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;You can try deploying this template by clicking on the Deploy to Azure button below.&lt;/p&gt;

    &lt;a href=&#34;https://portal.azure.com/#create/Microsoft.Template/uri/https%3a%2f%2fgist.githubusercontent.com%2frchaganti%2fd7e35878c6687da07ae5fa5dfb7d54c2%2fraw%2f4a5cb89ed7d2b3a5c08230450a38799e1f6d6f0e%2fazKVbeginnerParameterized.azrm.json&#34; target=&#34;_blank&#34;&gt;
        &lt;img src=&#34;https://raw.githubusercontent.com/Azure/azure-quickstart-templates/master/1-CONTRIBUTION-GUIDE/images/deploytoazure.svg?sanitize=true&#34; alt=&#34;&#34;&gt;
    &lt;/a&gt;
    &lt;br /&gt;

&lt;p&gt;Now, with this updated template you have a functional key vault that can be used to store secrets needed for other resource configurations. So, how do you use ARM templates to store secrets in a key vault?&lt;/p&gt;
&lt;h3 id=&#34;adding-secrets-to-vault&#34;&gt;Adding secrets to vault&lt;/h3&gt;
&lt;p&gt;Once you have a key vault provisioned, you can add the &lt;code&gt;Microsoft.KeyVault/vaults/secrets&lt;/code&gt; resource to the template to add secrets to the vault. The following resource definition will do that job.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;{
	&amp;#34;type&amp;#34;: &amp;#34;Microsoft.KeyVault/vaults/secrets&amp;#34;,
	&amp;#34;name&amp;#34;: &amp;#34;[concat(variables(&amp;#39;keyVaultName&amp;#39;), &amp;#39;/&amp;#39;, parameters(&amp;#39;secretName&amp;#39;))]&amp;#34;,
	&amp;#34;apiVersion&amp;#34;: &amp;#34;2018-02-14&amp;#34;,
	&amp;#34;location&amp;#34;: &amp;#34;[resourceGroup().location]&amp;#34;,
	&amp;#34;properties&amp;#34;: {
		&amp;#34;value&amp;#34;: &amp;#34;[parameters(&amp;#39;secretValue&amp;#39;)]&amp;#34;,
		&amp;#34;contentType&amp;#34; : &amp;#34;string&amp;#34;
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In this resource definition, the type of the resource is &lt;code&gt;Microsoft.KeyVault/vaults/secrets&lt;/code&gt;. The &lt;code&gt;secretName&lt;/code&gt; that you want to use will be provided as the name of the resource and the value will be set in the resource properties.&lt;/p&gt;
&lt;p&gt;Here is the full template that can be used to provision a key vault and then add a secret to it.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/rchaganti/d7e35878c6687da07ae5fa5dfb7d54c2.js?file=azKVbeginnerStoreSecret.azrm.json&#34;&gt;&lt;/script&gt;

&lt;p&gt;This updated template added two more parameters &amp;ndash; &lt;code&gt;secretName&lt;/code&gt; and &lt;code&gt;secretValue&lt;/code&gt;. &lt;code&gt;secretValue&lt;/code&gt; is a secure string. Try deploying the template using the deploy to Azure button below.&lt;/p&gt;

    &lt;a href=&#34;https://portal.azure.com/#create/Microsoft.Template/uri/https%3a%2f%2fgist.githubusercontent.com%2frchaganti%2fd7e35878c6687da07ae5fa5dfb7d54c2%2fraw%2fb605dc41251aea40dae877f352a0b35998944076%2fazKVbeginnerStoreSecret.azrm.json&#34; target=&#34;_blank&#34;&gt;
        &lt;img src=&#34;https://raw.githubusercontent.com/Azure/azure-quickstart-templates/master/1-CONTRIBUTION-GUIDE/images/deploytoazure.svg?sanitize=true&#34; alt=&#34;&#34;&gt;
    &lt;/a&gt;
    &lt;br /&gt;

&lt;h3 id=&#34;retrieve-vault-secret&#34;&gt;Retrieve vault secret&lt;/h3&gt;
&lt;p&gt;Finally, when you have to use the secret as another resource property value, you can do that using a property definition as shown below.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&amp;#34;adminPassword&amp;#34;: {
    &amp;#34;reference&amp;#34;: {
        &amp;#34;keyVault&amp;#34;: {
        &amp;#34;id&amp;#34;: &amp;#34;/subscriptions/&amp;lt;SubscriptionID&amp;gt;/resourceGroups/mykeyvaultdeploymentrg/providers/Microsoft.KeyVault/vaults/&amp;lt;KeyVaultName&amp;gt;&amp;#34;
        },
        &amp;#34;secretName&amp;#34;: &amp;#34;vmAdminPassword&amp;#34;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;You will learn more about this pattern in the later articles of this series when you attempt creating virtual machines using ARM template.&lt;/p&gt;
&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;
&lt;p&gt;In this part, you learned how to create an Azure Key Vault, add secrets to the vault, and retrieve the secrets. This knowledge will come handy when you attempt creating virtual machines that require a predefined administrator password. In the next part, you will learn about resource dependencies in ARM templates.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Azure Resource Manager - Using functions in ARM templates</title>
      <link>https://ravichaganti.com/blog/azure-resource-manager-using-functions-in-arm-templates/</link>
      <pubDate>Fri, 31 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ravichaganti.com/blog/azure-resource-manager-using-functions-in-arm-templates/</guid>
      <description>
    &lt;figure &gt;
        
            &lt;img src=&#34;https://ravichaganti.com/images/armin30/templatearchitecture.png&#34; width=&#34;760&#34; /&gt;
        
        
    &lt;/figure&gt;
    
&lt;p&gt;&lt;a href=&#34;https://ravichaganti.com/blog/azure-resource-manager-in-30-days-using-expressions-and-variables-in-arm-templates/&#34;&gt;Expressions in ARM template language&lt;/a&gt; are a way to reduce complexity in the templates. &lt;a href=&#34;https://ravichaganti.com/blog/azure-resource-manager-adding-parameters-to-arm-templates/&#34;&gt;Using parameters and variables in ARM templates&lt;/a&gt; always requires the use of expressions. Parameter and variable values are combined with standard (built-in) template functions (STF) to create complex expressions to implement the business requirements and implement known configurations. Updated ARM template syntax introduced the ability to implement user-defined functions for complicated expressions and use repeatedly in your templates. In this part, you will learn more about standard template functions and learn how to implement user-defined functions.&lt;/p&gt;
&lt;h2 id=&#34;standard-template-functions&#34;&gt;Standard template functions&lt;/h2&gt;
&lt;p&gt;There are different categories of &lt;a href=&#34;https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/template-functions&#34;&gt;standard template functions&lt;/a&gt;. To work with arrays, &lt;a href=&#34;https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/template-functions-array&#34;&gt;array functions&lt;/a&gt; can be used. For example, &lt;code&gt;contains()&lt;/code&gt; function can be used to check whether an array / object / string contains a value / key / substring. This function returns true if the item is found an false otherwise. Here is an example.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/rchaganti/d7e35878c6687da07ae5fa5dfb7d54c2.js?file=stfArrayContains.json&#34;&gt;&lt;/script&gt;

&lt;p&gt;In this example, the parameter &lt;code&gt;locations&lt;/code&gt; has a default value so you do not have to pass any parameter values while evaluating this template &lt;a href=&#34;https://ravichaganti.com/blog/azure-resource-manager-in-30-days-using-expressions-and-variables-in-arm-templates/#evaluating-expressions&#34;&gt;using the method you used in the last part&lt;/a&gt;. Within the &lt;code&gt;outputs&lt;/code&gt; element, there are two output values defined within which the &lt;code&gt;contains()&lt;/code&gt; function is used. One function checks for a value that exists on the parameter value (therefore returns true) and the second one checks for a value that does not exist in the parameter value and therefore returns false.&lt;/p&gt;

    &lt;figure &gt;
        
            &lt;img src=&#34;https://ravichaganti.com/images/armin30/stfArrayContainsOutput.png&#34; width=&#34;670&#34; /&gt;
        
        
    &lt;/figure&gt;
    
&lt;p&gt;In the last part, you tried a few examples of STF already. At a high level, you can classify the STF into two categories &amp;ndash; compile-time and run-time. The examples that we have seen so far are compile-time functions. The compile-time functions evaluate before the deployment begins. The run-time functions evaluate once the deployment begins. One example of a run-time function is the &lt;code&gt;listKeys()&lt;/code&gt; function. Using this template function, here is how you retrieve the storage account key for a given storage account.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;[
    &lt;span style=&#34;color:#f00&#34;&gt;listKeys(&lt;/span&gt;
        &lt;span style=&#34;color:#f00&#34;&gt;resourceId(&lt;/span&gt;
            &lt;span style=&#34;color:#f00&#34;&gt;&amp;#39;Microsoft.Storage/storageAccounts&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#f00&#34;&gt;concat(&lt;/span&gt;
                &lt;span style=&#34;color:#f00&#34;&gt;&amp;#39;sacct&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#f00&#34;&gt;&amp;#39;-&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#f00&#34;&gt;uniqueString(&lt;/span&gt;
                    &lt;span style=&#34;color:#f00&#34;&gt;resourceGroup().id&lt;/span&gt;
                &lt;span style=&#34;color:#f00&#34;&gt;)&lt;/span&gt;
            &lt;span style=&#34;color:#f00&#34;&gt;)&lt;/span&gt;
        &lt;span style=&#34;color:#f00&#34;&gt;)&lt;/span&gt;, &lt;span style=&#34;color:#f00&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2019-06-01&lt;/span&gt;&lt;span style=&#34;color:#f00&#34;&gt;&amp;#39;&lt;/span&gt;
    &lt;span style=&#34;color:#f00&#34;&gt;).keys&lt;/span&gt;[&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;]&lt;span style=&#34;color:#f00&#34;&gt;.value&lt;/span&gt;
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In the above example, two arguments are passed to the &lt;code&gt;listKeys()&lt;/code&gt; &lt;a href=&#34;https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/template-functions-resource#list&#34;&gt;function&lt;/a&gt;. First one is the &lt;code&gt;resourceId()&lt;/code&gt; &lt;a href=&#34;https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/template-functions-resource#resourceid&#34;&gt;function&lt;/a&gt; to retrieve the unique ID of the storage account that you provisioned. Second parameter is the API version used to deploy the resource. The final part of the expression &lt;code&gt;.keys[0].value&lt;/code&gt; is the array reference to retrieve the value of primary storage key.&lt;/p&gt;
&lt;p&gt;Here is another example of a run-time function. This is called &lt;a href=&#34;https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/template-functions-resource#reference&#34;&gt;reference()&lt;/a&gt;. This function returns the runtime state of a resource.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;[
    &lt;span style=&#34;color:#f00&#34;&gt;reference(&lt;/span&gt;
        &lt;span style=&#34;color:#f00&#34;&gt;concat(&amp;#39;Microsoft.Storage/storageAccounts/&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#f00&#34;&gt;concat(&lt;/span&gt;
                &lt;span style=&#34;color:#f00&#34;&gt;&amp;#39;sacct&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#f00&#34;&gt;&amp;#39;-&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#f00&#34;&gt;uniqueString(resourceGroup().id)&lt;/span&gt;
            &lt;span style=&#34;color:#f00&#34;&gt;)&lt;/span&gt;, &lt;span style=&#34;color:#f00&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2019-06-01&lt;/span&gt;&lt;span style=&#34;color:#f00&#34;&gt;&amp;#39;&lt;/span&gt;
        &lt;span style=&#34;color:#f00&#34;&gt;)&lt;/span&gt;
    &lt;span style=&#34;color:#f00&#34;&gt;).primaryEndpoints.blob&lt;/span&gt;
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Similar to the expression that used &lt;code&gt;listKeys()&lt;/code&gt; function, this one too uses a prefix string, a unique string generated using the resource group ID, and the API version string to retrieve the storage blob URI. This blob URI is retrieved using &lt;code&gt;.primaryEndpoints.blob&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In the above example, &lt;code&gt;concat(&#39;sacct&#39;, &#39;-&#39;, uniqueString(resourceGroup().id))&lt;/code&gt; sub-expression is used to generate a unique name for the storage account. What if you want to use a similar expression for multiple resource names in the ARM template to ensure that your ARM template uses more known configuration? One way to do that is to repeat the expression multiple times with different prefixes as needed. The second and a better way is to create and use an user-defined functions (UDF) where you get the ability to parameterize expressions and reuse the same in your ARM templates like you use built-in functions.&lt;/p&gt;
&lt;h2 id=&#34;user-defined-functions&#34;&gt;User-defined functions&lt;/h2&gt;
&lt;p&gt;With user-defined functions (UDF), you can create your own functions by combining multiple standard template functions into a complicated expression. The following syntax describes how the user-defined functions can be added to ARM templates.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/rchaganti/d7e35878c6687da07ae5fa5dfb7d54c2.js?file=userDefinedFunction.json&#34;&gt;&lt;/script&gt;

&lt;p&gt;A UDF must be a part of a namespace to avoid name conflicts with STF. All your expressions get added to the members object. You need to give your custom function a unique name within the namespace and add parameters and output as needed. Here is a quick example that wraps the above expression into a custom function.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/rchaganti/d7e35878c6687da07ae5fa5dfb7d54c2.js?file=userDefinedFunctionExample.json&#34;&gt;&lt;/script&gt;

&lt;p&gt;In the above example, one parameters &amp;ndash; prefix &amp;ndash; allows you to use the expression with varying input. The output value within the UDF is set to the transformed expression that will use the parameter and return a unique resource name. How do you use this UDF in your template? Simple, like any other built-in function in an expression.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;variables&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f00&#34;&gt;:&lt;/span&gt; {
	&lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;virtualNetworkAddressPrefix&amp;#34;&lt;/span&gt; : &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;10.0.0.0/16&amp;#34;&lt;/span&gt;,
	&lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;virtualNetworkName&amp;#34;&lt;/span&gt; : &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[armin30.uniqueResourceName(&amp;#39;vnet&amp;#39;)]&amp;#34;&lt;/span&gt;,
	&lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;virtualNetworkSubnetName&amp;#34;&lt;/span&gt; : &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[armin30.uniqueResourceName(&amp;#39;subnet&amp;#39;)]&amp;#34;&lt;/span&gt;,
	&lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;storageAccountName&amp;#34;&lt;/span&gt; : &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[armin30.uniqueResourceName(&amp;#39;sacct&amp;#39;)]&amp;#34;&lt;/span&gt;,
	&lt;span style=&#34;font-weight:bold&#34;&gt;&amp;#34;virtualNetworkSubnetAddressPrefix&amp;#34;&lt;/span&gt; : &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;10.0.1.0/24&amp;#34;&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;A UDF is accessed using the &lt;em&gt;namespace.functionName&lt;/em&gt; notation with a list of comma-separated parameter values. This example assign output value from &lt;code&gt;armin30.uniqueResourceName()&lt;/code&gt; function to variables. You can use the UDF directly in resource properties as well.&lt;/p&gt;
&lt;h3 id=&#34;limitations-of-udf&#34;&gt;Limitations of UDF&lt;/h3&gt;
&lt;p&gt;There are few limitations when using user-defined functions.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;You cannot access parameters and variables defined in the ARM template&amp;rsquo;s parameters and variables elements. You can only access parameters defined within the user-defined function and these UDF parameters cannot have any default values.&lt;/li&gt;
&lt;li&gt;There is no nested UDF support.&lt;/li&gt;
&lt;li&gt;The expressions that use reference and list* methods cannot be used within UDF.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Finally, here is the updated template for the scenario you are working on.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/rchaganti/d7e35878c6687da07ae5fa5dfb7d54c2.js?file=d6userDefinedFuncTemplate.json&#34;&gt;&lt;/script&gt;

&lt;p&gt;You can deploy this template by clicking on the deploy to Azure button.&lt;/p&gt;

    &lt;a href=&#34;https://portal.azure.com/#create/Microsoft.Template/uri/https%3a%2f%2fgist.githubusercontent.com%2frchaganti%2fd7e35878c6687da07ae5fa5dfb7d54c2%2fraw%2f1b1f190cab195fb0f7562a7ecc7d3e02886953fd%2fd6userDefinedFuncTemplate.json&#34; target=&#34;_blank&#34;&gt;
        &lt;img src=&#34;https://raw.githubusercontent.com/Azure/azure-quickstart-templates/master/1-CONTRIBUTION-GUIDE/images/deploytoazure.svg?sanitize=true&#34; alt=&#34;&#34;&gt;
    &lt;/a&gt;
    &lt;br /&gt;

&lt;p&gt;Once the deployment is complete, you can see the deployed resources in the portal or in the console if you used Azure CLI. Note the random strings with the prefixes that you specified as input to the &lt;code&gt;armin30.uniqueResourceName&lt;/code&gt; UDF.&lt;/p&gt;

    &lt;figure &gt;
        
            &lt;img src=&#34;https://ravichaganti.com/images/armin30/d6templateDeploy.png&#34; width=&#34;860&#34; /&gt;
        
        
    &lt;/figure&gt;
    
&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;
&lt;p&gt;With the help of parameters, variables, expressions, and user-defined functions you get the ability to simplify the ARM template authoring process and make the templates more readable. There are many standard template functions that help you simplify the ARM template resource definitions. When you have to repeat and reuse some of the complicated expressions in an ARM template, you can wrap the expression as a user-defined function and use the UDF in the resource definition. In the next part of the series, you will learn how to use secrets in an ARM template.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Azure Resource Manager - Using expressions and variables in ARM templates</title>
      <link>https://ravichaganti.com/blog/azure-resource-manager-in-30-days-using-expressions-and-variables-in-arm-templates/</link>
      <pubDate>Thu, 30 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ravichaganti.com/blog/azure-resource-manager-in-30-days-using-expressions-and-variables-in-arm-templates/</guid>
      <description>
    &lt;figure &gt;
        
            &lt;img src=&#34;https://ravichaganti.com/images/armin30/templatearchitecture.png&#34; width=&#34;760&#34; /&gt;
        
        
    &lt;/figure&gt;
    
&lt;p&gt;So far in &lt;a href=&#34;https://ravichaganti.com/series/azure-resource-manager-in-30-days/&#34;&gt;this series&lt;/a&gt;, you learned how to use VS Code and ARM Tools extension to get started with the ARM template development, how to perform a subscription scoped deployment to create a resource group and then looked at resource group scoped deployment to create a storage account and a virtual network resources. You learned about parameterizing the ARM template so that it becomes reusable. Equipped with that knowledge, you can now start digging into expressions and variables in the ARM templates.&lt;/p&gt;
&lt;h2 id=&#34;expressions&#34;&gt;Expressions&lt;/h2&gt;
&lt;p&gt;You have already used expressions in the template you built in the last part. For example, &lt;code&gt;[parameters(&#39;storageAccountSku&#39;)]&lt;/code&gt; is an expression that you used. Within an ARM template, expressions are a way to dynamically determine values of resource properties and other artifacts. Expressions are invoked within square brackets and are calculated at deployment time. When creating an expression, you can combine multiple &lt;a href=&#34;https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/template-functions&#34;&gt;template functions&lt;/a&gt;. For example, in the previous template that provisioned a storage account and a virtual network, the storage account name has to be unique. Now, either you can let the end user figure out a unique string for this resource property by trial and error or you can use an expression such as &lt;code&gt;[concat(&#39;sacct&#39;, &#39;-&#39;, uniqueString(resourceGroup().id))]&lt;/code&gt; to generate a random string to use as a name for the storage account you want provision. Remember that, within the same resource group, the value generated by this expression will always be same since the seed to the &lt;code&gt;uniqueString()&lt;/code&gt; function will always be same. So, when you deploy a template that uses this expression multiple times, no action will be taken if the storage account already exists with the name.&lt;/p&gt;
&lt;p&gt;There are several categories of standard (built-in) template functions that you can use to simplify template authoring and deployment experience. These functions include comparison and logical functions, numeric and string functions, array, object, and date functions, and resource and deployment value functions. For example, the &lt;code&gt;concat()&lt;/code&gt; function that you saw in the earlier example is a part of &lt;a href=&#34;https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/template-functions-string&#34;&gt;string functions&lt;/a&gt; category. It takes multiple strings and returns a concatenated string. A &lt;code&gt;concat()&lt;/code&gt; function exists in the &lt;a href=&#34;https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/template-functions-array&#34;&gt;array functions&lt;/a&gt; category as well and works on arrays and returns a concatenated array. The &lt;code&gt;uniqueString()&lt;/code&gt; function is in the string functions category and generates a hash based on the value passed as its argument. The &lt;code&gt;resourceGroup()&lt;/code&gt; function is a part of the &lt;a href=&#34;https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/template-functions-resource&#34;&gt;resource functions&lt;/a&gt; category and returns the properties of the resource group within which the deployment is in progress.&lt;/p&gt;
&lt;p&gt;Let us see another example of using expressions in ARM templates. In the template that was develope d in the last part, the &lt;code&gt;storageAccountName&lt;/code&gt; parameter was used the capture the input for the name property of the storage account resource. In this parameter definition, &lt;code&gt;minLength&lt;/code&gt; and &lt;code&gt;maxLength&lt;/code&gt; elements were used to ensure the string length is between 3 and 24 characters. However, the name of the storage account name should always be in lower case. There is no element in parameter definition to describe this validation. This can be achieved by using the &lt;code&gt;toLower()&lt;/code&gt; function from the string functions category to transform the user provided input value into a lower case string. Here is how it can be done.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/rchaganti/d7e35878c6687da07ae5fa5dfb7d54c2.js?file=storageResourceWithToLower.json&#34;&gt;&lt;/script&gt;

&lt;p&gt;These are just a few examples of how you can use standard template functions in ARM templates as a part of different expressions. I recommend that you read through the &lt;a href=&#34;https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/template-functions&#34;&gt;documentation&lt;/a&gt; to understand how to use these functions in an expression and explore how you can simplify the template deployment experience. But, how do you evaluate an expression that you want to use in an ARM template?&lt;/p&gt;
&lt;h3 id=&#34;evaluating-expressions&#34;&gt;Evaluating Expressions&lt;/h3&gt;
&lt;p&gt;Waiting for a real resource template deployment may be not be a great idea and a way to evaluate expression output without initiating a real deployment would be beneficial. This is totally possible with the &lt;code&gt;outputs&lt;/code&gt; element in an ARM template.&lt;/p&gt;
&lt;p&gt;As you learned in the template basics, the &lt;code&gt;outputs&lt;/code&gt; element in a template is used to return values from after a deployment is complete. This is especially useful in automated deployment processes. Except for a few that are runtime functions such as &lt;code&gt;reference()&lt;/code&gt;, this method can be used with most of the standard template functions and expressions that you create. In general, the following snippet shows the syntax of &lt;code&gt;outputs&lt;/code&gt; element.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/rchaganti/d7e35878c6687da07ae5fa5dfb7d54c2.js?file=outputSyntax.json&#34;&gt;&lt;/script&gt;

&lt;p&gt;This is a simplified syntax of &lt;code&gt;outputs&lt;/code&gt; element. There are other properties you can use but for now, this is good enough.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Element Name&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;th&gt;Is Required&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;output-name&lt;/td&gt;
&lt;td&gt;Name of the output value&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;type&lt;/td&gt;
&lt;td&gt;type of the output value&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;value&lt;/td&gt;
&lt;td&gt;Expression that should be evaluated and returned as output value&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;To try this method of using &lt;code&gt;outputs&lt;/code&gt; element , you can create an ARM template with no resource definitions as shown below.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/rchaganti/d7e35878c6687da07ae5fa5dfb7d54c2.js?file=outputDemo.azrm.json&#34;&gt;&lt;/script&gt;

&lt;p&gt;In the outputs element definition, the name of the output value has been set to &lt;code&gt;lowercaseStorageAccountName&lt;/code&gt; and the output value is set to &lt;code&gt;[toLower(parameters(&#39;StorageAccountName&#39;))]&lt;/code&gt;. Although there is just one output from this example template, there can be any number of outputs from a given ARM template. The above ARM template can be deployed using of the known deployment tools to see the value the expression evaluates to. Let us see an example using Azure CLI.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/rchaganti/d7e35878c6687da07ae5fa5dfb7d54c2.js?file=deployForEvalOutput.azcli&#34;&gt;&lt;/script&gt;

&lt;p&gt;In the command above, inline parameter specification has been used and the value for the &lt;code&gt;storageAccountName&lt;/code&gt; has been set to a string containing mixed case characters. The expression used in the output value element should return this string with all characters in lower case.&lt;/p&gt;
&lt;p&gt;When you deploy using Azure CLI or Azure PowerShell, the command output contains the deployment output as well when the template deployment completes successfully. The default output format in Azure CLI is JSON. So, when the command completes successfully, you will see the JSON string returned to the command console.&lt;/p&gt;

    &lt;figure &gt;
        
            &lt;img src=&#34;https://ravichaganti.com/images/armin30/outputEvalExprDemo.png&#34; width=&#34;670&#34; /&gt;
        
        
    &lt;/figure&gt;
    
&lt;p&gt;This JSON output can be queried using &lt;a href=&#34;https://docs.microsoft.com/en-us/cli/azure/query-azure-cli?view=azure-cli-latest&#34;&gt;JMESPath&lt;/a&gt;. All you have to do is append &lt;code&gt;--query properties.outputs.&amp;lt;output_value_name&amp;gt;.value&lt;/code&gt; to the above Azure CLI deployment command.&lt;/p&gt;
&lt;p&gt;Output values from the template&amp;rsquo;s &lt;code&gt;outputs&lt;/code&gt; element can be seen in the Azure portal as well if you navigate to the resource group and check the deployment history.&lt;/p&gt;

    &lt;figure &gt;
        
            &lt;img src=&#34;https://ravichaganti.com/images/armin30/portalOutput.png&#34; width=&#34;670&#34; /&gt;
        
        
    &lt;/figure&gt;
    
&lt;h2 id=&#34;variables&#34;&gt;Variables&lt;/h2&gt;
&lt;p&gt;Variables are a way to help reduce complexity in an ARM template. In the template that deployed a storage account and a virtual network, we used seven parameters to collect the input required for the template deployment. This provides flexibility in choosing desired values for the deployment. While this flexibility is good, you may want to use fixed address prefixes for virtual network and subnets that you deploy as a part of the template. One way to achieve this is to hard code these values in resource properties. Hard coding values results in repetition and any unintentional mistakes that lead to errors in deployment. Also, there may be certain resource property values that you want to auto-generate based on the value of a specific parameter. This is where variables in ARM template syntax play a role.&lt;/p&gt;
&lt;p&gt;Here is the simplified syntax for adding variables in an ARM template.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/rchaganti/d7e35878c6687da07ae5fa5dfb7d54c2.js?file=variableSyntax.json&#34;&gt;&lt;/script&gt;

&lt;p&gt;Simple variable declaration is straightforward. You just need to add a key-value pair for the variable name and it&amp;rsquo;s value. Here is how you may simplify the earlier template.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/rchaganti/d7e35878c6687da07ae5fa5dfb7d54c2.js?file=variablesForStorageAndVNet.json&#34;&gt;&lt;/script&gt;

&lt;p&gt;This variable definition eliminates the need for three parameters - &lt;code&gt;virtualNetworkAddressPrefix&lt;/code&gt;, &lt;code&gt;virtualNetworkSubnetName&lt;/code&gt;, and &lt;code&gt;virtualNetworkSubnetAddressPrefix&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;accessing-variable-values&#34;&gt;Accessing variable values&lt;/h3&gt;
&lt;p&gt;Within the resource definitions, you can access the values of variables using the &lt;code&gt;variables()&lt;/code&gt; function in an expression. Here is the updated template that uses variables for a few resource properties.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/rchaganti/d7e35878c6687da07ae5fa5dfb7d54c2.js?file=d5RgScopedStorageVNetTemplateFinal.json&#34;&gt;&lt;/script&gt;

&lt;p&gt;You can deploy this template by clicking on the deploy to Azure button.&lt;/p&gt;

    &lt;a href=&#34;https://portal.azure.com/#create/Microsoft.Template/uri/https%3a%2f%2fgist.githubusercontent.com%2frchaganti%2fd7e35878c6687da07ae5fa5dfb7d54c2%2fraw%2fd5RgScopedStorageVNetTemplateFinal.json&#34; target=&#34;_blank&#34;&gt;
        &lt;img src=&#34;https://raw.githubusercontent.com/Azure/azure-quickstart-templates/master/1-CONTRIBUTION-GUIDE/images/deploytoazure.svg?sanitize=true&#34; alt=&#34;&#34;&gt;
    &lt;/a&gt;
    &lt;br /&gt;

&lt;p&gt;In the portal template deployment experience, you will see that the number of input parameters have reduced but the final result stays same. You can try deploying this template via the Azure CLI using the same set of commands you tried in the last part.&lt;/p&gt;
&lt;h3 id=&#34;free-form-vs-known-configuration&#34;&gt;Free-form vs known configuration&lt;/h3&gt;
&lt;p&gt;So far in this series, you have learned about are parameters, variables, and learn to use them in ARM templates. Parameters enable the flexibility to gather input from user deploying the template. You can parameterize a complete template and let the user provide every value needed for the deployment as an input parameter. This is called &lt;strong&gt;free-form configuration&lt;/strong&gt;. However, using free-form configuration is not always scalable. The number of parameters that a user need to input might be overwhelming. Also, you don’t want your end user deploying this template to mess-up with critical resource properties such as virtual network and subnet address prefixes. This can have negative effects on the overall infrastructure deployment. As you have seen in the updated template, you might always want to use fixed values for certain parameters where there is scope for errors. Some of this cannot be controlled unless you use &lt;strong&gt;known configurations&lt;/strong&gt;. Known configurations help standardize resource configurations. Use variables in the template for resource settings that require no user input or you need control over. By using variables, you can simply change the value of the variable if at all you need to modify the template instead of trying to find where all the value is used.&lt;/p&gt;
&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;
&lt;p&gt;Expressions syntax in ARM templates enable combining multiple standard functions provided by the ARM template language. Variables when combined with expression syntax can simplify the overall template authoring experience. Choosing between free-form vs known configurations for the ARM template, you can create a template that is both flexible and implements known configurations to control how the deployed infrastructure gets configured. With this knowledge around parameters, variables, and expressions, in the next part of this series, you will learn more about some of the standard functions and learn how to implement user-defined functions.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Azure Resource Manager - Adding parameters to ARM templates</title>
      <link>https://ravichaganti.com/blog/azure-resource-manager-adding-parameters-to-arm-templates/</link>
      <pubDate>Fri, 24 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ravichaganti.com/blog/azure-resource-manager-adding-parameters-to-arm-templates/</guid>
      <description>
    &lt;figure &gt;
        
            &lt;img src=&#34;https://ravichaganti.com/images/armin30/templatearchitecture.png&#34; width=&#34;760&#34; /&gt;
        
        
    &lt;/figure&gt;
    
&lt;p&gt;In the &lt;a href=&#34;https://ravichaganti.com/blog/azure-resource-manager-arm-template-basics/&#34;&gt;last part&lt;/a&gt; of &lt;a href=&#34;https://ravichaganti.com/series/azure-resource-manager-in-30-days/&#34;&gt;this series&lt;/a&gt;, you learned the template syntax and authored an ARM template that provisions the resource group needed for the above architecture. This deployment was performed at the subscription level using Azure CLI. In this part, you will create another template for performing additional resource &amp;ndash; storage account and virtual network &amp;ndash; provisioning at the resource group level. You will, then, parameterize this template to understand how to add parameters to ARM templates.&lt;/p&gt;
&lt;h2 id=&#34;resource-group-deployment&#34;&gt;Resource group deployment&lt;/h2&gt;
&lt;p&gt;Deployments scoped at the resource group level are the most common deployments. In this method, you provision resources within a resource group in your subscription. Within the VS Code editor, typing &lt;code&gt;arm!&lt;/code&gt; brings up the snippet for a resource group scoped ARM template.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/rchaganti/d7e35878c6687da07ae5fa5dfb7d54c2.js?file=rgScopedDeploymentSkeleton.azrm.json&#34;&gt;&lt;/script&gt;

&lt;p&gt;You can see in the above snippet that the &lt;code&gt;$schema&lt;/code&gt; value is different from what was used for a subscription scoped deployment. Within this template, you can either right-click in the editor window and select Insert Item in the context menu and select Resource or click &lt;code&gt;+&lt;/code&gt; next to resources in the ARM template outline to add any additional resources you need.&lt;/p&gt;

    &lt;figure &gt;
        
            &lt;img src=&#34;https://ravichaganti.com/images/armin30/d3-insertresource.png&#34; width=&#34;760&#34; /&gt;
        
        
    &lt;/figure&gt;
    
&lt;p&gt;Either of these options will present you with a list of available resource types. To add a storage account resource type, select &lt;code&gt;Storage Account&lt;/code&gt; from the list of resources. You may go ahead and add a virtual network resource as well. This is how the updated template will look like.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/rchaganti/d7e35878c6687da07ae5fa5dfb7d54c2.js?file=rgScopedDeployment.azrm.json&#34;&gt;&lt;/script&gt;

&lt;p&gt;As you see here, the insert resources method adds the resource definitions with pre-defined default values. You may not be able deploy this as-is since some of the resource names (storage account especially) might be taken already. You may enter some unique names for the resources and try template deployment using the deploy to Azure button below.&lt;/p&gt;

    &lt;a href=&#34;https://portal.azure.com/#create/Microsoft.Template/uri/https%3a%2f%2fgist.githubusercontent.com%2frchaganti%2fd7e35878c6687da07ae5fa5dfb7d54c2%2fraw%2frgScopedDeployment.azrm.json&#34; target=&#34;_blank&#34;&gt;
        &lt;img src=&#34;https://raw.githubusercontent.com/Azure/azure-quickstart-templates/master/1-CONTRIBUTION-GUIDE/images/deploytoazure.svg?sanitize=true&#34; alt=&#34;&#34;&gt;
    &lt;/a&gt;
    &lt;br /&gt;

&lt;p&gt;When this template opens in the Azure portal, you will be prompted to select either an existing resource group or create a new resource group. Since you already created a resource group in the last part of this series, you can select the same. For the resources (storage account and virtual network), the selected resource group&amp;rsquo;s location will be used. This is specified in the template using the built-in &lt;code&gt;resourceGroup()&lt;/code&gt; function. You will learn more about these functions and expressions in a later part of the series. For now, just remember that &lt;code&gt;resourceGroup().location&lt;/code&gt; will give the location of the resource group selected for the resources&amp;rsquo; deployment.&lt;/p&gt;
&lt;h2 id=&#34;parameters-in-arm-templates&#34;&gt;Parameters in ARM templates&lt;/h2&gt;
&lt;p&gt;The template that you just built provides a good foundation to start experimenting with parameters in an ARM template. In the template above, there are several resource properties that can be parameterized so that the template becomes reusable between multiple deployments by providing the necessary input parameters. So, if you have to identify a few parameters within each resource, you may come with a list similar to the one below.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Resource&lt;/th&gt;
&lt;th&gt;Parameter Names&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;storageAccounts&lt;/td&gt;
&lt;td&gt;storageAccountName, storageAccountSku, storageAccountTier&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;virtualNetworks&lt;/td&gt;
&lt;td&gt;virtualNetworkName, virtualNetworkAddressPrefix, VirtualNetworkSubnetName, virtualNetworkSubnetAddressPrefix&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;With this list handy, take a look at the syntax for adding parameters.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/rchaganti/d7e35878c6687da07ae5fa5dfb7d54c2.js?file=parameterSyntax.json&#34;&gt;&lt;/script&gt;

&lt;p&gt;Within all possible elements described above for defining a parameter, only name and type are mandatory. Rest all elements provide a way to control the input values. For the type element, the allowed values are string, int, bool, securestring, object, secureObject, and array. The type of a parameter depends on the resource property that we choose to parameterize.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;allowedValues&lt;/code&gt; element in parameters can be used to define a set of valid values for the selected resource property. For example, Azure supports two type of storage tiers &amp;ndash; standard and premium &amp;ndash; for any storage SKU. Any other value for this property will be invalid. When an end user does not select any value out of the allowed values for a property, you can default to a known value using the &lt;code&gt;defaultValue&lt;/code&gt; element.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;maxLength&lt;/code&gt; and &lt;code&gt;minLength&lt;/code&gt; are used for string data types. Within the above template, these elements can be used for the &lt;code&gt;name&lt;/code&gt; property of the resources to define the minimum and maximum allowed length of the string input. For example, an Azure storage account name should be between 3 to 24 characters in length. These elements can be used with array type as well.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;minValue&lt;/code&gt; and &lt;code&gt;maxValue&lt;/code&gt; elements are used for parameters of int type. In the parameter selection that we did, there is no need for using these elements yet. You will see the use of these elements in a later part of this series.&lt;/p&gt;
&lt;p&gt;With this understanding, you can define the parameters for this template as below.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/rchaganti/d7e35878c6687da07ae5fa5dfb7d54c2.js?file=parametersford4template.json&#34;&gt;&lt;/script&gt;

&lt;p&gt;The parameter definitions above provide a clear idea about how to use the &lt;code&gt;allowedValues&lt;/code&gt; and &lt;code&gt;defaultValue&lt;/code&gt; elements in a parameter definition. Now, how do you use these parameter values in the template for resource properties?&lt;/p&gt;
&lt;h3 id=&#34;using-parameter-values&#34;&gt;Using parameter values&lt;/h3&gt;
&lt;p&gt;The built-in &lt;code&gt;parameters()&lt;/code&gt; function can be used to retrieve the value provided by the end user as a part of template deployment. This function takes the parameter name as the argument and retrieves the value. For example, &lt;code&gt;[parameters(&#39;storageAccountSku&#39;)]&lt;/code&gt;. You may now update the template above to change the static values to use the &lt;code&gt;parameters()&lt;/code&gt; function.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/rchaganti/d7e35878c6687da07ae5fa5dfb7d54c2.js?file=d4RgScopedStorageVNetTemplateFinal.azrm.json&#34;&gt;&lt;/script&gt;

&lt;h3 id=&#34;deploying-parameterized-templates&#34;&gt;Deploying parameterized templates&lt;/h3&gt;
&lt;p&gt;You can try deploying the parameterized template by clicking on the below deploy to Azure button.&lt;/p&gt;

    &lt;a href=&#34;https://portal.azure.com/#create/Microsoft.Template/uri/https%3a%2f%2fgist.githubusercontent.com%2frchaganti%2fd7e35878c6687da07ae5fa5dfb7d54c2%2fraw%2fd4RgScopedStorageVNetTemplateFinal.azrm.json&#34; target=&#34;_blank&#34;&gt;
        &lt;img src=&#34;https://raw.githubusercontent.com/Azure/azure-quickstart-templates/master/1-CONTRIBUTION-GUIDE/images/deploytoazure.svg?sanitize=true&#34; alt=&#34;&#34;&gt;
    &lt;/a&gt;
    &lt;br /&gt;

&lt;p&gt;This will bring up the input blade for this template deployment.&lt;/p&gt;

    &lt;figure &gt;
        
            &lt;img src=&#34;https://ravichaganti.com/images/armin30/d4-finalportaldeployment.png&#34; width=&#34;660&#34; /&gt;
        
        
    &lt;/figure&gt;
    
&lt;p&gt;Take a look at how the array value for the virtual network address prefix is provided. The &lt;code&gt;*&lt;/code&gt; next to a parameter name indicates a mandatory parameter or a parameter that has no default value. If you hover the &lt;code&gt;!&lt;/code&gt; icon next to the parameter name to see (balloon tip) what the parameter is about. This text is you added in the parameter &lt;code&gt;metadata&lt;/code&gt; element as &lt;code&gt;description&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The parameter &amp;lsquo;Virtual Network Address Prefix&amp;rsquo; accepts values of array type and it can be seen from the example above how array values are provided. The array values must be enclosed in square brackets.&lt;/p&gt;
&lt;p&gt;Now that you have tried the portal experience of deploying templates, take a look at how you can do that at the command line using Azure CLI. With Azure CLI, there are many ways of providing template parameter input. Inline parameter values is one such method.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/rchaganti/d7e35878c6687da07ae5fa5dfb7d54c2.js?file=d4-deployTemplateInlineParam.azcli&#34;&gt;&lt;/script&gt;

&lt;p&gt;In the above command, a resource group for the template deployment gets created first. The &lt;code&gt;az deployment group create&lt;/code&gt; command performs the template deployment by using the template URL as the argument to &lt;code&gt;--template-uri&lt;/code&gt; parameter and &lt;code&gt;--parameters&lt;/code&gt; is used to supply all template input parameter values. The URL specified as argument to the &lt;code&gt;--template-uri&lt;/code&gt; parameter must be accessible from Azure. As an alternate to the &lt;code&gt;--template-uri&lt;/code&gt; parameter, you can use the &lt;code&gt;--template-file&lt;/code&gt; to specify a local path to the template JSON file.&lt;/p&gt;
&lt;p&gt;As you see in the above Azure CLI command, all mandatory parameters (parameters with no default values) should be provided as key-value pairs separated by space. This can be quite daunting and error-prone if you have a lot of template parameters. You can also provide a JSON string as an argument to &lt;code&gt;--parameters&lt;/code&gt;. Also, when using Azure CLI, you must know the names of the parameters to be supplied as input. This is where the parameter files will come in very handy. You can either create one manually or use ARM Tools VS Code extension to generate one for you.&lt;/p&gt;
&lt;p&gt;To use VS Code extension to generate the parameter file, right-click anywhere in the template editor window and click &lt;em&gt;Select/Create Parameter File&lt;/em&gt;. In the command window, select &lt;em&gt;New&lt;/em&gt; and then &lt;em&gt;All Parameters&lt;/em&gt;. This will prompt for a name and location for the parameter JSON file. Here is how the generated parameter JSON will look like.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/rchaganti/d7e35878c6687da07ae5fa5dfb7d54c2.js?file=d4-paramJson.json&#34;&gt;&lt;/script&gt;

&lt;p&gt;You can fill-in the required values and use the following Azure CLI command to start the deployment.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/rchaganti/d7e35878c6687da07ae5fa5dfb7d54c2.js?file=d4-deployTemplateWithParamJson.azcli&#34;&gt;&lt;/script&gt;

&lt;p&gt;This command specification is way simpler than using inline parameters or JSON string.&lt;/p&gt;
&lt;p&gt;Apart from the inline key-value pair specification, the @d4-paramJson.json (@{path}) specification references a file in the local folder path. This is most preferred in case of CI &amp;amp; CD of ARM templates in which the parameter JSON file can be auto-generated during build processes. Also, you can use a mix of inline parameters and parameter JSON as well. You can explore more such examples using &lt;code&gt;az deployment group create --help&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;
&lt;p&gt;In this part, you looked at how to add resources to an ARM template and learned how to parameterize the template for reusability. Parameters in ARM templates support multiple data types and learned how to use string and array data types in this article. You will learn about using other data types in the later parts of this series. You learned how to use Azure portal and Azure CLI for template deployments. You looked at using inline parameter key-value specification and looked at creating and using parameter JSON files as well. In the next part, you will learn how to build expressions and variables in ARM templates.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Azure Resource Manager - ARM template basics</title>
      <link>https://ravichaganti.com/blog/azure-resource-manager-arm-template-basics/</link>
      <pubDate>Thu, 23 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ravichaganti.com/blog/azure-resource-manager-arm-template-basics/</guid>
      <description>&lt;p&gt;In the last two parts of &lt;a href=&#34;https://ravichaganti.com/series/azure-resource-manager-in-30-days/&#34;&gt;the series&lt;/a&gt;, you have seen a brief introduction to Azure Resource Manager and the services that complement ARM to extend its functionality or support the services offered by ARM. You also looked at an overview of ARM templates and the tools available to design, author, and deploy these templates.&lt;/p&gt;
&lt;p&gt;Starting this part of the series for the next few days, you will start learning about authoring ARM templates right from the basics and to the advanced template syntax and techniques with a goal to build an ARM template that helps provision the following architecture.&lt;/p&gt;

    &lt;figure &gt;
        
            &lt;img src=&#34;https://ravichaganti.com/images/armin30/templatearchitecture.png&#34; width=&#34;760&#34; /&gt;
        
        
    &lt;/figure&gt;
    
&lt;p&gt;This is not a complex architecture but gives you enough scope to implement what you learn through this series of articles. Apart from this architecture, I recommend that you start looking at the &lt;a href=&#34;https://github.com/Azure/AzureStack-QuickStart-Templates&#34;&gt;quickstart templates repository&lt;/a&gt; and read the templates there to understand the syntax and how some of those templates are written and implement best practices. Throughout this series, you will see examples from quickstart templates repository to explain best practices in template authoring.&lt;/p&gt;
&lt;p&gt;I strongly recommend using VS Code for ARM template authoring and the next section provides a quick overview of this before you dive into ARM template basics.&lt;/p&gt;
&lt;h2 id=&#34;vs-code-and-arm-tools-extension&#34;&gt;VS Code and ARM tools extension&lt;/h2&gt;
&lt;p&gt;If you have already installed VS Code and the ARM tools extension, you may want to customize the extension settings for improved authoring experience and ease. By default, VS Code editor will auto-detect template files if the JSON or JSONC file contains the appropriate schema and changes the editor language to Azure Resource Manager template. You can see this in the status bar of the VS Code editor.&lt;/p&gt;

    &lt;figure &gt;
        
            &lt;img src=&#34;https://ravichaganti.com/images/armin30/d3-editorarm.png&#34; /&gt;
        
        
    &lt;/figure&gt;
    
&lt;p&gt;However, this method requires that you at least have a value for the $schema element. You can also use file association setting to detect a file in the editor as an ARM template. This can be done by adding the following in the extension settings. With this setting in place, you can even create an empty file with an extension azrm.json and the editor auto-detects and sets the editor language as ARM template.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/rchaganti/d7e35878c6687da07ae5fa5dfb7d54c2.js?file=azrmtemplatefileassociation.json&#34;&gt;&lt;/script&gt;

&lt;p&gt;Once the editor language gets set to Azure Resource Manager Template, you can access over 70 snippets that come with the extension. For example, typing arm in the editor window, brings up the snippets that you can select and insert into the editor.&lt;/p&gt;

    &lt;figure &gt;
        
            &lt;img src=&#34;https://ravichaganti.com/images/armin30/d3-armsnippets.png&#34; width=&#34;600&#34; /&gt;
        
        
    &lt;/figure&gt;
    
&lt;p&gt;Throughout this series, you will see different features of this VS Code extension. Now, let us get started with the basics of the ARM template language.&lt;/p&gt;
&lt;h2 id=&#34;basics&#34;&gt;Basics&lt;/h2&gt;
&lt;p&gt;As you have seen already, an ARM template is JSON file with additional template functions and expressions that the Azure Resource Manager understands. Here is a basic skeleton structure of an ARM template.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/rchaganti/d7e35878c6687da07ae5fa5dfb7d54c2.js?file=skeleton.azrm.json&#34;&gt;&lt;/script&gt;

&lt;p&gt;In the following sections, you will see quick overview of the elements in an ARM template.&lt;/p&gt;
&lt;h3 id=&#34;schema&#34;&gt;$schema&lt;/h3&gt;
&lt;p&gt;This element identifies the version of template language to be used. The value of this element changes based on the type of editor and the scope of the deployment. There are four different scopes at which you can deploy an ARM template.&lt;/p&gt;
&lt;h4 id=&#34;subscription-scope&#34;&gt;Subscription Scope&lt;/h4&gt;
&lt;p&gt;When you need to deploy resources at the subscription level, for example create resource groups or provision policies and resource-based access controls, you need to use subscription level deployments. For this type of deployments, the value of &lt;code&gt;$schema&lt;/code&gt; should be &lt;code&gt;https://schema.management.azure.com/schemas/2018-05-01/subscriptionDeploymentTemplate.json#&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;management-group-scope&#34;&gt;Management Group Scope&lt;/h4&gt;
&lt;p&gt;Management groups in Azure are used to organize subscriptions for better governance. When you need to provision resources such as policies at the management group level, you need to the use the management group level schema. The value of this element for management group level deployments should be &lt;code&gt;https://schema.management.azure.com/schemas/2019-08-01/managementGroupDeploymentTemplate.json#&lt;/code&gt;.&lt;/p&gt;
&lt;h4 id=&#34;tenant-scope&#34;&gt;Tenant Scope&lt;/h4&gt;
&lt;p&gt;For provisioning resources across multiple Azure AD tenants, you need the tenant scoped deployments. For tenant level deployments the value of &lt;code&gt;$schema&lt;/code&gt; element should be set to &lt;code&gt;https://schema.management.azure.com/schemas/2019-08-01/tenantDeploymentTemplate.json#&lt;/code&gt;.&lt;/p&gt;
&lt;h4 id=&#34;resource-group-scope&#34;&gt;Resource Group Scope&lt;/h4&gt;
&lt;p&gt;This is the typical type of deployment you will normally come across. When using this deployment scope, you describe resources that need to be deployed within a given resource group in a subscription. The value of &lt;code&gt;$schema&lt;/code&gt; for this type of deployments in VS Code should be &lt;code&gt;https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#&lt;/code&gt;. For Visual Studio, this value should be &lt;code&gt;https://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;You will learn more about scoped deployments in a later article in this series.&lt;/p&gt;
&lt;h3 id=&#34;contentversion&#34;&gt;ContentVersion&lt;/h3&gt;
&lt;p&gt;This element identifies the version of the template content. This value is required but can be set to anything you want. If you use source control for ARM templates, you can increment the value of this element in your template at every commit. You will learn more about this in a later article discussing CI &amp;amp; CD of ARM templates.&lt;/p&gt;
&lt;h3 id=&#34;parameters&#34;&gt;Parameters&lt;/h3&gt;
&lt;p&gt;This element accepts a set of parameters that act as input to the ARM template deployment using which you can introduce reusability of ARM templates. If you are familiar with any programming language, similar to a function or a method parameters, ARM template parameters too support different data types, valid values, default values, and different other characteristics such as min and max values (for numeric types), and min and max length (for string types). This is not a mandatory element but highly recommended to parameterize the template.&lt;/p&gt;
&lt;h3 id=&#34;functions&#34;&gt;Functions&lt;/h3&gt;
&lt;p&gt;ARM template syntax support built-in functions and expressions. These functions range from comparison functions to numeric, date, string, and so on. In a later update to the ARM template syntax, support for custom user-defined functions was added. You can now define some complex expressions that you want to use in the template as user-defined functions. This is not a mandatory element.&lt;/p&gt;
&lt;h3 id=&#34;variables&#34;&gt;Variables&lt;/h3&gt;
&lt;p&gt;Variables, similar to functions, can help reduce the complexity of expressions in the ARM template. This is not a mandatory element. In an ARM template, variables are predominantly inside expressions. Between parameters and variables, you need to always a strike balance (free-form vs known configuration) to create templates are easy to deploy.&lt;/p&gt;
&lt;h3 id=&#34;resources&#34;&gt;Resources&lt;/h3&gt;
&lt;p&gt;This element is where you define what Azure resource you need to deploy or update. An ARM template must have at least one resource. The type of valid resources supported in a template depends on the value of &lt;code&gt;$schema&lt;/code&gt; element. In the next section, you will see how to author your first ARM template and you will see more about resource specification in an ARM template.&lt;/p&gt;
&lt;h3 id=&#34;outputs&#34;&gt;Outputs&lt;/h3&gt;
&lt;p&gt;Using this element, you can specify the values returned by the template after the deployment is complete. This element is not mandatory. This can be very useful when using nested templates and you will learn more about it soon in this series.&lt;/p&gt;
&lt;h2 id=&#34;first-arm-template&#34;&gt;First ARM template&lt;/h2&gt;
&lt;p&gt;Alright! After that quick overview of the template elements, this section will get you started with your first ARM template. For this purpose, you will perform a subscription scoped deployment to provision a new resource group. Within VS Code, if you want a quick snippet that supports subscription level deployments, you can type &lt;code&gt;arm!s&lt;/code&gt; and press enter. You can now add the following snippet under the resource element.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/rchaganti/d7e35878c6687da07ae5fa5dfb7d54c2.js?file=resourceGroup.res&#34;&gt;&lt;/script&gt;

&lt;p&gt;A typical resource specification will be very similar to what is shown above. The following table provides an overview of the resource group object properties that you can use in a template.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Property Name&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;th&gt;Is Mandatory?&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;type&lt;/td&gt;
&lt;td&gt;This property identifies the type of a resource that you want to provision. For a resource group, this will be &lt;code&gt;Microsoft.Resources/resourceGroups&lt;/code&gt;.&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;name&lt;/td&gt;
&lt;td&gt;Using this property, you can specify a name for the resource being provisioned.&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;apiVersion&lt;/td&gt;
&lt;td&gt;This property identifies the API version to be used for provisioning the resource. For a resource group resource, this, at present, should be &lt;code&gt;2020-06-01&lt;/code&gt;.&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;location&lt;/td&gt;
&lt;td&gt;This property specifies where there resource should be created. Some resources may not be supported in all regions or enabled in your subscription.&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;properties&lt;/td&gt;
&lt;td&gt;Specifies additional properties needed for the resource provisioning.&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;tags&lt;/td&gt;
&lt;td&gt;Specifies a list of tags (key-value pairs) associated with the resource.&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;For now, you don&amp;rsquo;t have to worry about the parameters, variables, functions, and outputs in the template. You can simply leave them blank. With the addition of resource group snippet, here is how your first template should look like.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/rchaganti/d7e35878c6687da07ae5fa5dfb7d54c2.js?file=resourceGroup.azrm.json&#34;&gt;&lt;/script&gt;

&lt;p&gt;This is ready for deployment. If you want to use Azure portal for template deployments, the subscription level deployment, at present, is available only in the preview portal. The below deploy to Azure button will take you directly to the preview portal.&lt;/p&gt;

    &lt;a href=&#34;https://preview.portal.azure.com/#create/Microsoft.Template/uri/https%3a%2f%2fgist.githubusercontent.com%2frchaganti%2fd7e35878c6687da07ae5fa5dfb7d54c2%2fraw%2fresourceGroup.azrm.json&#34; target=&#34;_blank&#34;&gt;
        &lt;img src=&#34;https://raw.githubusercontent.com/Azure/azure-quickstart-templates/master/1-CONTRIBUTION-GUIDE/images/deploytoazure.svg?sanitize=true&#34; alt=&#34;&#34;&gt;
    &lt;/a&gt;
    &lt;br /&gt;

&lt;p&gt;If you want to perform this deployment using Azure CLI, you can use the below command to perform this subscription level deployment to create the resource group.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If you have not already done so, you must first authenticate using &lt;code&gt;az login&lt;/code&gt; command.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/rchaganti/d7e35878c6687da07ae5fa5dfb7d54c2.js?file=resourceGroupDeploy.azcli&#34;&gt;&lt;/script&gt;

&lt;p&gt;In the above command, do not confuse the &lt;code&gt;--name&lt;/code&gt; and &lt;code&gt;--location&lt;/code&gt; parameters to what you have in the ARM template. These two parameters indicate the name of the deployment and location where the deployment meta data should be stored. The &lt;code&gt;sub&lt;/code&gt; subcommand within az deployment indicates that you are doing a subscription level deployment.&lt;/p&gt;
&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;
&lt;p&gt;In this part of the article, you looked at basics of ARM template syntax, understood different elements in the template and their purpose, saw a quick overview of scoped deployments, and finally performed a subscription level deployment to create a resource group in your subscription and used Azure CLI for this purpose. In this next part of this series, you will learn how to create reusable ARM templates by adding parameters.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Azure Resource Manager - Tools for ARM template design, authoring, and deployment</title>
      <link>https://ravichaganti.com/blog/azure-resource-manager-tools-for-arm-template-design-authoring-and-deployment/</link>
      <pubDate>Fri, 17 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ravichaganti.com/blog/azure-resource-manager-tools-for-arm-template-design-authoring-and-deployment/</guid>
      <description>&lt;p&gt;The first part of this series of articles on Azure Resource Manager (ARM) provided a quick overview of ARM. You looked a quick introduction to ARM templates as well and looked at an overview of different template deployment methods. In this part of the series, we will look at different methods to author ARM templates and an in-depth look at preferred deployment methods. You can choose any of the methods mentioned here but this series of articles will use one preferred method each for authoring and deploying templates. You will read more about those methods and the reasons behind that choice as well.&lt;/p&gt;
&lt;h2 id=&#34;authoring-tools&#34;&gt;Authoring Tools&lt;/h2&gt;
&lt;p&gt;ARM templates, as mentioned in the last part, are JSON documents. These files can be authored in notepad as well but there are better ways to deal with this task. You will learn about three different methods that I have used and my observations and preferences around these methods. Let us start with the template editor that Azure Portal offers.&lt;/p&gt;
&lt;h3 id=&#34;template-editor-in-azure-portal&#34;&gt;Template Editor in Azure Portal&lt;/h3&gt;
&lt;p&gt;The web-based template editor in the Azure portal is one way but I see it as a better way to edit existing templates than writing one from scratch. You can import a quick start template and use that as a starting point for building your own template.&lt;/p&gt;

    &lt;figure &gt;
        
            &lt;img src=&#34;https://ravichaganti.com/images/armin30/d2-templateeditor-qs.png&#34; width=&#34;860&#34; /&gt;
        
        
    &lt;/figure&gt;
    
&lt;p&gt;Once you click on &lt;em&gt;Quickstart template&lt;/em&gt; [1], you will be shown a list of templates available from the &lt;a href=&#34;https://github.com/Azure/azure-quickstart-templates&#34;&gt;GitHub repository&lt;/a&gt;. The selected template then gets loaded into the editor for further updates or deployment. I selected the &lt;a href=&#34;https://github.com/Azure/azure-quickstart-templates/tree/master/101-vm-simple-windows&#34;&gt;101-vm-simple-windows template&lt;/a&gt; from the list.&lt;/p&gt;

    &lt;figure &gt;
        
            &lt;img src=&#34;https://ravichaganti.com/images/armin30/d2-templateeditor-ar.png&#34; width=&#34;860&#34; /&gt;
        
        
    &lt;/figure&gt;
    
&lt;p&gt;At this point, you can click on &lt;em&gt;Add resource&lt;/em&gt; [2] to add another resource to this template. This will bring up a limited set of additional resources you can add to the loaded template. You may select a Windows Virtual Machine.&lt;/p&gt;

    &lt;figure &gt;
        
            &lt;img src=&#34;https://ravichaganti.com/images/armin30/d2-templateeditor-arwvm.png&#34; width=&#34;860&#34; /&gt;
        
        
    &lt;/figure&gt;
    
&lt;p&gt;This brings up a few input parameters needed for the new VM instance. Once you enter these values and click OK, the template in the editor window gets updated to add the new VM resource instance. You can review the updated template and click on Save to move ahead to deploy this template.&lt;/p&gt;

    &lt;figure &gt;
        
            &lt;img src=&#34;https://ravichaganti.com/images/armin30/d2-templateeditor-deploy.png&#34; width=&#34;860&#34; /&gt;
        
        
    &lt;/figure&gt;
    
&lt;p&gt;At this point, you will presented with a list of input parameters needed for this template deployment. You can enter these values and click &lt;em&gt;Purchase&lt;/em&gt; to start the template validation and deploy it if there are no validation errors. However, it is not always this straightforward. I ended up updating a few language expressions to make this working. If you have tried this option, you will know that the editing experience is limited. It supports adding only a few types of additional resources to the template. And, of course, this isn&amp;rsquo;t a great way to edit or build anything other than a simple template. You need a better way than this web-based editor.&lt;/p&gt;
&lt;h3 id=&#34;visual-studio&#34;&gt;Visual Studio&lt;/h3&gt;
&lt;p&gt;Visual Studio provides a rich integrated development environment (IDE) for developing various types of applications. You can use some of the starter templates packaged along with Visual Studio and build upon those existing templates to add your own resources or start from a blank template and build everything from scratch. For this quick overview of using Visual Studio for template authoring and deployment, I will use Visual Studio 2019 Community Edition.&lt;/p&gt;

    &lt;figure &gt;
        
            &lt;img src=&#34;https://ravichaganti.com/images/armin30/d2-visualstudiostart.png&#34; width=&#34;860&#34; /&gt;
        
        
    &lt;/figure&gt;
    
&lt;p&gt;When you install and open Visual Studio, you will see different options to get started. Select &lt;em&gt;Create a new project&lt;/em&gt;.&lt;/p&gt;

    &lt;figure &gt;
        
            &lt;img src=&#34;https://ravichaganti.com/images/armin30/d2-visualstudio.png&#34; width=&#34;860&#34; /&gt;
        
        
    &lt;/figure&gt;
    
&lt;p&gt;In the next window, filter down the options [1] to Azure and Cloud. In the filtered project templates, select &lt;em&gt;Azure Resource Group&lt;/em&gt; [2] and click &lt;em&gt;Next&lt;/em&gt;.&lt;/p&gt;

    &lt;figure &gt;
        
            &lt;img src=&#34;https://ravichaganti.com/images/armin30/d2-visualstudioconfigure.png&#34; width=&#34;560&#34; /&gt;
        
        
    &lt;/figure&gt;
    
&lt;p&gt;Enter the relevant input for creating a Visual Studio project and click Create.&lt;/p&gt;

    &lt;figure &gt;
        
            &lt;img src=&#34;https://ravichaganti.com/images/armin30/d2-visualstudiotemplate.png&#34; width=&#34;560&#34; /&gt;
        
        
    &lt;/figure&gt;
    
&lt;p&gt;As you see in the above screenshot, you can select one of the canned starter templates or start with a blank template. Since we have learned the basics of template authoring yet, scroll down in the template list and select &lt;em&gt;Windows Virtual Machine&lt;/em&gt; and click OK. This creates the Visual Studio solution.&lt;/p&gt;

    &lt;figure &gt;
        
            &lt;img src=&#34;https://ravichaganti.com/images/armin30/d2-visualstudiosolution.png&#34; width=&#34;860&#34; /&gt;
        
        
    &lt;/figure&gt;
    
&lt;p&gt;Once the solution gets created, click on WindowsVirtualMachine.json [1] in the Solution Explorer pane. This opens the ARM template. On the left-hand side, you can see the JSON Outline [2] pane which shows parameters, variables, and resources defined in the template.&lt;/p&gt;

    &lt;figure &gt;
        
            &lt;img src=&#34;https://ravichaganti.com/images/armin30/d2-visualstudioresource.png&#34; width=&#34;860&#34; /&gt;
        
        
    &lt;/figure&gt;
    
&lt;p&gt;Similar to the Azure Portal template editing experience, you can add resources to this existing template by right-clicking on resources node in the JSON outline and selecting &lt;em&gt;Add New Resource&lt;/em&gt;.&lt;/p&gt;

    &lt;figure &gt;
        
            &lt;img src=&#34;https://ravichaganti.com/images/armin30/d2-visualstudioaddresource.png&#34; width=&#34;560&#34; /&gt;
        
        
    &lt;/figure&gt;
    
&lt;p&gt;From a set of limited resource types, you can select the resource type you want to add, provide the necessary input parameter values and click Add. The selected resource gets added to the template. You can now customize the template and start a deployment. Before you can deploy the template, you will have to provide the values for the template parameters. This can be done by opening the WindowsVirtualMachine.parameters.json file and enter the relevant values.&lt;/p&gt;

    &lt;figure &gt;
        
            &lt;img src=&#34;https://ravichaganti.com/images/armin30/d2-visualstudioeditparams.png&#34; width=&#34;860&#34; /&gt;
        
        
    &lt;/figure&gt;
    
&lt;p&gt;Before starting a deployment of this template, you can validate the template. For that, right click on the solution name in the Solution Explorer and select &lt;em&gt;Validate&lt;/em&gt;.&lt;/p&gt;

    &lt;figure &gt;
        
            &lt;img src=&#34;https://ravichaganti.com/images/armin30/d2-visualstudiovalidate.png&#34; width=&#34;560&#34; /&gt;
        
        
    &lt;/figure&gt;
    
&lt;p&gt;You will be prompted to enter the password for the admin user to continue validation. If the validation completes with no errors, you can again right-click on the solution name in the Solution Explorer and click Deploy to provision the ARM resources defined in the template.&lt;/p&gt;
&lt;p&gt;Overall experience with authoring templates in Visual Studio is good. This method provides intellisense for different resource properties based on the template schema version.&lt;/p&gt;

    &lt;figure &gt;
        
            &lt;img src=&#34;https://ravichaganti.com/images/armin30/d2-visualstudiointelli.png&#34; width=&#34;560&#34; /&gt;
        
        
    &lt;/figure&gt;
    
&lt;p&gt;The editor experience in Visual Studio also provides insights into what might be wrong with certain resource property values and / or what might be missing therefore providing better editing experience.&lt;/p&gt;

    &lt;figure &gt;
        
            &lt;img src=&#34;https://ravichaganti.com/images/armin30/d2-visualstudioeditorexp.png&#34; width=&#34;560&#34; /&gt;
        
        
    &lt;/figure&gt;
    
&lt;p&gt;Overall, compared to the web editor in Azure portal, authoring experience in Visual Studio is way better. However, this is a heavy solution. On a decently configured system, it takes close to a minute to just open Visual Studio. Also, as you may have already seen, the starter templates do not support selecting the Azure quickstart templates from the GitHub repository. Within the template editor, you can auto-complete the resource property names once the resource type property is populated. However, there are no quick snippets that you can use directly. This, for me, kills productivity. There may be a few external marketplace extensions but there is no built-in support.&lt;/p&gt;
&lt;h3 id=&#34;visual-studio--code&#34;&gt;Visual Studio  Code&lt;/h3&gt;
&lt;p&gt;This is my favorite tool. No doubt. There are several reasons as you will read in this section. This tweet poll just endorses my choice.&lt;/p&gt;
&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;What is your favorite editor for authoring &lt;a href=&#34;https://twitter.com/Azure?ref_src=twsrc%5Etfw&#34;&gt;@Azure&lt;/a&gt; Resource Manager templates?&lt;/p&gt;&amp;mdash; Ravikanth Chaganti (@ravikanth) &lt;a href=&#34;https://twitter.com/ravikanth/status/1280058881322872833?ref_src=twsrc%5Etfw&#34;&gt;July 6, 2020&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;

&lt;p&gt;Throughout this series, you will see using VS Code only for authoring ARM templates. Therefore, I will skip any details similar to Visual Studio based template authoring experience you just read earlier. Now, moving on to why I like VS Code for ARM template authoring, first of all, VS Code is an open source, lightweight, and faster alternative to Visual Studio. The extension support within VS Code is unmatchable. With the official Azure extensions and a bunch of other community extensions, you can be super productive when working with the complex ARM template files. Before you get started with authoring an ARM template in VS Code, you must first install the right set of extensions that will help you in the authoring process. The following list is the minimum you will need to follow the articles in this series. Alternatively, you can install the &lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=ms-vscode.vscode-node-azure-pack&#34;&gt;Azure Tools extension pack&lt;/a&gt; that will install following three plus a bunch of other extensions that you may never need.&lt;/p&gt;
&lt;h4 id=&#34;azure-account&#34;&gt;Azure Account&lt;/h4&gt;
&lt;p&gt;The &lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=ms-vscode.azure-account&#34;&gt;Azure account&lt;/a&gt; VS Code extension allows you to sign into Azure and access your Azure subscriptions. This is necessary for other Azure extensions to function. Once you install this extension, you get a set of commands to sign in, sign out, select subscriptions, create Azure accounts, and open Azure Cloud Shell within VS Code.&lt;/p&gt;
&lt;h4 id=&#34;azure-resource-manager-arm-tools&#34;&gt;Azure Resource Manager (ARM) Tools&lt;/h4&gt;
&lt;p&gt;The &lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=msazurermtools.azurerm-vscode-tools&#34;&gt;ARM Tools extension&lt;/a&gt; is a must if you want to be productive authoring ARM templates in VS Code. This extension provides the full ARM template language support and provides a bunch of snippets to speed up the authoring process. You will see and use this extension a lot in the next parts of this article series and therefore I will not spend any more time on this here.&lt;/p&gt;
&lt;h4 id=&#34;azure-policy&#34;&gt;Azure Policy&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=AzurePolicy.azurepolicyextension&#34;&gt;Azure Policy&lt;/a&gt; extension can be used for authoring and managing policy definitions and assignments. This is in preview like a few other VS Code extensions. This is a good one to install as well as you follow this series of articles on Azure Resource Manager and want to try out Azure Policy related examples.&lt;/p&gt;
&lt;h4 id=&#34;azure-cli-tools&#34;&gt;Azure CLI Tools&lt;/h4&gt;
&lt;p&gt;Finally, the &lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=ms-vscode.azurecli&#34;&gt;Azure CLI Tools&lt;/a&gt; extension is what will help you when you author Azure CLI scripts to perform template deployments. This is an optional one if all you need is really the ability to run Azure CLI commands to validate and deploy templates within the VS Code terminal.&lt;/p&gt;
&lt;h2 id=&#34;deployment-tools&#34;&gt;Deployment Tools&lt;/h2&gt;
&lt;p&gt;There are many ways to deploy ARM templates. This includes using Azure portal, Azure CLI, Azure PowerShell cmdlets, ARM REST API, and Python or Go SDK.&lt;/p&gt;
&lt;h3 id=&#34;azure-portal&#34;&gt;Azure Portal&lt;/h3&gt;
&lt;p&gt;Azure Portal allows you to author templates in an online editor or upload templates for deployments or deploy from a collection of quick start templates. We looked at the an example of this in the previous section already. Using the template editor in the Azure portal, you can author and deploy or you can simply upload a template for deployment. Many places online (including the Azure Quickstart template repository), you see a &lt;a href=&#34;https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/deploy-to-azure-button&#34;&gt;Deploy to Azure&lt;/a&gt; button that directly takes to you the custom deployment page. You can use this method to deploy a template stored in an online public repository to perform resource group level deployments. Here is how it appears in a webpage.&lt;/p&gt;

    &lt;a href=&#34;https://portal.azure.com/#create/Microsoft.Template/uri/https%3a%2f%2fportal.azure.com%2f%23create%2fMicrosoft.Template%2furi%2fhttps%253A%252F%252Fraw.githubusercontent.com%252FAzure%252Fazure-quickstart-templates%252Fmaster%252F101-storage-account-create%252Fazuredeploy.json&#34; target=&#34;_blank&#34;&gt;
        &lt;img src=&#34;https://raw.githubusercontent.com/Azure/azure-quickstart-templates/master/1-CONTRIBUTION-GUIDE/images/deploytoazure.svg?sanitize=true&#34; alt=&#34;&#34;&gt;
    &lt;/a&gt;
    &lt;br /&gt;

&lt;p&gt;Clicking on the above button brings up the custom deployment blade asking for the input parameters needed for the template deployment.&lt;/p&gt;
&lt;h3 id=&#34;azure-cli&#34;&gt;Azure CLI&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.microsoft.com/en-us/cli/azure/?view=azure-cli-latest&#34;&gt;Azure CLI&lt;/a&gt; offers a method to deploy ARM templates as well. You can use the &lt;code&gt;az deployment&lt;/code&gt; command to perform template deployment.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/rchaganti/d7e35878c6687da07ae5fa5dfb7d54c2.js?file=deploytemplate.azcli&#34;&gt;&lt;/script&gt;

&lt;p&gt;With the &lt;code&gt;az deployment&lt;/code&gt; command, we can either use an online template file or local file.&lt;/p&gt;
&lt;h3 id=&#34;azure-powershell&#34;&gt;Azure PowerShell&lt;/h3&gt;
&lt;p&gt;Similar to Azure CLI, you can use &lt;a href=&#34;https://docs.microsoft.com/en-us/powershell/azure&#34;&gt;Azure PowerShell module&lt;/a&gt; as well to deploy ARM templates.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/rchaganti/d7e35878c6687da07ae5fa5dfb7d54c2.js?file=deploytemplate.ps1&#34;&gt;&lt;/script&gt;

&lt;p&gt;If you do not want to install any of these tools (Az CLI and Az PowerShell module) on your local system, you can always use Azure Cloud Shell within VS Code or launch Cloud Shell in the browser to start using any of these tools. Within this series of articles, you will occasionally see a button like the one displayed below. You can click on it to open &lt;a href=&#34;https://docs.microsoft.com/en-us/azure/cloud-shell/embed-cloud-shell&#34;&gt;Azure Cloud Shell&lt;/a&gt; and start performing command execution.&lt;/p&gt;

    &lt;a href=&#34;https://shell.azure.com/&#34; target=&#34;_blank&#34;&gt;
        &lt;img src=&#34;https://shell.azure.com/images/launchcloudshell.png&#34; alt=&#34;&#34;&gt;
    &lt;/a&gt;
    &lt;br /&gt;

&lt;h3 id=&#34;arm-rest-api&#34;&gt;ARM REST API&lt;/h3&gt;
&lt;p&gt;ARM REST API is another way to do template deployment but I consider this a bit low-level and requires good amount of scripting / programming experience.&lt;/p&gt;
&lt;p&gt;For most part of this series of articles on ARM, you will see Azure CLI examples. You will occasionally see a few Azure PowerShell examples. I will write about other deployment methods such as Terraform and Pulumi in a different series of articles. But, before you go there, it is good to get a good grasp of ARM fundamentals. Next few articles in this series of articles will dive into the ARM template authoring and deployment. For now, let us move on to discuss some features and services that work hand in hand with ARM.&lt;/p&gt;
&lt;h2 id=&#34;template-design-and-visualization-tools&#34;&gt;Template Design and visualization Tools&lt;/h2&gt;
&lt;p&gt;As a cloud consultant or architect, you have to create the cloud architecture proposals before you go into the implementation phase. There are a bunch of tools &amp;ndash; online and offline &amp;ndash; that can help you create the architecture diagrams for your cloud infrastructure proposals. In this final section of this post, you will get to know about a few tools that I have used or using to create these architecture diagrams.&lt;/p&gt;
&lt;p&gt;You can always use good old friend Microsoft Visio if you have a license for the product and I trust this a lot and use it. However, I will introduce other tools that you may find useful.&lt;/p&gt;
&lt;h3 id=&#34;arm-template-visualizer&#34;&gt;ARM template visualizer&lt;/h3&gt;
&lt;p&gt;The ARM template visualizer is not really a designer like Visio or any other tool you may see in this section but a good way to visualize an ARM template on a canvas. If you navigate to the ARM quickstart template GitHub repository, you will see a button like what is shown below.&lt;/p&gt;

    &lt;a href=&#34;http://armviz.io/#/?load=https%3a%2f%2fraw.githubusercontent.com%2fAzure%2fazure-quickstart-templates%2fmaster%2f101-1vm-2nics-2subnets-1vnet%2fazuredeploy.json&#34; target=&#34;_blank&#34;&gt;
        &lt;img src=&#34;https://raw.githubusercontent.com/Azure/azure-quickstart-templates/master/1-CONTRIBUTION-GUIDE/images/visualizebutton.svg?sanitize=true&#34; alt=&#34;&#34;&gt;
    &lt;/a&gt;
    &lt;br /&gt;

&lt;p&gt;And, when you on click on this button, it takes you to an ARM template visualizer where you can see the template in a visual form.&lt;/p&gt;

    &lt;figure &gt;
        
            &lt;img src=&#34;https://ravichaganti.com/images/armin30/d2-armviz.png&#34; width=&#34;860&#34; /&gt;
        
        
    &lt;/figure&gt;
    
&lt;p&gt;By default, the template visualization [1] opens up and you can click on &lt;em&gt;&amp;lt;/&amp;gt;&lt;/em&gt; [2] to see the ARM template JSON. You can edit the contents of the template and return back to the canvas to see the updated visualization. Going to the File menu, you can open a local template or download the template that is visualized.&lt;/p&gt;
&lt;h3 id=&#34;drawio&#34;&gt;Draw.io&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://draw.io&#34;&gt;Draw.io&lt;/a&gt; is a web-based tool that can help you design and save Azure architecture diagrams. There is a &lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=hediet.vscode-drawio&#34;&gt;VS Code extension&lt;/a&gt; as well for this and you can now create the diagrams right within VS Code.&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&#34;https://ravichaganti.com/images/armin30/d2-drawio.png&#34; width=&#34;860&#34;/&gt; 
&lt;/figure&gt;

&lt;h3 id=&#34;cloudskew&#34;&gt;Cloudskew&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cloudskew.com/&#34;&gt;Cloudskew&lt;/a&gt; is another web-based tool that provides a very nice canvas to create cloud architecture diagrams. This is also a free tool that offers several built-in cloud icon support.&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&#34;https://ravichaganti.com/images/armin30/d2-cloudskew.png&#34; width=&#34;860&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;There may be many other tools for ARM template design and visualization that I may not have tried yet. But, like I mentioned earlier, my trusted source is still good old Visio and I continue to use it.&lt;/p&gt;
&lt;p&gt;So far in this article, we looked at different authoring tools, deployment methods, and finally a few options to design and visualize these ARM templates. This should get you equipped with the right tools to get started with template authoring. In the next part of this series, we will look at the basics of template authoring. Stay tuned.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Azure Resource Manager - Introduction</title>
      <link>https://ravichaganti.com/blog/azure-resource-manager-introduction/</link>
      <pubDate>Thu, 16 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ravichaganti.com/blog/azure-resource-manager-introduction/</guid>
      <description>&lt;p&gt;A while ago, I had written a &lt;a href=&#34;https://ravichaganti.com/series/arm-templates/&#34;&gt;series of articles&lt;/a&gt; introducing and diving deep into authoring Azure Resource Manager (ARM) templates. A few things have changed in authoring ARM templates and new features got added in the recent past. I thought it is probably a better time to revisit and do it all over again. At the same time, I thought why just limit to just authoring ARM templates. Over the years, I made notes around ARM and learned quite a bit. Starting today, I will share those notes with you here.&lt;/p&gt;
&lt;p&gt;In this new and improved series, I will start from the very basics and build upon that in each article. The goal is to ensure I create a set of articles that can be referenced in a zero to hero approach to understand ARM and authoring ARM templates. So, without further ado, let us get started and let us start with the very basics.&lt;/p&gt;
&lt;h2 id=&#34;what-is-azure-resource-manager-arm&#34;&gt;What is Azure Resource Manager (ARM)?&lt;/h2&gt;
&lt;p&gt;Microsoft Azure, during the early days, had a management layer called Azure Service Manager (ASM) that was responsible for deploying and managing services. These services that you deployed using ASM were all independent entities without any grouping whatsoever. There was no way to define the dependencies either. So, if you were to implement a three-tier application as a set of cloud services, each service in the three-tier application had to be deployed individually and managed individually. When you have to delete this application, you had to do it by deleting each service individually. The same applies to updates as well. Monitoring and billing was a nightmare. This approach was not scalable. So, during &lt;a href=&#34;https://channel9.msdn.com/Events/Build/2014/2-607&#34;&gt;Build 2014&lt;/a&gt;, Microsoft announced a new deployment and management service called Azure Resource Manager (ARM).&lt;/p&gt;
&lt;p&gt;Here is a super simplified view of the ARM that provides an overview of the constructs.&lt;/p&gt;

    &lt;figure &gt;
        
            &lt;img src=&#34;https://ravichaganti.com/images/armin30/d1-armarch.png&#34; width=&#34;350&#34; /&gt;
        
        
    &lt;/figure&gt;
    
&lt;p&gt;With ARM, all your &lt;em&gt;&lt;strong&gt;resources&lt;/strong&gt;&lt;/em&gt; having a common life cycle (create/update/delete) can now be grouped together under a &lt;em&gt;&lt;strong&gt;resource group&lt;/strong&gt;&lt;/em&gt; and their life cycle management can be done together. A resource group becomes the unit of management. Each resource in Azure is supplied by a service known as a &lt;em&gt;&lt;strong&gt;resource provider&lt;/strong&gt;&lt;/em&gt;. The resources in Azure can be deployed in many ways but the focus of this series will be around the declarative &lt;em&gt;&lt;strong&gt;deployment templates&lt;/strong&gt;&lt;/em&gt; through which you can provision the resources in a consistent and idempotent manner.&lt;/p&gt;
&lt;p&gt;Let us dig a bit into the terminology you read in the above paragraph.&lt;/p&gt;
&lt;h2 id=&#34;azure-resources&#34;&gt;Azure Resources&lt;/h2&gt;
&lt;p&gt;Resources are what you provision in Azure cloud. For example, as shown in the above image, web apps, virtual machines, databases, and so on. Each resource will have certain properties that you can configure. What resources you can provision depends on what is allowed and / or enabled in your subscription. We will look at this in a later article.&lt;/p&gt;
&lt;h2 id=&#34;azure-resource-groups&#34;&gt;Azure Resource Groups&lt;/h2&gt;
&lt;p&gt;Resource group is a container for all resources that share a common life cycle. A resource should always exist in a resource group and can exist only in one group. It is not necessary that resources that have inter-dependencies are provisioned in the same resource group. These resources within a resource group can exist in different regions too. Instead, the life cycle of the resources is used as a way to group the resources together.&lt;/p&gt;
&lt;h2 id=&#34;azure-resource-providers&#34;&gt;Azure Resource Providers&lt;/h2&gt;
&lt;p&gt;The resource providers enable the resource and implement the management of the resources. Each resource that you can provision in Azure will have an associated resource provider. ARM binds all this together to provide a single management pane irrespective of what type of resource you are provisioning.&lt;/p&gt;
&lt;p&gt;There are several methods to interact with ARM for all your resource creation and management needs. These methods include Azure PowerShell module, Azure CLI, Azure SDKs for Golang, Python, and other languages. You can, of course, use the REST API directly to provision and manage resources. Through all these methods, you basically use individual commands or write scripts or you own applications to provision and manage resources. This approach is more imperative in nature. You write a script to implement what you need and at the same time you define how that needs to be done. In an imperative method, you perform checks to see if the resource that you are trying to provision already exists or not and provision only if it does not exist. You perform all error handling yourself in the imperative approach. And, if you were to create a lot of resources that do not necessarily depend on each other, you can write some parallel jobs to perform simultaneous execution of resource creation. But, the onus is on you to write this code and make sure it works.&lt;/p&gt;
&lt;h2 id=&#34;azure-resource-manager-templates&#34;&gt;Azure Resource Manager Templates&lt;/h2&gt;
&lt;p&gt;ARM templates help eliminate the need for the tedious and error-prone development of automation scripts using any of the methods you read about earlier. These templates are JSON files that provide a declarative syntax to provision Azure resources. Using the &lt;strong&gt;declarative&lt;/strong&gt; syntax of ARM templates, you define what infrastructure you need to provision and not how. With the increasing focus on Agile infrastructure practices and DevOps, this declarative template becomes a part of your application code and lives in the same source control repositories as your application. Any changes to the infrastructure configuration go through the same source control and application development procedures such as automation validations, continuous integration and delivery / deployment. This is what we describe as Infrastructure as Code (IaC).&lt;/p&gt;
&lt;p&gt;The ARM templates also offer a way to repeatedly deploy your infrastructure in Azure cloud. This is done in an &lt;strong&gt;idempotent&lt;/strong&gt; way. Idempotency means that the result of a provisioning task (state of the resources defined in the template) would be same irrespective of how many times you run the task.&lt;/p&gt;
&lt;p&gt;With ARM templates, unlike imperative scripting, you don&amp;rsquo;t have to worry about simultaneous resource creation or resource provisioning dependencies or error handling. ARM can infer these dependencies from what is defined in the template and also perform parallel execution when possible. This ensures &lt;strong&gt;reliable&lt;/strong&gt; deployment of resources defined in the template.&lt;/p&gt;
&lt;p&gt;In summary, &lt;em&gt;&lt;strong&gt;ARM templates offer a declarative method to provision your infrastructure resources in a reliable and idempotent manner&lt;/strong&gt;&lt;/em&gt;. There are several other aspects of ARM templates such as validation, extensions, and modularity / composability. You will read more about these characteristics in the upcoming parts of this series with relevant examples.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Apart from ARM templates, there are 3rd party providers such as &lt;a href=&#34;https://docs.microsoft.com/en-us/azure/developer/terraform/overview#:~:text=%20Terraform%20with%20Azure%20%201%20Automate%20infrastructure,configuring%20it%20to%20use%20Azure.%20%20More%20&#34;&gt;Terraform&lt;/a&gt; and &lt;a href=&#34;https://www.pulumi.com/azure/&#34;&gt;Pulumi&lt;/a&gt; for provisioning Azure infrastructure. These methods provide the same characteristics as ARM templates. Each of these methods have their pros and cons. This series of articles will only use ARM templates as a way to provision infrastructure.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;If you are interested in exploring what ARM templates look like or looking for a quick start for a specific resource type or scenario, you may look up &lt;a href=&#34;https://github.com/Azure/azure-quickstart-templates&#34;&gt;Azure Quickstart templates GitHub repository&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Writing and reading ARM templates can be very complex and may get boring as well! At Build 2020, Microsoft announced &lt;a href=&#34;https://youtu.be/UaVCNpD3pvg?t=986&#34;&gt;language revision&lt;/a&gt; that intends to provide a Domain Specific Language (DSL) abstraction that complies to a JSON template underneath and makes it easy for you to author complex ARM templates.&lt;/p&gt;

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/UaVCNpD3pvg?t=986&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;As this preview becomes available, I will write more about this new method here.&lt;/p&gt;
&lt;p&gt;After you author the ARM templates, you can deploy these templates using a variety of methods. You will read more about these methods in the next part of this series.&lt;/p&gt;
&lt;h2 id=&#34;azure-deployment-manager&#34;&gt;Azure Deployment Manager&lt;/h2&gt;
&lt;p&gt;As your organization grows and you start using Azure with multiple subscriptions and may be in multiple regions too, it becomes complex to perform an ordered and monitored rollout of Azure deployments. This is where &lt;a href=&#34;https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/deployment-manager-overview&#34;&gt;Azure Deployment Manager&lt;/a&gt; (ADM) comes into play. ADM extends ARM by enabling new features called &lt;em&gt;Service Topologies&lt;/em&gt; and &lt;em&gt;Rollouts&lt;/em&gt;.  ADM makes it easy to define complex deployments that span multiple regions and subscriptions and allows repeated deployments of these topologies using &lt;a href=&#34;https://docs.microsoft.com/en-us/rest/api/deploymentmanager/rollouts&#34;&gt;Rollouts&lt;/a&gt;. You will learn about this in-depth in later parts of this series.&lt;/p&gt;
&lt;h2 id=&#34;azure-governance&#34;&gt;Azure Governance&lt;/h2&gt;
&lt;p&gt;While knowing how to author and deploy ARM templates is an important part of working with Azure, it is equally important to know how to govern those resources and services deployed in Azure. As cloud architect, you would want control over who can create what type resources, where can they create those resources and how many. You would also want to standardize on the deployments so that the configuration of resources is in compliance with your organization standards. Among many other aspects like this you would want the ability to track your cloud cost more granularly for every service deployed in the cloud and for every business unit or group within your organization. To address this and to implement efficient governance Azure offers features and services such as &lt;a href=&#34;https://docs.microsoft.com/en-us/azure/governance/policy/overview&#34;&gt;Policies&lt;/a&gt;, &lt;a href=&#34;https://docs.microsoft.com/en-us/azure/governance/management-groups/&#34;&gt;Management Groups&lt;/a&gt;, &lt;a href=&#34;https://azure.microsoft.com/en-us/features/resource-graph/&#34;&gt;Resource Graph&lt;/a&gt;, and &lt;a href=&#34;https://docs.microsoft.com/en-us/azure/governance/blueprints/overview&#34;&gt;Blueprints&lt;/a&gt;. Here is an excellent depiction of Azure governance architecture from the &lt;a href=&#34;https://www.microsoft.com/en-us/us-partner-blog/2019/07/24/azure-governance/&#34;&gt;partner blog&lt;/a&gt;.&lt;/p&gt;

    &lt;figure &gt;
        
            &lt;img src=&#34;https://ravichaganti.com/images/armin30/d1-azuregovernance.png&#34; width=&#34;800&#34; /&gt;
        
        
    &lt;/figure&gt;
    
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Azure Policy&lt;/strong&gt;&lt;/em&gt; helps enforce your organizational IT and business standards for resource consistency, compliance to regulatory requirements, management, security, and cost. Azure offers a set of built-in policy definitions that are readily available for some of the common use cases in your Azure environment. You can, of course, create your own custom policy definitions as well.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Azure Management Groups&lt;/strong&gt;&lt;/em&gt; allow organizing subscriptions into containers called management groups and then perform governance on these management groups. The subscriptions under the management groups inherit the governance conditions (policies) applied at the management group level.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Azure Resource Graph&lt;/strong&gt;&lt;/em&gt; offers an efficient and performant way to query resources across multiple environments and subscriptions. This service can be used to extend management of Azure resources by enabling the ability to query resources with complex filtering, grouping, and sorting by resource properties. To use Azure Graph, you need to understand the Kusto Query Language (&lt;a href=&#34;https://docs.microsoft.com/en-us/azure/governance/resource-graph/concepts/query-language&#34;&gt;KQL&lt;/a&gt;). In this series of articles, you will see a basic overview of KQL and using Azure CLI to query the Resource Graph.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Azure Blueprints&lt;/strong&gt;&lt;/em&gt; enable streamlining of resource deployments by packaging ARM templates, policies, and role assignments. Blueprints are a declarative way to orchestrate these templates and other related artifacts. Blueprints enable efficient tracking and auditing of deployments. The knowledge you gain around ARM templates can be directly used with Azure Blueprints.&lt;/p&gt;
&lt;p&gt;With this quick overview of Azure governance features and service, you have an understanding of Azure Resource Manager and services that complement ARM. This brings us to the end of today&amp;rsquo;s article. The next few parts of this series will focus on authoring ARM templates. As described earlier, the ARM templates are JSON files and can be authored in notepad as well. But, there are some very good authoring tools and we will take a look at that in the next part of this series. Stay tuned!&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
