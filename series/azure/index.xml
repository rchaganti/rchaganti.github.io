<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Azure on Ravikanth Chaganti</title>
    <link>https://ravichaganti.com/series/azure/</link>
    <description>Recent content in Azure on Ravikanth Chaganti</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Wed, 02 Nov 2022 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://ravichaganti.com/series/azure/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Understanding and using Azure Container Instances service</title>
      <link>https://ravichaganti.com/blog/2022-11-02-understanding-and-using-azure-container-instances-service/</link>
      <pubDate>Wed, 02 Nov 2022 00:00:00 +0000</pubDate>
      
      <guid>https://ravichaganti.com/blog/2022-11-02-understanding-and-using-azure-container-instances-service/</guid>
      <description>&lt;p&gt;In an earlier article, we looked at &lt;a href=&#34;https://ravichaganti.com/blog/2022-11-01-containerization-in-azure&#34;&gt;different containerization options&lt;/a&gt; available in Microsoft Azure.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Containerization on Microsoft Azure</title>
      <link>https://ravichaganti.com/blog/2022-11-01-containerization-in-azure/</link>
      <pubDate>Tue, 01 Nov 2022 00:00:00 +0000</pubDate>
      
      <guid>https://ravichaganti.com/blog/2022-11-01-containerization-in-azure/</guid>
      <description>&lt;p&gt;Containerization is everywhere &amp;ndash; from on-premises data centers to the edge and in the cloud. We have been using containers right from development to production. I wrote about VS Code development containers and how &lt;a href=&#34;https://ravichaganti.com/blog/bicep-feature-in-vscode-devcontainer/&#34;&gt;I have standardized my development environment using devcontainers.&lt;/a&gt; There are several options for companies to run containerized applications in production. we can run individual application containers on a container host using engines like Docker. We can use tools like Docker &lt;a href=&#34;https://docs.docker.com/compose/&#34;&gt;Compose&lt;/a&gt; or &lt;a href=&#34;https://docs.docker.com/engine/swarm/&#34;&gt;Swarm&lt;/a&gt; for slightly complex multi-container, multi-host environments. However, it becomes complex to manage such environments. This needs us to implement a physical or virtualized server environment and handle all operational overhead associated with running our data center.&lt;/p&gt;
&lt;p&gt;Many cloud providers offer managed environments to run containerized applications. Microsoft Azure, too,  offers several options for running containerized applications.&lt;/p&gt;
&lt;h3 id=&#34;azure-container-instances-aci&#34;&gt;Azure Container Instances (ACI)&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://learn.microsoft.com/en-us/azure/container-instances/container-instances-overview&#34;&gt;ACI service&lt;/a&gt; offers the capability to spin a container in the Azure cloud, similar to running a container from an image using the &lt;code&gt;docker run&lt;/code&gt; command. With ACI, we can quickly deploy and scale containers for running short-lived and bursty workloads. We don&amp;rsquo;t need to worry about owning and deploying any infrastructure. ACI offers faster startup times. We can access the container instance using a Fully-Qualified Domain Name (FQDN). ACI integrates with other Azure services, such as Virtual Networks and Storage. We can use Azure PowerShell or Azure CLI to provision container instances in the Azure cloud.&lt;/p&gt;
&lt;p&gt;ACI uses the concept of container groups to group together multiple containers, deploy to the same host, share the same network, and share any mounted volumes. We can have up to 60 containers and 20 volumes per container group.&lt;/p&gt;
&lt;p&gt;ACI service runs containers inside a Hyper-V virtual machine to provide higher isolation levels. We can use resource requests to allocate CPU and memory per container group. ACI is not a container orchestrator like Kubernetes. Azure Container Instances can be virtual Azure Kubernetes Service (AKS) nodes.&lt;/p&gt;
&lt;h3 id=&#34;azure-kubernetes-service-aks&#34;&gt;Azure Kubernetes Service (AKS)&lt;/h3&gt;
&lt;p&gt;Azure Kubernetes Service is the hosted Kubernetes service from Azure. When using AKS, the operational overhead is offloaded to Azure. This is done by automatically provisioning the Kubernetes control plane. This control plane is provided at no additional cost, and we only pay for the worker nodes. An AKS cluster contains at least one node, an Azure virtual machine running the Kubernetes node components, and a container runtime. AKS supports thousands of nodes in a single cluster. In an AKS cluster, nodes are grouped as node pools based on the configuration. These node pools can contain both Windows and Linux nodes.&lt;/p&gt;
&lt;p&gt;AKS offers a built-in load balancer, automated scaling, and upgrades. We can use the recently used Kubernetes Fleet Manager (preview) for resource propagation and multi-cluster load balancing. While AKS offers an excellent way to run cloud-native applications and removes the overhead of managing a Kubernetes cluster, developers must still be aware of creating Kubernetes deployments specs written in YAML and managing the health of applications. This is where Azure Container Apps (ACA) help.&lt;/p&gt;
&lt;h3 id=&#34;azure-container-apps&#34;&gt;Azure Container Apps&lt;/h3&gt;
&lt;p&gt;Azure Container Apps (ACA) offer a fully managed serverless platform on which we can run microservices ad containerized applications. With ACA, we can run application code packaged in container format and not worry about managing cloud infrastructure. A group of containers share a secure environment within which all containers share the same network and write logs to the same destination. Azure handles the updates, resource balancing, scaling, and failover procedures. ACA supports Distributed Application Runtime (DAPR) and Kubernetes Event-Driven Autoscaling (KEDA) and is best suited for applications that implement microservice and event-driven architectures.&lt;/p&gt;
&lt;p&gt;In future posts, we will dive into each of these services, understand the concepts, implement applications, and finally gain the knowledge to help us decide to choose one of the services for our applications.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Publish container images to Azure Container Registry</title>
      <link>https://ravichaganti.com/blog/2022-10-29-publish-container-images-to-azure-container-registry/</link>
      <pubDate>Sat, 29 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://ravichaganti.com/blog/2022-10-29-publish-container-images-to-azure-container-registry/</guid>
      <description>&lt;p&gt;In the &lt;a href=&#34;https://ravichaganti.com/series/container-images/&#34;&gt;previous articles in this series&lt;/a&gt;, we looked at how to build container images and understand the OCI image specification that governs how the images are built and dealt with. Once the images are built, we may want to push them to a central repository for sharing with a larger community or a private container registry such as the Azure Container Registry (ACR).&lt;/p&gt;
&lt;p&gt;In today&amp;rsquo;s article, we shall learn how to create an Azure Container Registry, push an image, and consume it back in the local environment. Let&amp;rsquo;s start!&lt;/p&gt;
&lt;h3 id=&#34;azure-container-registry&#34;&gt;Azure Container Registry&lt;/h3&gt;
&lt;p&gt;ACR is a managed registry service based on open-source Docker Registry 2.0. Within our Azure subscription, we can create an instance of the ACR resource and use it for publishing the container images. The following Bicep template can be used to provision ACR.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;@minLength(5)
@maxLength(50)
@description(&amp;#39;Specify a globally unique name&amp;#39;)
param acrName string

@description(&amp;#39;Specify a location where the ACR must be created&amp;#39;)
param location string = resourceGroup().location

@description(&amp;#39;Specify the pricing tier of for ACR&amp;#39;)
param acrSku string = &amp;#39;Basic&amp;#39;

resource acrResource &amp;#39;Microsoft.ContainerRegistry/registries@2021-06-01-preview&amp;#39; = {
  name: acrName
  location: location
  sku: {
    name: acrSku
  }
  properties: {
    adminUserEnabled: false
  }
}

@description(&amp;#39;Login server information&amp;#39;)
output loginServer string = acrResource.properties.loginServer
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;We can provision this template using Azure PowerShell or Azure CLI.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;az deployment group create --resource-group bicep --template-file acr.bicep --parameters &lt;span class=&#34;nv&#34;&gt;acrName&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;acrbicepex&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;This Bicep template returns the login server FQDN as the output.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;outputs&amp;#34;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;nt&#34;&gt;&amp;#34;loginServer&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nt&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;String&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
    &lt;span class=&#34;nt&#34;&gt;&amp;#34;value&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;acrbicepex.azurecr.io&amp;#34;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Once an instance of ACR is available within the subscription, we can start pushing images to this registry and eventually pull images from this private registry. Optionally, we can import Docker Hub images to ACR.&lt;/p&gt;
&lt;h4 id=&#34;pushing-images-to-acr&#34;&gt;Pushing images to ACR&lt;/h4&gt;
&lt;p&gt;To try pushing images to ACR, let us first pull an image using docker CLI.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;docker pull ravikanth/bicep
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;We must re-tag (alias) the pulled image to indicate the remote Azure Container Registry we provisioned.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;docker tag ravikanth/bicep acrbicepex.azurecr.io/bicep:latest
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Before we can push to the ACR, we need to authenticate. For this, we need the Azure CLI.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;az login
az acr login --name acrbicepex.azurecr.io
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;We are now ready to push the image. This can be done using the &lt;code&gt;docker push&lt;/code&gt; command.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt; docker push acrbicepex.azurecr.io/bicep:latest
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id=&#34;pulling-an-image-from-acr&#34;&gt;Pulling an image from ACR&lt;/h4&gt;
&lt;p&gt;Pulling an image from ACR is the same as pulling one from the Docker Hub. We must refer to the right image location. And, since the ACR instance we created is a private registry, we must ensure that we authenticate to it before trying to pull an image.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;docker pull acrbicepex.azurecr.io/bicep:latest
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id=&#34;importing-docker-hub-images-to-acr&#34;&gt;Importing Docker Hub images to ACR&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;az acr import \
  --name acrbicepex \
  --source docker.io/library/ravikanth/hello-cloud:latest \
  --image hello-cloud:latest
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;In a later post, we shall see how ACR can be used with other container services in Azure.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
